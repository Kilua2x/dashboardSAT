<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Analítico Universal de Datos</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .card h2 {
            color: #3498db;
            font-size: 1.5rem;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .chart-container {
            height: 300px;
            position: relative;
            margin-bottom: 15px;
        }
        .chart-analysis {
            background-color: #f8f9fa;
            border-left: 3px solid #3498db;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 4px;
            font-size: 0.95rem;
        }
        .chart-analysis h4 {
            margin: 0 0 5px 0;
            color: #2c3e50;
        }
        .chart-analysis p {
            margin: 0;
            line-height: 1.5;
        }
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            flex: 1;
            min-width: 120px;
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }
        .stat-box:hover {
            transform: translateY(-3px);
        }
        .stat-box h3 {
            margin: 0;
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        .stat-box p {
            margin: 10px 0 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }
        .risk-high {
            border-left-color: #e74c3c;
        }
        .risk-medium {
            border-left-color: #f39c12;
        }
        .risk-none {
            border-left-color: #2ecc71;
        }
        .filters {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 150px;
        }
        .filter-group label {
            font-size: 0.9rem;
            color: #7f8c8d;
            font-weight: 600;
        }
        .filters input[type="file"], .filters input[type="text"] {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            flex: 1;
            min-width: 250px;
        }
        .filters select {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            width: 100%;
        }
        .data-source-tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .data-source-tab {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            background-color: #f8f9fa;
            margin-right: 5px;
            font-weight: 600;
        }
        .data-source-tab.active {
            background-color: white;
            border-bottom: 2px solid #3498db;
        }
        .data-source-content {
            display: none;
            margin-bottom: 10px;
        }
        .data-source-content.active {
            display: block;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        .btn-success {
            background-color: #2ecc71;
            color: white;
        }
        .btn-warning {
            background-color: #f39c12;
            color: white;
        }
        .btn-info {
            background-color: #16a085;
            color: white;
        }
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
        }
        .loader {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .loader div {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #3498db;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .alert-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .filter-badge {
            display: inline-block;
            padding: 5px 10px;
            background-color: #e9f7fd;
            color: #3498db;
            border-radius: 20px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .applied-filters {
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
            display: none;
        }
        .dynamic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .conclusions-section {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .conclusions-section h2 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .conclusion-card {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .conclusion-card h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .recommendation-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #2ecc71;
        }
        .recommendation-icon {
            background-color: #2ecc71;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            flex-shrink: 0;
        }
        .recommendation-content h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .recommendation-content p {
            margin: 0;
            color: #7f8c8d;
        }
        .priority-high .recommendation-icon {
            background-color: #e74c3c;
        }
        .priority-medium .recommendation-icon {
            background-color: #f39c12;
        }
        .header-custom {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
        }
        .report-title-input {
            width: 100%;
            padding: 10px;
            font-size: 1.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .report-subtitle-input {
            width: 100%;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        /* Estilos para sección de análisis predictivo */
        .predictive-section {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .correlation-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        .correlation-strong {
            background-color: #d4edda;
            color: #155724;
        }
        .correlation-moderate {
            background-color: #fff3cd;
            color: #856404;
        }
        .correlation-weak {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        .forecast-point {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
            background-color: #e9f7fd;
            color: #0c5460;
            border-left: 4px solid #3498db;
        }
        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .segment-card {
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            margin-bottom: 15px;
        }
        .segment-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .metric-item {
            background-color: #fff;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .metric-item h5 {
            margin: 0;
            font-size: 0.8rem;
            color: #7f8c8d;
        }
        .metric-item p {
            margin: 5px 0 0;
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        /* Estilos para selectores de campo */
        .field-selector-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .field-selector {
            flex: 1;
            min-width: 200px;
        }
        .print-options {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .print-options h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .print-checkbox {
            margin-right: 20px;
        }
        /* Estilos específicos para impresión */
        @page {
            size: A4;
            margin: 1.5cm;
        }
        @media print {
            body {
                background-color: white;
                padding: 0;
                margin: 0;
                font-size: 11pt;
            }
            .container {
                max-width: 100%;
                width: 100%;
                margin: 0;
                padding: 0;
            }
            .card {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
                page-break-inside: avoid;
                margin-bottom: 15mm;
                width: 100%;
            }
            .filters, .no-print, .btn-group, #loader, .alert, .data-source-tabs {
                display: none !important;
            }
            .header-custom {
                display: block !important;
                box-shadow: none;
                padding: 0;
                margin-bottom: 20mm;
                text-align: center;
            }
            .dashboard {
                display: block;
            }
            .full-width {
                width: 100%;
            }
            .chart-container {
                height: 130mm;
                max-height: 130mm;
                width: 100%;
                page-break-inside: avoid;
            }
            header {
                margin-bottom: 15mm;
                page-break-after: avoid;
            }
            h1, h2 {
                page-break-after: avoid;
            }
            table {
                font-size: 9pt;
                page-break-inside: avoid;
                width: 100%;
            }
            th, td {
                padding: 5px 8px;
            }
            .chart-analysis, .conclusion-card, .recommendation-item {
                border: 1px solid #ddd;
                border-left-width: 4px;
                page-break-inside: avoid;
            }
            .conclusions-section {
                page-break-before: always;
                box-shadow: none;
                border: 1px solid #ddd;
            }
            .recommendation-item {
                page-break-inside: avoid;
            }
            .applied-filters {
                margin-bottom: 10mm;
                background-color: transparent;
                border: 1px solid #ddd;
                padding: 5mm;
            }
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            .card:first-of-type {
                page-break-after: avoid;
            }
            .stat-box {
                break-inside: avoid;
            }
            .stats-container {
                page-break-inside: avoid;
            }
            /* Ajuste específico para tablas de datos */
            .data-table {
                font-size: 8pt;
            }
            .data-table th, .data-table td {
                padding: 3px 4px;
            }
            /* Asegurar que los análisis se impriman completos */
            p {
                orphans: 3;
                widows: 3;
            }
            /* Ocultar elementos que no son necesarios para la impresión */
            .print-hide {
                display: none !important;
            }
            /* Mostrar elementos específicos para impresión */
            .print-show {
                display: block !important;
            }
            /* Ocultar selectores de campo en la impresión */
            .field-selector-container, .print-options {
                display: none !important;
            }
            /* Agregar fecha y número de página */
            @bottom-right {
                content: "Página " counter(page) " de " counter(pages);
            }
            @bottom-left {
                content: "Generado el " attr(data-print-date);
            }
        }
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .stat-box {
                min-width: 100px;
            }
            .filters {
                flex-direction: column;
                align-items: stretch;
            }
            .btn-group {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }
        }
        .print-header, .print-footer {
            display: none;
        }
        @media print {
            .print-header, .print-footer {
                display: block;
                text-align: center;
            }
            .print-footer {
                position: fixed;
                bottom: 0;
                width: 100%;
                font-size: 9pt;
                color: #777;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dashboard Analítico Universal de Datos</h1>
            <p id="dashboard-description">Análisis avanzado de datos con identificación automática de patrones, predicción y generación de informes personalizados</p>
        </header>
        
        <div class="filters">
            <div class="data-source-tabs">
                <div class="data-source-tab active" data-tab="file-tab">Archivo Excel</div>
                <div class="data-source-tab" data-tab="sheets-tab">Google Sheets</div>
                <div class="data-source-tab" data-tab="config-tab">Configurar Informe</div>
            </div>
            
            <div class="data-source-content active" id="file-tab">
                <div class="filter-group">
                    <label for="excel-file">Cargar archivo Excel</label>
                    <input type="file" id="excel-file" accept=".xlsx, .xls, .csv" />
                </div>
            </div>
            
            <div class="data-source-content" id="sheets-tab">
                <div class="filter-group">
                    <label for="sheets-url">URL de Google Sheets (público o compartido)</label>
                    <input type="text" id="sheets-url" placeholder="Ej: https://docs.google.com/spreadsheets/d/..." />
                </div>
                <div class="filter-group">
                    <label for="sheets-tab-name">Nombre de la hoja (opcional)</label>
                    <input type="text" id="sheets-tab-name" placeholder="Hoja1" />
                </div>
            </div>
            
            <div class="data-source-content" id="config-tab">
                <div class="filter-group">
                    <label for="report-title">Título del informe</label>
                    <input type="text" id="report-title" placeholder="Informe de análisis de datos" value="Informe de análisis de datos" />
                </div>
                <div class="filter-group">
                    <label for="report-subtitle">Subtítulo</label>
                    <input type="text" id="report-subtitle" placeholder="Análisis detallado y recomendaciones" value="Análisis detallado y recomendaciones" />
                </div>
                <div class="filter-group">
                    <label for="report-color">Color principal</label>
                    <input type="color" id="report-color" value="#3498db" />
                </div>
            </div>
            
            <div class="btn-group">
                <button id="process-button" class="btn btn-primary">Procesar Datos</button>
                <button id="filter-button" class="btn btn-warning">Filtrar Datos</button>
                <button id="print-report" class="btn btn-success">Imprimir Informe</button>
            </div>
        </div>
        
        <div id="applied-filters" class="applied-filters">
            <h3>Filtros aplicados:</h3>
            <div id="filter-badges"></div>
            <div id="dynamic-filters" class="dynamic-filters"></div>
        </div>
        
        <div id="success-alert" class="alert alert-success">
            Datos procesados correctamente. El dashboard ha sido actualizado.
        </div>
        
        <div id="error-alert" class="alert alert-danger">
            Error al procesar el archivo. Asegúrese de que sea un archivo válido con la estructura correcta.
        </div>
        
        <div id="info-alert" class="alert alert-info">
            Seleccione los campos adecuados para realizar el análisis completo.
        </div>
        
        <div id="loader" class="loader">
            <div></div>
            <span>Procesando datos...</span>
        </div>
        
        <!-- Cabecera personalizada para impresión -->
        <div id="header-custom" class="header-custom print-show">
            <h1 id="print-title">Informe de análisis de datos</h1>
            <p id="print-subtitle">Análisis detallado y recomendaciones</p>
            <p id="print-date">Fecha: <span id="current-date"></span></p>
        </div>
        
        <div id="dashboard-content">
            <!-- El contenido del dashboard se generará dinámicamente basado en los datos cargados -->
            <section class="dashboard" id="dashboard-container">
                <div class="card full-width">
                    <h2>Bienvenido al Dashboard Analítico</h2>
                    <p>Para comenzar, siga estos pasos:</p>
                    <ol>
                        <li>Cargue un archivo Excel o proporcione una URL de Google Sheets</li>
                        <li>Haga clic en "Procesar Datos" para generar el análisis automático</li>
                        <li>Utilice las opciones de filtrado para explorar segmentos específicos de datos</li>
                        <li>Imprima el informe completo para compartirlo</li>
                    </ol>
                    <p>El sistema detectará automáticamente patrones, tendencias y relaciones en sus datos, generando visualizaciones, análisis estadístico avanzado y pronósticos predictivos.</p>
                </div>
            </section>
            
            <section class="conclusions-section" id="conclusions-section">
                <h2>Diagnóstico Integral y Recomendaciones Estratégicas</h2>
                
                <div class="conclusion-card">
                    <h3>Diagnóstico General</h3>
                    <p id="general-conclusion">Cargue sus datos para generar un análisis automático y recomendaciones personalizadas.</p>
                </div>
                
                <h3>Recomendaciones Estratégicas Basadas en Evidencia</h3>
                
                <div id="recommendations-container">
                    <!-- Las recomendaciones se generarán dinámicamente -->
                    <div class="recommendation-item">
                        <div class="recommendation-icon">i</div>
                        <div class="recommendation-content">
                            <h4>No hay recomendaciones disponibles</h4>
                            <p>Cargue sus datos para recibir recomendaciones personalizadas basadas en el análisis.</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
        
        <!-- Pie de página para impresión -->
        <div class="print-footer">
            <p>Generado automáticamente - Página <span class="page-number"></span></p>
        </div>
    </div>

    <!-- Scripts necesarios -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        // Objeto para almacenar las instancias de gráficos
        const charts = {};
        
        // Almacenar los datos sin filtrar
        let originalData = null;
        
        // Configuración de estilos
        const reportStyles = {
            primaryColor: '#3498db',
            secondaryColor: '#2ecc71',
            accentColor: '#e74c3c',
            neutralColor: '#f39c12'
        };
        
        // Configuración de impresión
        const printOptions = {
            includeDataTable: true,
            includePredictions: true,
            includeCorrelations: true,
            includeSegments: true,
            includeRecommendations: true
        };
        
        // Datos globales
        let globalData = {
            totalRecords: 0,
            fields: {},
            categories: {},
            numerics: {},
            dates: {},
            appliedFilters: {},
            rawData: [],
            selectedFields: {} // Para almacenar los campos seleccionados por el usuario
        };
        
        // Función para inicializar la interfaz
        document.addEventListener('DOMContentLoaded', function() {
            // Verificar si Chart.js está disponible
            if (typeof Chart === 'undefined') {
                console.error('Chart.js no está cargado. No se pueden crear gráficos.');
                showAlert('error-alert', 'Error: La biblioteca Chart.js no está disponible. Verifique su conexión a internet y recargue la página.');
                return;
            }
            
            console.log('Chart.js está disponible, versión:', Chart.version);
            
            // Establecer la fecha actual para el informe
            const now = new Date();
            document.getElementById('current-date').textContent = now.toLocaleDateString();
            document.body.setAttribute('data-print-date', now.toLocaleDateString());
            
            // Eventos para las pestañas de fuente de datos
            document.querySelectorAll('.data-source-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.data-source-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.data-source-content').forEach(c => c.classList.remove('active'));
                    
                    this.classList.add('active');
                    document.getElementById(this.getAttribute('data-tab')).classList.add('active');
                });
            });
            
            // Evento para procesar datos
            document.getElementById('process-button').addEventListener('click', function() {
                const fileInput = document.getElementById('excel-file');
                const sheetsUrl = document.getElementById('sheets-url');
                
                if (fileInput.files.length > 0) {
                    processExcelFile(fileInput.files[0]);
                } else if (sheetsUrl.value.trim() !== '') {
                    processGoogleSheets(sheetsUrl.value, document.getElementById('sheets-tab-name').value);
                } else {
                    showAlert('error-alert', 'Por favor, seleccione un archivo Excel o proporcione una URL de Google Sheets válida.');
                }
            });
            
            // Evento para abrir panel de filtros
            document.getElementById('filter-button').addEventListener('click', function() {
                if (!globalData.rawData || globalData.rawData.length === 0) {
                    showAlert('info-alert', 'Primero debe cargar y procesar datos para poder filtrarlos.');
                    return;
                }
                
                toggleFilterPanel();
            });
            
            // Evento para imprimir informe
            document.getElementById('print-report').addEventListener('click', printReport);
            
            // Evento para cambio de título y subtítulo del informe
            document.getElementById('report-title').addEventListener('input', function() {
                document.getElementById('print-title').textContent = this.value;
            });
            
            document.getElementById('report-subtitle').addEventListener('input', function() {
                document.getElementById('print-subtitle').textContent = this.value;
            });
            
            // Evento para cambio de color principal
            document.getElementById('report-color').addEventListener('change', function() {
                reportStyles.primaryColor = this.value;
                updateChartsColors();
            });
        });
        
        // Función para mostrar alertas
        function showAlert(alertId, message, duration = 3000) {
            const alert = document.getElementById(alertId);
            alert.textContent = message;
            alert.style.display = 'block';
            
            setTimeout(() => {
                alert.style.display = 'none';
            }, duration);
        }
        
        // Función para procesar archivo Excel
        function processExcelFile(file) {
            document.getElementById('loader').style.display = 'block';
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    console.log('Archivo Excel cargado correctamente.');
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    console.log(`Datos extraídos: ${jsonData.length} registros`);
                    
                    // Procesar los datos
                    processData(jsonData);
                    
                    // Guardar los datos originales para aplicar filtros después
                    originalData = JSON.parse(JSON.stringify(globalData));
                    
                    // Generar visualizaciones y análisis
                    generateDashboard();
                    
                    // Mostrar mensaje de éxito
                    showAlert('success-alert', 'Datos procesados correctamente. El dashboard ha sido actualizado.');
                } catch (error) {
                    console.error('Error al procesar el archivo:', error);
                    showAlert('error-alert', 'Error al procesar el archivo: ' + error.message);
                } finally {
                    document.getElementById('loader').style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error al leer el archivo.');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Función para procesar datos de Google Sheets
        function processGoogleSheets(url, tabName) {
            document.getElementById('loader').style.display = 'block';
            
            try {
                // Convertir URL de Google Sheets a CSV
                const csvUrl = convertSheetsToCsvUrl(url, tabName);
                
                // Informar al usuario sobre posibles problemas de CORS
                showAlert('info-alert', 'Intentando acceder a Google Sheets. Si hay problemas de CORS, considere descargar y usar el archivo localmente.', 5000);
                
                // Usar un proxy CORS público o sugerir una solución alternativa
                const proxyUrl = `https://cors-anywhere.herokuapp.com/${csvUrl}`;
                
                fetch(proxyUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('No se pudo acceder a la hoja. Asegúrese de que sea pública o esté compartida correctamente.');
                        }
                        return response.text();
                    })
                    .then(csvData => {
                        // Convertir CSV a JSON
                        const jsonData = parseCsvToJson(csvData);
                        
                        console.log(`Datos de Google Sheets extraídos: ${jsonData.length} registros`);
                        
                        // Procesar los datos
                        processData(jsonData);
                        
                        // Guardar los datos originales para aplicar filtros después
                        originalData = JSON.parse(JSON.stringify(globalData));
                        
                        // Generar visualizaciones y análisis
                        generateDashboard();
                        
                        // Mostrar mensaje de éxito
                        showAlert('success-alert', 'Datos procesados correctamente. El dashboard ha sido actualizado.');
                    })
                    .catch(error => {
                        console.error('Error al procesar Google Sheets:', error);
                        showAlert('error-alert', 'Error al acceder a Google Sheets: ' + error.message + 
                                '. Para evitar problemas de CORS, descargue la hoja como Excel y cárguela directamente.');
                    })
                    .finally(() => {
                        document.getElementById('loader').style.display = 'none';
                    });
            } catch (error) {
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error: ' + error.message);
            }
        }
        
        // Función para convertir URL de Google Sheets a URL de CSV
        function convertSheetsToCsvUrl(url, tabName) {
            // Extraer el ID de la hoja de la URL
            let sheetId = '';
            const regex = /\/d\/([a-zA-Z0-9-_]+)/;
            const match = url.match(regex);
            
            if (match && match[1]) {
                sheetId = match[1];
            } else {
                throw new Error('URL de Google Sheets no válida.');
            }
            
            // Construir la URL de exportación CSV
            let csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
            
            // Agregar nombre de la pestaña si se proporciona
            if (tabName && tabName.trim() !== '') {
                csvUrl += `&gid=0&sheet=${encodeURIComponent(tabName.trim())}`;
            }
            
            return csvUrl;
        }
        
        // Función para parsear CSV a JSON
        function parseCsvToJson(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(header => header.trim().replace(/^"|"$/g, ''));
            
            const jsonData = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                const obj = {};
                
                headers.forEach((header, index) => {
                    if (index < values.length) {
                        obj[header] = values[index];
                    } else {
                        obj[header] = '';
                    }
                });
                
                jsonData.push(obj);
            }
            
            return jsonData;
        }
        
        // Función para parsear una línea CSV respetando comillas
        function parseCSVLine(line) {
            const result = [];
            let insideQuotes = false;
            let currentValue = '';
            
            for (let i = 0; i < line.length; i++) {
                if (line[i] === '"') {
                    insideQuotes = !insideQuotes;
                } else if (line[i] === ',' && !insideQuotes) {
                    result.push(currentValue.replace(/^"|"$/g, ''));
                    currentValue = '';
                } else {
                    currentValue += line[i];
                }
            }
            
            // Agregar el último valor
            result.push(currentValue.replace(/^"|"$/g, ''));
            
            return result;
        }
        
        // Función para procesar los datos
        function processData(jsonData) {
            try {
                console.log(`Procesando datos con ${jsonData.length} registros`);
                
                // Resetear datos globales
                globalData = {
                    totalRecords: jsonData.length,
                    fields: {},
                    categories: {},
                    numerics: {},
                    dates: {},
                    appliedFilters: {},
                    rawData: jsonData,
                    selectedFields: {}
                };
                
                // Si no hay datos, salir
                if (jsonData.length === 0) {
                    console.warn('No hay datos para procesar');
                    return;
                }
                
                // Obtener todas las claves de los datos
                const fieldNames = Object.keys(jsonData[0]);
                console.log(`Se encontraron ${fieldNames.length} campos:`, fieldNames);
                
                // Analizar cada campo para detectar su tipo
                fieldNames.forEach(field => {
                    try {
                        globalData.fields[field] = analyzeField(jsonData, field);
                        console.log(`Campo ${field} analizado como ${globalData.fields[field].type}`);
                    } catch (fieldError) {
                        console.error(`Error al analizar el campo ${field}:`, fieldError);
                        // Proporcionar información predeterminada en caso de error
                        globalData.fields[field] = {
                            name: field,
                            type: 'unknown',
                            uniqueValues: [],
                            distribution: {},
                            stats: {}
                        };
                    }
                });
                
                // Clasificar campos por tipo
                fieldNames.forEach(field => {
                    const fieldInfo = globalData.fields[field];
                    
                    if (fieldInfo.type === 'date') {
                        globalData.dates[field] = fieldInfo;
                    } else if (fieldInfo.type === 'numeric') {
                        globalData.numerics[field] = fieldInfo;
                    } else if (fieldInfo.type === 'categorical') {
                        globalData.categories[field] = fieldInfo;
                    }
                });
                
                console.log(`Clasificación de campos: ${Object.keys(globalData.categories).length} categóricos, ${Object.keys(globalData.numerics).length} numéricos, ${Object.keys(globalData.dates).length} fechas`);
                
                // Inicializar los campos seleccionados
                initializeSelectedFields();
                
                console.log('Procesamiento de datos completado');
            } catch (error) {
                console.error('Error en processData:', error);
                showAlert('error-alert', 'Error al procesar los datos: ' + error.message);
            }
        }
        
        // Función para inicializar los campos seleccionados
        function initializeSelectedFields() {
            // Inicializar con los primeros campos disponibles
            globalData.selectedFields = {
                categories: [],
                numerics: []
            };
            
            // Seleccionar el primer campo categórico disponible
            const categoryFields = Object.keys(globalData.categories);
            if (categoryFields.length > 0) {
                globalData.selectedFields.categories.push(categoryFields[0]);
            }
            
            // Seleccionar los primeros 3 campos numéricos disponibles
            const numericFields = Object.keys(globalData.numerics);
            for (let i = 0; i < Math.min(numericFields.length, 3); i++) {
                globalData.selectedFields.numerics.push(numericFields[i]);
            }
        }
        
        // Función para analizar un campo y determinar su tipo y estadísticas
        function analyzeField(data, fieldName) {
            try {
                console.log(`Analizando campo: ${fieldName}`);
                
                const fieldInfo = {
                    name: fieldName,
                    type: 'unknown',
                    uniqueValues: new Set(),
                    distribution: {},
                    stats: {}
                };
                
                // Recopilar valores y contarlos
                const values = [];
                let validCount = 0;
                let missingCount = 0;
                
                data.forEach(record => {
                    const value = record[fieldName];
                    
                    if (value !== undefined && value !== null && value !== '') {
                        fieldInfo.uniqueValues.add(value);
                        
                        if (!fieldInfo.distribution[value]) {
                            fieldInfo.distribution[value] = 0;
                        }
                        fieldInfo.distribution[value]++;
                        validCount++;
                        
                        // Intentar convertir a número
                        const numValue = Number(value);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    } else {
                        missingCount++;
                    }
                });
                
                console.log(`Campo ${fieldName}: ${validCount} valores válidos, ${missingCount} valores faltantes, ${fieldInfo.uniqueValues.size} valores únicos`);
                
                // Determinar tipo de campo
                if (isDateField(data, fieldName)) {
                    fieldInfo.type = 'date';
                    console.log(`Campo ${fieldName} identificado como campo de fecha`);
                } else if (values.length > 0 && values.length >= validCount * 0.8) {
                    fieldInfo.type = 'numeric';
                    console.log(`Campo ${fieldName} identificado como campo numérico`);
                    
                    // Calcular estadísticas para campo numérico
                    fieldInfo.stats = calculateNumericStats(values);
                } else if (fieldInfo.uniqueValues.size <= Math.min(20, data.length * 0.2)) {
                    fieldInfo.type = 'categorical';
                    console.log(`Campo ${fieldName} identificado como campo categórico con ${fieldInfo.uniqueValues.size} categorías`);
                    
                    // Calcular estadísticas para campo categórico
                    fieldInfo.stats = calculateCategoricalStats(fieldInfo.distribution, data.length);
                } else {
                    fieldInfo.type = 'text';
                    console.log(`Campo ${fieldName} identificado como campo de texto`);
                    
                    // Calcular estadísticas básicas para campo de texto
                    fieldInfo.stats = calculateTextStats(fieldInfo.distribution, data.length, validCount, missingCount);
                }
                
                // Convertir Set a Array para facilitar serialización
                fieldInfo.uniqueValues = Array.from(fieldInfo.uniqueValues);
                
                return fieldInfo;
            } catch (error) {
                console.error(`Error al analizar campo ${fieldName}:`, error);
                return {
                    name: fieldName,
                    type: 'unknown',
                    uniqueValues: [],
                    distribution: {},
                    stats: {}
                };
            }
        }
        
        // Función para verificar si un campo parece ser fecha
        function isDateField(data, fieldName) {
            // Verificar los primeros 20 registros (o menos)
            const sampleSize = Math.min(20, data.length);
            let dateCount = 0;
            
            for (let i = 0; i < sampleSize; i++) {
                if (i < data.length) {
                    const value = data[i][fieldName];
                    if (value) {
                        const date = new Date(value);
                        if (!isNaN(date.getTime())) {
                            dateCount++;
                        }
                    }
                }
            }
            
            // Si más del 80% de los valores de la muestra son fechas válidas
            return dateCount >= sampleSize * 0.8;
        }
        
        // Función para calcular estadísticas de campo categórico
        function calculateCategoricalStats(distribution, totalCount) {
            try {
                const valueCount = Object.keys(distribution).length;
                const values = Object.values(distribution);
                
                if (values.length === 0) {
                    return {
                        count: 0,
                        unique: 0,
                        mostFrequent: null,
                        mostFrequentCount: 0,
                        mostFrequentPercentage: 0
                    };
                }
                
                // Encontrar el valor más frecuente
                let maxValue = '';
                let maxCount = 0;
                
                Object.entries(distribution).forEach(([value, count]) => {
                    if (count > maxCount) {
                        maxValue = value;
                        maxCount = count;
                    }
                });
                
                return {
                    count: values.reduce((a, b) => a + b, 0),
                    unique: valueCount,
                    mostFrequent: maxValue,
                    mostFrequentCount: maxCount,
                    mostFrequentPercentage: (maxCount / totalCount) * 100
                };
            } catch (error) {
                console.error('Error en calculateCategoricalStats:', error);
                return {
                    count: 0,
                    unique: 0,
                    mostFrequent: null,
                    mostFrequentCount: 0,
                    mostFrequentPercentage: 0
                };
            }
        }
        
        // Función para calcular estadísticas básicas de campo de texto
        function calculateTextStats(distribution, totalCount, validCount, missingCount) {
            return {
                count: validCount,
                unique: Object.keys(distribution).length,
                missing: missingCount,
                missingPercentage: (missingCount / totalCount) * 100
            };
        }
        
        // Función mejorada para calcular estadísticas de un campo numérico
        function calculateNumericStats(values) {
            try {
                if (values.length === 0) {
                    return {
                        min: 0,
                        max: 0,
                        mean: 0,
                        median: 0,
                        sum: 0,
                        std: 0,
                        count: 0,
                        q1: 0,
                        q3: 0,
                        iqr: 0,
                        skewness: 0,
                        kurtosis: 0,
                        outliers: []
                    };
                }
                
                // Ordenar valores para cálculos estadísticos
                const sortedValues = [...values].sort((a, b) => a - b);
                
                const min = sortedValues[0];
                const max = sortedValues[sortedValues.length - 1];
                const sum = sortedValues.reduce((acc, val) => acc + val, 0);
                const mean = sum / sortedValues.length;
                
                // Calcular mediana
                const mid = Math.floor(sortedValues.length / 2);
                const median = sortedValues.length % 2 === 0
                    ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
                    : sortedValues[mid];
                
                // Calcular cuartiles
                const q1Index = Math.floor(sortedValues.length * 0.25);
                const q3Index = Math.floor(sortedValues.length * 0.75);
                const q1 = sortedValues[q1Index];
                const q3 = sortedValues[q3Index];
                const iqr = q3 - q1;
                
                // Calcular desviación estándar
                const squaredDiffs = sortedValues.map(val => Math.pow(val - mean, 2));
                const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / sortedValues.length;
                const std = Math.sqrt(variance);
                
                // Calcular asimetría (skewness)
                const cubeSum = values.reduce((acc, val) => acc + Math.pow(val - mean, 3), 0);
                const skewness = cubeSum / (values.length * Math.pow(std, 3)) || 0;
                
                // Calcular curtosis
                const fourthPowerSum = values.reduce((acc, val) => acc + Math.pow(val - mean, 4), 0);
                const kurtosis = fourthPowerSum / (values.length * Math.pow(variance, 2)) - 3 || 0;
                
                // Detectar outliers usando el método IQR
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;
                const outliers = values.filter(val => val < lowerBound || val > upperBound);
                
                return {
                    min,
                    max,
                    mean,
                    median,
                    sum,
                    std,
                    count: values.length,
                    q1,
                    q3,
                    iqr,
                    skewness,
                    kurtosis,
                    outliers,
                    lowerBound,
                    upperBound
                };
            } catch (error) {
                console.error('Error en calculateNumericStats:', error);
                return {
                    min: 0,
                    max: 0,
                    mean: 0,
                    median: 0,
                    sum: 0,
                    std: 0,
                    count: 0,
                    q1: 0,
                    q3: 0,
                    iqr: 0,
                    skewness: 0,
                    kurtosis: 0,
                    outliers: []
                };
            }
        }
        
        // Función para calcular la correlación entre dos variables numéricas
        function calculateCorrelation(data, field1, field2) {
            // Extraer pares de valores válidos
            const pairs = [];
            
            data.forEach(record => {
                const val1 = Number(record[field1]);
                const val2 = Number(record[field2]);
                
                if (!isNaN(val1) && !isNaN(val2)) {
                    pairs.push([val1, val2]);
                }
            });
            
            if (pairs.length < 2) return { correlation: 0, pairs: [], strength: 'insuficientes datos' };
            
            // Calcular medias
            const mean1 = pairs.reduce((sum, pair) => sum + pair[0], 0) / pairs.length;
            const mean2 = pairs.reduce((sum, pair) => sum + pair[1], 0) / pairs.length;
            
            // Calcular componentes de correlación
            let numerator = 0;
            let denom1 = 0;
            let denom2 = 0;
            
            pairs.forEach(pair => {
                const diff1 = pair[0] - mean1;
                const diff2 = pair[1] - mean2;
                
                numerator += diff1 * diff2;
                denom1 += diff1 * diff1;
                denom2 += diff2 * diff2;
            });
            
            // Calcular coeficiente de correlación de Pearson
            const correlation = (denom1 > 0 && denom2 > 0) 
                ? numerator / Math.sqrt(denom1 * denom2)
                : 0;
            
            // Determinar la fuerza de la correlación
            let strength = 'nula';
            const absCorr = Math.abs(correlation);
            
            if (absCorr >= 0.9) strength = 'muy fuerte';
            else if (absCorr >= 0.7) strength = 'fuerte';
            else if (absCorr >= 0.5) strength = 'moderada';
            else if (absCorr >= 0.3) strength = 'débil';
            else if (absCorr >= 0.1) strength = 'muy débil';
            
            // Determinar la dirección
            const direction = correlation > 0 ? 'positiva' : correlation < 0 ? 'negativa' : 'nula';
            
            return {
                correlation,
                pairs: pairs.length,
                strength,
                direction
            };
        }
        
        // Función para realizar análisis de tendencias y predicción
        function analyzeTrendAndPredict(periods, values, numPredictions = 3) {
            if (periods.length < 4) {
                return {
                    trend: 'insuficientes datos',
                    prediction: [],
                    confidence: 'baja',
                    equation: ''
                };
            }
            
            // Crear índices numéricos para los períodos
            const indices = Array.from({length: periods.length}, (_, i) => i);
            
            // Calcular la línea de tendencia (regresión lineal)
            const n = indices.length;
            const sumX = indices.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
            const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);
            
            // Calcular pendiente e intercepto
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Función para calcular valores de tendencia
            const trendLine = x => slope * x + intercept;
            
            // Calcular valores de tendencia para los puntos existentes
            const trendValues = indices.map(trendLine);
            
            // Calcular R-cuadrado (coeficiente de determinación)
            const meanY = sumY / n;
            const totalVariation = values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
            const residualVariation = values.reduce((sum, y, i) => sum + Math.pow(y - trendValues[i], 2), 0);
            const rSquared = 1 - (residualVariation / totalVariation);
            
            // Determinar la fuerza y dirección de la tendencia
            let trendStrength = 'indeterminada';
            if (rSquared > 0.7) trendStrength = 'fuerte';
            else if (rSquared > 0.4) trendStrength = 'moderada';
            else if (rSquared > 0.2) trendStrength = 'débil';
            else trendStrength = 'no significativa';
            
            const trendDirection = slope > 0 ? 'creciente' : slope < 0 ? 'decreciente' : 'estable';
            
            // Realizar predicciones para futuros períodos
            const predictions = [];
            for (let i = 0; i < numPredictions; i++) {
                const nextIndex = indices.length + i;
                const predictedValue = trendLine(nextIndex);
                predictions.push({
                    index: nextIndex,
                    value: predictedValue
                });
            }
            
            // Calcular el nivel de confianza basado en R-cuadrado
            let confidence = 'baja';
            if (rSquared > 0.8) confidence = 'alta';
            else if (rSquared > 0.5) confidence = 'media';
            
            // Crear ecuación de la línea de tendencia
            const equation = `y = ${slope.toFixed(4)}x + ${intercept.toFixed(2)}`;
            
            return {
                trend: `${trendDirection} (${trendStrength})`,
                prediction: predictions,
                slope,
                intercept,
                rSquared,
                confidence,
                equation,
                trendValues
            };
        }
        
        // Función para análisis avanzado de series temporales
        function analyzeTimeSeries(periods, values) {
            if (periods.length < 6) {
                return {
                    trend: 'insuficientes datos',
                    seasonality: 'indeterminada',
                    cyclical: 'indeterminada',
                    forecast: []
                };
            }
            
            // Calcular tendencia usando regresión lineal
            const trendAnalysis = analyzeTrendAndPredict(periods, values, 3);
            
            // Eliminar la tendencia para buscar estacionalidad
            const detrended = values.map((value, i) => value - trendAnalysis.trendValues[i]);
            
            // Análisis simple de estacionalidad
            let hasSeasonality = false;
            let seasonalityStrength = 'no detectada';
            let seasonalityPeriod = 0;
            
            // Verificar patrones estacionales para diferentes períodos
            const potentialPeriods = [3, 4, 6, 12]; // trimestral, cuatrimestral, semestral, anual
            
            // Verificar autocorrelación para diferentes lags
            for (const period of potentialPeriods) {
                if (periods.length < period * 2) continue;
                
                let autocorrelation = 0;
                let count = 0;
                
                for (let i = 0; i < detrended.length - period; i++) {
                    autocorrelation += detrended[i] * detrended[i + period];
                    count++;
                }
                
                if (count > 0) {
                    autocorrelation /= count;
                    
                    // Normalizar la autocorrelación
                    const variance = detrended.reduce((sum, val) => sum + val * val, 0) / detrended.length;
                    const normalizedAutocorr = variance > 0 ? autocorrelation / variance : 0;
                    
                    if (Math.abs(normalizedAutocorr) > 0.3) {
                        hasSeasonality = true;
                        seasonalityPeriod = period;
                        
                        if (Math.abs(normalizedAutocorr) > 0.7) seasonalityStrength = 'fuerte';
                        else if (Math.abs(normalizedAutocorr) > 0.5) seasonalityStrength = 'moderada';
                        else seasonalityStrength = 'débil';
                        
                        break;
                    }
                }
            }
            
            // Calcular componentes estacionales si se detecta estacionalidad
            let seasonalComponents = [];
            if (hasSeasonality && seasonalityPeriod > 0) {
                const seasonalAvgs = Array(seasonalityPeriod).fill(0);
                const seasonalCounts = Array(seasonalityPeriod).fill(0);
                
                // Calcular promedios estacionales
                for (let i = 0; i < detrended.length; i++) {
                    const seasonIndex = i % seasonalityPeriod;
                    seasonalAvgs[seasonIndex] += detrended[i];
                    seasonalCounts[seasonIndex]++;
                }
                
                for (let i = 0; i < seasonalityPeriod; i++) {
                    if (seasonalCounts[i] > 0) {
                        seasonalAvgs[i] /= seasonalCounts[i];
                    }
                }
                
                // Normalizar componentes estacionales para que sumen cero
                const avgSeasonal = seasonalAvgs.reduce((sum, val) => sum + val, 0) / seasonalityPeriod;
                seasonalComponents = seasonalAvgs.map(val => val - avgSeasonal);
            }
            
            // Generar pronósticos combinando tendencia y estacionalidad
            const forecast = [];
            const numPredictions = 3;
            
            for (let i = 0; i < numPredictions; i++) {
                const nextIndex = periods.length + i;
                const trendPrediction = trendAnalysis.slope * nextIndex + trendAnalysis.intercept;
                
                let seasonalAdjustment = 0;
                if (hasSeasonality && seasonalityPeriod > 0) {
                    const seasonIndex = nextIndex % seasonalityPeriod;
                    seasonalAdjustment = seasonalComponents[seasonIndex] || 0;
                }
                
                forecast.push({
                    index: nextIndex,
                    value: trendPrediction + seasonalAdjustment
                });
            }
            
            return {
                trend: trendAnalysis.trend,
                equation: trendAnalysis.equation,
                rSquared: trendAnalysis.rSquared,
                seasonality: hasSeasonality ? `${seasonalityStrength} (periodo: ${seasonalityPeriod})` : 'no detectada',
                seasonalComponents,
                forecast,
                confidence: hasSeasonality && trendAnalysis.rSquared > 0.5 ? 'media-alta' : trendAnalysis.confidence
            };
        }
        
        // Función para análisis de clústeres usando K-means simple
        function performClusterAnalysis(data, fields, k = 3, maxIterations = 100) {
            try {
                if (!data || data.length < k || !fields || fields.length === 0) {
                    return {
                        success: false,
                        message: 'Datos insuficientes para análisis de clústeres'
                    };
                }
                
                // Extraer y normalizar valores para los campos seleccionados
                const extractedData = [];
                const fieldStats = {};
                
                // Calcular estadísticas para normalización
                fields.forEach(field => {
                    const values = data
                        .map(record => Number(record[field]))
                        .filter(val => !isNaN(val));
                    
                    if (values.length > 0) {
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const range = max - min > 0 ? max - min : 1; // Evitar división por cero
                        
                        fieldStats[field] = { min, max, range };
                    }
                });
                
                // Extraer y normalizar datos
                data.forEach(record => {
                    const point = {};
                    
                    let hasValidValue = false;
                    fields.forEach(field => {
                        const value = Number(record[field]);
                        
                        if (!isNaN(value) && fieldStats[field]) {
                            // Normalizar a escala [0,1]
                            const { min, range } = fieldStats[field];
                            point[field] = (value - min) / range;
                            hasValidValue = true;
                        } else {
                            point[field] = null;
                        }
                    });
                    
                    if (hasValidValue) {
                        extractedData.push({
                            original: record,
                            normalized: point
                        });
                    }
                });
                
                if (extractedData.length < k) {
                    return {
                        success: false,
                        message: 'Datos insuficientes después de filtrar valores no válidos'
                    };
                }
                
                // Inicializar centroides de forma aleatoria
                let centroids = [];
                const selectedIndices = new Set();
                
                while (centroids.length < k) {
                    const randomIndex = Math.floor(Math.random() * extractedData.length);
                    
                    if (!selectedIndices.has(randomIndex) && Object.values(extractedData[randomIndex].normalized).every(val => val !== null)) {
                        selectedIndices.add(randomIndex);
                        centroids.push({...extractedData[randomIndex].normalized});
                    }
                }
                
                // Función para calcular distancia euclidiana
                function calculateDistance(point1, point2) {
                    let sumSquaredDiff = 0;
                    let validDimensions = 0;
                    
                    fields.forEach(field => {
                        if (point1[field] !== null && point2[field] !== null) {
                            sumSquaredDiff += Math.pow(point1[field] - point2[field], 2);
                            validDimensions++;
                        }
                    });
                    
                    return validDimensions > 0 ? Math.sqrt(sumSquaredDiff / validDimensions) : Infinity;
                }
                
                // Realizar algoritmo K-means
                let clusters = Array(k).fill().map(() => []);
                let iteration = 0;
                let centroidsChanged = true;
                
                while (centroidsChanged && iteration < maxIterations) {
                    // Reiniciar clusters
                    clusters = Array(k).fill().map(() => []);
                    
                    // Asignar puntos a clusters
                    extractedData.forEach(dataPoint => {
                        let minDistance = Infinity;
                        let clusterIndex = 0;
                        
                        centroids.forEach((centroid, index) => {
                            const distance = calculateDistance(dataPoint.normalized, centroid);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                clusterIndex = index;
                            }
                        });
                        
                        clusters[clusterIndex].push(dataPoint);
                    });
                    
                    // Actualizar centroides
                    centroidsChanged = false;
                    
                    clusters.forEach((cluster, index) => {
                        if (cluster.length === 0) return;
                        
                        const newCentroid = {};
                        
                        fields.forEach(field => {
                            const validValues = cluster
                                .map(point => point.normalized[field])
                                .filter(val => val !== null);
                            
                            if (validValues.length > 0) {
                                newCentroid[field] = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
                            } else {
                                newCentroid[field] = centroids[index][field];
                            }
                        });
                        
                        // Verificar si el centroide cambió significativamente
                        const centroidDistance = calculateDistance(centroids[index], newCentroid);
                        if (centroidDistance > 0.001) {
                            centroidsChanged = true;
                        }
                        
                        centroids[index] = newCentroid;
                    });
                    
                    iteration++;
                }
                
                // Calcular métricas para cada cluster
                const clusterMetrics = clusters.map((cluster, index) => {
                    // Calcular estadísticas para cada campo en este cluster
                    const fieldMetrics = {};
                    
                    fields.forEach(field => {
                        const originalValues = cluster
                            .map(point => Number(point.original[field]))
                            .filter(val => !isNaN(val));
                        
                        if (originalValues.length > 0) {
                            const stats = calculateNumericStats(originalValues);
                            fieldMetrics[field] = stats;
                        }
                    });
                    
                    // Calcular la cohesión del cluster (suma de distancias al centroide)
                    let totalDistance = 0;
                    cluster.forEach(point => {
                        totalDistance += calculateDistance(point.normalized, centroids[index]);
                    });
                    
                    const avgDistance = cluster.length > 0 ? totalDistance / cluster.length : 0;
                    
                    return {
                        size: cluster.length,
                        percentage: (cluster.length / extractedData.length) * 100,
                        fieldMetrics,
                        cohesion: avgDistance,
                        centroid: {...centroids[index]}
                    };
                });
                
                // Identificar características distintivas de cada cluster
                const clusterProfiles = clusterMetrics.map((metrics, index) => {
                    const distinctiveFeatures = [];
                    
                    fields.forEach(field => {
                        if (metrics.fieldMetrics[field]) {
                            const clusterMean = metrics.fieldMetrics[field].mean;
                            
                            // Comparar con los otros clusters
                            const otherClusters = clusterMetrics.filter((_, i) => i !== index);
                            const otherMeans = otherClusters
                                .map(c => c.fieldMetrics[field] ? c.fieldMetrics[field].mean : null)
                                .filter(mean => mean !== null);
                            
                            if (otherMeans.length > 0) {
                                const overallMean = otherMeans.reduce((sum, val) => sum + val, 0) / otherMeans.length;
                                const difference = clusterMean - overallMean;
                                const percentDiff = (difference / overallMean) * 100;
                                
                                if (Math.abs(percentDiff) > 15) {
                                    distinctiveFeatures.push({
                                        field,
                                        direction: percentDiff > 0 ? 'mayor' : 'menor',
                                        percentDiff: Math.abs(percentDiff)
                                    });
                                }
                            }
                        }
                    });
                    
                    return {
                        clusterIndex: index,
                        distinctiveFeatures: distinctiveFeatures.sort((a, b) => b.percentDiff - a.percentDiff)
                    };
                });
                
                // Asignar clusters a los datos originales
                const dataWithClusters = data.map(record => {
                    // Buscar el punto correspondiente en extractedData
                    const found = extractedData.find(point => point.original === record);
                    
                    if (found) {
                        const clusterIndex = clusters.findIndex(cluster => cluster.includes(found));
                        return {
                            ...record,
                            cluster: clusterIndex !== -1 ? clusterIndex : null
                        };
                    }
                    
                    return {
                        ...record,
                        cluster: null
                    };
                });
                
                return {
                    success: true,
                    clusters: clusterMetrics,
                    clusterProfiles,
                    iterations: iteration,
                    dataWithClusters
                };
            } catch (error) {
                console.error('Error en performClusterAnalysis:', error);
                return {
                    success: false,
                    message: 'Error en análisis de clústeres: ' + error.message
                };
            }
        }
        
        // Función para generar un análisis predictivo consolidado
        function generatePredictiveAnalysis() {
            try {
                if (globalData.totalRecords === 0) {
                    return {
                        success: false,
                        message: 'No hay datos suficientes para realizar análisis predictivo.'
                    };
                }
                
                const analysis = {
                    trends: [],
                    correlations: [],
                    forecast: null,
                    clusters: null,
                    segments: [],
                    recommendations: []
                };
                
                // 1. Análisis de tendencias para campos numéricos con series temporales
                const dateFields = Object.keys(globalData.dates);
                const numericFields = Object.keys(globalData.numerics);
                
                if (dateFields.length > 0 && numericFields.length > 0) {
                    const dateField = dateFields[0];
                    
                    numericFields.slice(0, 3).forEach(numericField => {
                        // Preparar datos de serie temporal
                        const timeData = {};
                        
                        globalData.rawData.forEach(record => {
                            if (record[dateField] && record[numericField]) {
                                // Convertir a fecha
                                let dateValue;
                                try {
                                    dateValue = new Date(record[dateField]);
                                } catch (e) {
                                    return; // Ignorar si no es una fecha válida
                                }
                                
                                if (isNaN(dateValue.getTime())) return; // Ignorar si no es una fecha válida
                                
                                // Agrupar por mes
                                const year = dateValue.getFullYear();
                                const month = dateValue.getMonth() + 1;
                                const period = `${year}-${month.toString().padStart(2, '0')}`;
                                
                                if (!timeData[period]) {
                                    timeData[period] = {
                                        sum: 0,
                                        count: 0
                                    };
                                }
                                
                                const numValue = Number(record[numericField]);
                                if (!isNaN(numValue)) {
                                    timeData[period].sum += numValue;
                                    timeData[period].count++;
                                }
                            }
                        });
                        
                        // Calcular promedios por período
                        const timeAvg = {};
                        Object.keys(timeData).forEach(period => {
                            if (timeData[period].count > 0) {
                                timeAvg[period] = timeData[period].sum / timeData[period].count;
                            }
                        });
                        
                        // Ordenar períodos cronológicamente
                        const sortedPeriods = Object.keys(timeAvg).sort();
                        const values = sortedPeriods.map(period => timeAvg[period]);
                        
                        if (sortedPeriods.length >= 4) {
                            // Analizar tendencia y generar pronóstico
                            const timeSeriesAnalysis = analyzeTimeSeries(sortedPeriods, values);
                            
                            // Formatear fechas para las predicciones
                            const lastPeriod = sortedPeriods[sortedPeriods.length - 1];
                            const [lastYear, lastMonth] = lastPeriod.split('-').map(Number);
                            
                            const formattedForecasts = timeSeriesAnalysis.forecast.map((forecast, index) => {
                                let forecastMonth = lastMonth + index + 1;
                                let forecastYear = lastYear;
                                
                                while (forecastMonth > 12) {
                                    forecastMonth -= 12;
                                    forecastYear += 1;
                                }
                                
                                return {
                                    period: `${forecastYear}-${forecastMonth.toString().padStart(2, '0')}`,
                                    value: forecast.value
                                };
                            });
                            
                            analysis.trends.push({
                                field: numericField,
                                dateField,
                                trend: timeSeriesAnalysis.trend,
                                seasonality: timeSeriesAnalysis.seasonality,
                                equation: timeSeriesAnalysis.equation,
                                rSquared: timeSeriesAnalysis.rSquared,
                                forecast: formattedForecasts,
                                confidence: timeSeriesAnalysis.confidence
                            });
                        }
                    });
                    
                    // Establecer el pronóstico principal (primer campo numérico)
                    if (analysis.trends.length > 0) {
                        analysis.forecast = analysis.trends[0];
                    }
                }
                
                // 2. Análisis de correlaciones entre campos numéricos
                if (numericFields.length >= 2) {
                    // Analizar todas las combinaciones de pares de campos numéricos
                    for (let i = 0; i < numericFields.length - 1; i++) {
                        for (let j = i + 1; j < numericFields.length; j++) {
                            const field1 = numericFields[i];
                            const field2 = numericFields[j];
                            
                            const correlation = calculateCorrelation(globalData.rawData, field1, field2);
                            
                            if (Math.abs(correlation.correlation) >= 0.3) {
                                analysis.correlations.push({
                                    field1,
                                    field2,
                                    correlation: correlation.correlation,
                                    strength: correlation.strength,
                                    direction: correlation.direction
                                });
                            }
                        }
                    }
                    
                    // Ordenar por fuerza de correlación
                    analysis.correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
                }
                
                // 3. Análisis de clústeres si hay suficientes campos numéricos
                if (numericFields.length >= 2) {
                    // Seleccionar hasta 4 campos numéricos para el análisis
                    const clusterFields = numericFields.slice(0, 4);
                    
                    // Determinar el número óptimo de clústeres (entre 2 y 5)
                    const maxClusters = Math.min(5, Math.ceil(Math.sqrt(globalData.totalRecords / 10)));
                    const k = Math.max(2, Math.min(maxClusters, 3)); // Default a 3 si es posible
                    
                    const clusterAnalysis = performClusterAnalysis(globalData.rawData, clusterFields, k);
                    
                    if (clusterAnalysis.success) {
                        analysis.clusters = {
                            k,
                            fields: clusterFields,
                            clusters: clusterAnalysis.clusters,
                            profiles: clusterAnalysis.clusterProfiles
                        };
                        
                        // Generar segmentos basados en los perfiles de clústeres
                        clusterAnalysis.clusterProfiles.forEach((profile, index) => {
                            const cluster = clusterAnalysis.clusters[index];
                            
                            if (profile.distinctiveFeatures.length > 0) {
                                // Crear descripción del segmento
                                const topFeatures = profile.distinctiveFeatures.slice(0, 3);
                                
                                const featureDescriptions = topFeatures.map(feature => {
                                    const percentDiff = feature.percentDiff.toFixed(1);
                                    return `"${feature.field}" ${feature.direction} (${percentDiff}%)`;
                                });
                                
                                const segmentName = `Segmento ${index + 1}`;
                                const segmentDesc = `Caracterizado por ${featureDescriptions.join(', ')}`;
                                
                                analysis.segments.push({
                                    name: segmentName,
                                    size: cluster.size,
                                    percentage: cluster.percentage.toFixed(1),
                                    description: segmentDesc,
                                    features: topFeatures
                                });
                            }
                        });
                    }
                }
                
                // 4. Generar recomendaciones basadas en los hallazgos
                
                // Recomendaciones basadas en tendencias
                if (analysis.trends.length > 0) {
                    const mainTrend = analysis.trends[0];
                    
                    if (mainTrend.trend.includes('creciente')) {
                        analysis.recommendations.push({
                            type: 'tendencia',
                            title: `Aprovechar tendencia creciente en ${mainTrend.field}`,
                            description: `Los datos muestran una tendencia ${mainTrend.trend} para ${mainTrend.field}. Se recomienda capitalizar este crecimiento preparando capacidad adicional y optimizando recursos.`,
                            confidence: mainTrend.confidence
                        });
                    } else if (mainTrend.trend.includes('decreciente')) {
                        analysis.recommendations.push({
                            type: 'tendencia',
                            title: `Mitigar tendencia decreciente en ${mainTrend.field}`,
                            description: `Los datos muestran una tendencia ${mainTrend.trend} para ${mainTrend.field}. Se recomienda investigar las causas subyacentes e implementar estrategias para revertir esta tendencia.`,
                            confidence: mainTrend.confidence
                        });
                    }
                    
                    if (mainTrend.seasonality && !mainTrend.seasonality.includes('no detectada')) {
                        analysis.recommendations.push({
                            type: 'estacionalidad',
                            title: `Planificar para patrones estacionales`,
                            description: `Se ha detectado estacionalidad ${mainTrend.seasonality} en ${mainTrend.field}. Se recomienda ajustar la planificación de recursos y estrategias para adaptarse a estos ciclos predecibles.`,
                            confidence: 'media-alta'
                        });
                    }
                }
                
                // Recomendaciones basadas en correlaciones
                if (analysis.correlations.length > 0) {
                    const strongestCorrelation = analysis.correlations[0];
                    
                    analysis.recommendations.push({
                        type: 'correlación',
                        title: `Explorar relación entre ${strongestCorrelation.field1} y ${strongestCorrelation.field2}`,
                        description: `Existe una correlación ${strongestCorrelation.strength} ${strongestCorrelation.direction} entre estos campos. Se recomienda analizar cómo el cambio en uno podría influir en el otro para optimizar resultados.`,
                        confidence: strongestCorrelation.strength.includes('fuerte') ? 'alta' : 'media'
                    });
                }
                
                // Recomendaciones basadas en segmentos
                if (analysis.segments.length > 0) {
                    const largestSegment = analysis.segments.reduce(
                        (max, segment) => parseFloat(segment.percentage) > parseFloat(max.percentage) ? segment : max, 
                        analysis.segments[0]
                    );
                    
                    analysis.recommendations.push({
                        type: 'segmentación',
                        title: `Estrategia específica para ${largestSegment.name}`,
                        description: `Este segmento representa el ${largestSegment.percentage}% de los datos y está ${largestSegment.description}. Se recomienda desarrollar estrategias específicas que consideren estas características distintivas.`,
                        confidence: 'media-alta'
                    });
                }
                
                return {
                    success: true,
                    analysis
                };
            } catch (error) {
                console.error('Error en generatePredictiveAnalysis:', error);
                return {
                    success: false,
                    message: 'Error al generar análisis predictivo: ' + error.message
                };
            }
        }
        
        // Función para generar el dashboard completo
        function generateDashboard() {
            try {
                console.log('Generando dashboard...');
                
                // Limpiar el contenedor del dashboard
                const dashboardContainer = document.getElementById('dashboard-container');
                if (!dashboardContainer) {
                    console.error('Contenedor del dashboard no encontrado');
                    return;
                }
                dashboardContainer.innerHTML = '';
                
                // Limpiar los gráficos existentes
                console.log('Limpiando gráficos existentes...');
                for (const chartId in charts) {
                    try {
                        if (charts[chartId]) {
                            charts[chartId].destroy();
                            delete charts[chartId];
                        }
                    } catch (chartError) {
                        console.error(`Error al destruir el gráfico ${chartId}:`, chartError);
                    }
                }
                
                // Si no hay datos, mostrar mensaje
                if (globalData.totalRecords === 0) {
                    console.log('No hay datos para mostrar');
                    dashboardContainer.innerHTML = `
                        <div class="card full-width">
                            <h2>No hay datos para mostrar</h2>
                            <p>Cargue un archivo Excel o proporcione una URL de Google Sheets para comenzar el análisis.</p>
                        </div>
                    `;
                    return;
                }
                
                console.log(`Generando dashboard con ${globalData.totalRecords} registros`);
                
                // 1. Generar tarjeta de resumen
                try {
                    console.log('Generando tarjeta de resumen...');
                    generateSummaryCard(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar tarjeta de resumen:', error);
                }
                
                // 2. Generar gráficos de distribución para campos categóricos (máximo 4)
                const categoryFields = Object.keys(globalData.categories);
                console.log(`Se encontraron ${categoryFields.length} campos categóricos:`, categoryFields);
                
                for (let i = 0; i < Math.min(categoryFields.length, 4); i++) {
                    try {
                        console.log(`Generando gráfico para categoría ${i+1}/${Math.min(categoryFields.length, 4)}: ${categoryFields[i]}`);
                        generateCategoryChart(dashboardContainer, categoryFields[i]);
                    } catch (error) {
                        console.error(`Error al generar gráfico para categoría ${categoryFields[i]}:`, error);
                    }
                }
                
                // 3. Generar gráficos para campos numéricos (máximo 4)
                const numericFields = Object.keys(globalData.numerics);
                console.log(`Se encontraron ${numericFields.length} campos numéricos:`, numericFields);
                
                for (let i = 0; i < Math.min(numericFields.length, 4); i++) {
                    try {
                        console.log(`Generando gráfico para campo numérico ${i+1}/${Math.min(numericFields.length, 4)}: ${numericFields[i]}`);
                        generateNumericChart(dashboardContainer, numericFields[i]);
                    } catch (error) {
                        console.error(`Error al generar gráfico para campo numérico ${numericFields[i]}:`, error);
                    }
                }
                
                // 4. Generar gráficos combinados (categórico vs numérico)
                if (categoryFields.length > 0 && numericFields.length > 0) {
                    try {
                        console.log(`Generando gráfico combinado: ${categoryFields[0]} vs ${numericFields[0]}`);
                        generateCombinedChart(dashboardContainer, categoryFields[0], numericFields[0]);
                    } catch (error) {
                        console.error(`Error al generar gráfico combinado:`, error);
                    }
                }
                
                // 5. Generar gráficos de tendencia temporal si hay campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0 && numericFields.length > 0) {
                    try {
                        console.log(`Generando gráfico de serie temporal: ${dateFields[0]} - ${numericFields[0]}`);
                        generateTimeSeriesChart(dashboardContainer, dateFields[0], numericFields[0]);
                    } catch (error) {
                        console.error(`Error al generar gráfico de serie temporal:`, error);
                    }
                }
                
                // 6. Generar sección de análisis predictivo
                try {
                    console.log('Generando sección de análisis predictivo...');
                    generatePredictiveSection(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar sección de análisis predictivo:', error);
                }
                
                // 7. Generar tablas de datos principales
                try {
                    console.log('Generando tabla de datos...');
                    generateDataTable(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar tabla de datos:', error);
                }
                
                // 8. Generar análisis y recomendaciones
                try {
                    console.log('Generando análisis y recomendaciones...');
                    generateAnalysisAndRecommendations();
                } catch (error) {
                    console.error('Error al generar análisis y recomendaciones:', error);
                }
                
                // 9. Configurar filtros dinámicos
                try {
                    console.log('Configurando filtros dinámicos...');
                    setupDynamicFilters();
                } catch (error) {
                    console.error('Error al configurar filtros dinámicos:', error);
                }
                
                console.log('Generación del dashboard completada');
            } catch (error) {
                console.error('Error en generateDashboard:', error);
                showAlert('error-alert', 'Error al generar el dashboard: ' + error.message);
            }
        }
        
        // Función para generar la tarjeta de resumen
        function generateSummaryCard(container) {
            try {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.innerHTML = `
                    <h2>Resumen General</h2>
                    <div class="stats-container" id="summary-stats"></div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="summary-analysis">Analizando datos...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Agregar estadísticas
                const statsContainer = document.getElementById('summary-stats');
                
                // Total de registros
                const totalStat = document.createElement('div');
                totalStat.className = 'stat-box';
                totalStat.innerHTML = `
                    <h3>Total Registros</h3>
                    <p>${globalData.totalRecords}</p>
                `;
                statsContainer.appendChild(totalStat);
                
                // Campos analizados
                const fieldsStat = document.createElement('div');
                fieldsStat.className = 'stat-box';
                fieldsStat.innerHTML = `
                    <h3>Campos Analizados</h3>
                    <p>${Object.keys(globalData.fields).length}</p>
                `;
                statsContainer.appendChild(fieldsStat);
                
                // Categorías principales (si existen)
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const categoryCount = globalData.categories[mainCategory].uniqueValues.length;
                    
                    const categoryStat = document.createElement('div');
                    categoryStat.className = 'stat-box';
                    categoryStat.innerHTML = `
                        <h3>${mainCategory}</h3>
                        <p>${categoryCount}</p>
                    `;
                    statsContainer.appendChild(categoryStat);
                }
                
                // Campo numérico principal (si existe)
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    const numericStat = document.createElement('div');
                    numericStat.className = 'stat-box';
                    numericStat.innerHTML = `
                        <h3>Promedio ${mainNumeric}</h3>
                        <p>${stats.mean.toFixed(2)}</p>
                    `;
                    statsContainer.appendChild(numericStat);
                    
                    // Mostrar outliers si existen
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outliersStat = document.createElement('div');
                        outliersStat.className = 'stat-box risk-high';
                        outliersStat.innerHTML = `
                            <h3>Valores Atípicos</h3>
                            <p>${stats.outliers.length}</p>
                        `;
                        statsContainer.appendChild(outliersStat);
                    }
                }
                
                // Generar el análisis de resumen
                generateSummaryAnalysis();
            } catch (error) {
                console.error('Error en generateSummaryCard:', error);
                throw error;
            }
        }
        
        // Función para generar el análisis de resumen
        function generateSummaryAnalysis() {
            try {
                let analysis = `El conjunto de datos contiene ${globalData.totalRecords} registros con ${Object.keys(globalData.fields).length} campos analizados. `;
                
                // Análisis de campos categóricos
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    analysis += `Se identificaron ${categoryFields.length} campos categóricos. `;
                    
                    // Analizar la distribución del primer campo categórico
                    const mainCategory = categoryFields[0];
                    const categoryValues = globalData.categories[mainCategory].uniqueValues.length;
                    
                    analysis += `El campo "${mainCategory}" contiene ${categoryValues} valores únicos. `;
                    
                    // Identificar valores más frecuentes
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    if (sortedValues.length > 0) {
                        analysis += `Los valores más frecuentes son: `;
                        sortedValues.forEach((entry, index) => {
                            const percentage = ((entry[1] / globalData.totalRecords) * 100).toFixed(1);
                            analysis += `"${entry[0]}" (${percentage}%)`;
                            
                            if (index < sortedValues.length - 1) {
                                analysis += ', ';
                            } else {
                                analysis += '. ';
                            }
                        });
                    }
                }
                
                // Análisis de campos numéricos
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    analysis += `Se identificaron ${numericFields.length} campos numéricos. `;
                    
                    // Analizar estadísticas del primer campo numérico
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    analysis += `Para el campo "${mainNumeric}", el valor promedio es ${stats.mean.toFixed(2)}, `;
                    analysis += `con un valor mínimo de ${stats.min.toFixed(2)} y máximo de ${stats.max.toFixed(2)}. `;
                    
                    // Análisis de dispersión
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        analysis += `Los datos muestran una alta variabilidad (CV = ${cv.toFixed(1)}%), lo que indica valores dispersos. `;
                    } else if (cv > 20) {
                        analysis += `Los datos muestran una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        analysis += `Los datos muestran una baja variabilidad (CV = ${cv.toFixed(1)}%), lo que indica valores más homogéneos. `;
                    }
                    
                    // Análisis de asimetría
                    if (stats.skewness) {
                        if (Math.abs(stats.skewness) > 1) {
                            const skewType = stats.skewness > 0 ? "positiva" : "negativa";
                            analysis += `La distribución presenta una asimetría ${skewType} significativa (${stats.skewness.toFixed(2)}), `;
                            analysis += `lo que indica una concentración de valores ${stats.skewness > 0 ? "bajos con algunos valores extremos altos" : "altos con algunos valores extremos bajos"}. `;
                        }
                    }
                    
                    // Análisis de valores atípicos
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outlierPercentage = (stats.outliers.length / stats.count * 100).toFixed(1);
                        analysis += `Se detectaron ${stats.outliers.length} valores atípicos (${outlierPercentage}% del total), `;
                        analysis += `que podrían afectar significativamente los análisis estadísticos. `;
                    }
                }
                
                // Análisis de campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0) {
                    analysis += `Se identificaron ${dateFields.length} campos de fecha, lo que permite realizar análisis temporales y predicciones. `;
                }
                
                document.getElementById('summary-analysis').textContent = analysis;
            } catch (error) {
                console.error('Error en generateSummaryAnalysis:', error);
                document.getElementById('summary-analysis').textContent = 'Error al generar el análisis de resumen.';
            }
        }
        
        // Función para generar gráfico de distribución de categoría
        function generateCategoryChart(container, fieldName) {
            try {
                console.log(`Generando gráfico de categoría para el campo: ${fieldName}`);
                
                if (!globalData.categories[fieldName]) {
                    console.warn(`Campo ${fieldName} no encontrado en los datos de categorías`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                const chartId = `chart-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Distribución de ${fieldName}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="${analysisId}">Analizando distribución...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Obtener datos para el gráfico
                const distribution = globalData.categories[fieldName].distribution;
                console.log(`Datos de distribución para ${fieldName}:`, distribution);
                
                if (!distribution || Object.keys(distribution).length === 0) {
                    console.warn(`No hay datos de distribución disponibles para ${fieldName}`);
                    document.getElementById(analysisId).textContent = `No hay datos de distribución disponibles para ${fieldName}`;
                    return;
                }
                
                // Ordenar y limitar a los 10 valores más frecuentes si hay muchos
                const sortedData = Object.entries(distribution)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                
                const labels = sortedData.map(item => item[0]);
                const values = sortedData.map(item => item[1]);
                
                console.log(`Datos del gráfico para ${fieldName}:`, { labels, values });
                
                // Crear gráfico con manejo de errores
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    // Crear gráfico con configuración simplificada
                    charts[chartId] = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: values,
                                backgroundColor: generateColors(labels.length)
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: {
                                        font: {
                                            size: 12
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || '';
                                            const value = context.raw || 0;
                                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                            const percentage = Math.round((value / total) * 100);
                                            return `${label}: ${value} (${percentage}%)`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gráfico creado exitosamente para ${fieldName}`);
                    
                    // Generar análisis
                    generateCategoryAnalysis(fieldName, distribution, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gráfico para ${fieldName}:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gráfico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateCategoryChart para ${fieldName}:`, error);
            }
        }
        
        // Función para generar análisis de distribución de categoría
        function generateCategoryAnalysis(fieldName, distribution, analysisId) {
            try {
                const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
                const sortedData = Object.entries(distribution)
                    .sort((a, b) => b[1] - a[1]);
                
                let analysis = '';
                
                // Analizar valores más frecuentes
                if (sortedData.length > 0) {
                    const topValue = sortedData[0];
                    const topPercentage = ((topValue[1] / total) * 100).toFixed(1);
                    
                    analysis += `En el campo "${fieldName}", el valor más frecuente es "${topValue[0]}" con ${topValue[1]} registros (${topPercentage}%). `;
                    
                    // Analizar concentración
                    if (sortedData.length >= 3) {
                        const top3 = sortedData.slice(0, 3);
                        const top3Count = top3.reduce((sum, item) => sum + item[1], 0);
                        const top3Percentage = ((top3Count / total) * 100).toFixed(1);
                        
                        analysis += `Los 3 valores principales representan el ${top3Percentage}% de los datos, `;
                        
                        if (top3Percentage > 80) {
                            analysis += `lo que indica una alta concentración en pocos valores. `;
                        } else if (top3Percentage > 50) {
                            analysis += `mostrando una concentración moderada. `;
                        } else {
                            analysis += `indicando una distribución más equilibrada entre los diferentes valores. `;
                        }
                    }
                    
                    // Analizar "cola larga"
                    const uniqueCount = sortedData.length;
                    if (uniqueCount > 10) {
                        const tailCount = sortedData.slice(10).reduce((sum, item) => sum + item[1], 0);
                        const tailPercentage = ((tailCount / total) * 100).toFixed(1);
                        
                        analysis += `Hay ${uniqueCount - 10} valores adicionales que representan el ${tailPercentage}% de los datos, `;
                        
                        if (tailPercentage > 30) {
                            analysis += `lo que sugiere una "cola larga" significativa en la distribución. `;
                        } else {
                            analysis += `formando una "cola larga" de menor relevancia. `;
                        }
                    }
                    
                    // Análisis de equidad de la distribución (índice de Gini simplificado)
                    if (sortedData.length > 1) {
                        const values = sortedData.map(item => item[1]);
                        const totalSum = values.reduce((sum, val) => sum + val, 0);
                        const proportions = values.map(val => val / totalSum);
                        
                        // Calcular una versión simplificada del índice de Gini
                        let giniSum = 0;
                        for (let i = 0; i < proportions.length; i++) {
                            for (let j = 0; j < proportions.length; j++) {
                                giniSum += Math.abs(proportions[i] - proportions[j]);
                            }
                        }
                        
                        const gini = giniSum / (2 * proportions.length * proportions.length);
                        
                        if (gini > 0.6) {
                            analysis += `La distribución muestra una desigualdad alta (Gini ≈ ${gini.toFixed(2)}), con una fuerte dominancia de pocos valores. `;
                        } else if (gini > 0.4) {
                            analysis += `La distribución muestra una desigualdad moderada (Gini ≈ ${gini.toFixed(2)}). `;
                        } else {
                            analysis += `La distribución es relativamente equitativa entre los diferentes valores (Gini ≈ ${gini.toFixed(2)}). `;
                        }
                    }
                } else {
                    analysis = `No hay suficientes datos para analizar la distribución de "${fieldName}".`;
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateCategoryAnalysis para ${fieldName}:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar la distribución: ${error.message}`;
            }
        }
        
        // Función para generar gráfico de campo numérico
        function generateNumericChart(container, fieldName) {
            try {
                console.log(`Generando gráfico numérico para el campo: ${fieldName}`);
                
                if (!globalData.numerics[fieldName]) {
                    console.warn(`Campo ${fieldName} no encontrado en los datos numéricos`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                const chartId = `chart-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Distribución de ${fieldName}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="${analysisId}">Analizando distribución numérica...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Generar datos para histograma
                const values = [];
                globalData.rawData.forEach(record => {
                    if (record[fieldName] !== undefined && record[fieldName] !== null && record[fieldName] !== '') {
                        const numValue = Number(record[fieldName]);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    }
                });
                
                console.log(`Valores numéricos para ${fieldName}: ${values.length} valores válidos`);
                
                if (values.length === 0) {
                    console.warn(`No hay valores numéricos válidos para ${fieldName}`);
                    document.getElementById(analysisId).textContent = `No hay valores numéricos válidos para ${fieldName}`;
                    return;
                }
                
                // Calcular intervalos para histograma
                const stats = globalData.numerics[fieldName].stats;
                const min = stats.min;
                const max = stats.max;
                const range = max - min;
                const binCount = Math.min(10, Math.ceil(Math.sqrt(values.length)));
                const binWidth = range / binCount;
                
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                // Crear etiquetas de bins
                for (let i = 0; i < binCount; i++) {
                    const binStart = min + (i * binWidth);
                    const binEnd = binStart + binWidth;
                    binLabels.push(`${binStart.toFixed(1)} - ${binEnd.toFixed(1)}`);
                }
                
                // Clasificar valores en bins
                values.forEach(value => {
                    if (value >= min && value <= max) {
                        const binIndex = Math.min(binCount - 1, Math.floor((value - min) / binWidth));
                        bins[binIndex]++;
                    }
                });
                
                console.log(`Datos del histograma para ${fieldName}:`, { binLabels, bins });
                
                // Crear dataset para la curva de distribución normal
                const normalCurveData = [];
                if (stats.std > 0) { // Evitar división por cero
                    for (let i = 0; i < binCount; i++) {
                        const x = min + (i + 0.5) * binWidth;
                        const z = (x - stats.mean) / stats.std;
                        const y = (1 / (stats.std * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
                        // Escalar para que se ajuste al histograma
                        const maxBin = Math.max(...bins);
                        const scaleFactor = maxBin / (1 / (stats.std * Math.sqrt(2 * Math.PI)));
                        normalCurveData.push(y * scaleFactor);
                    }
                }
                
                // Crear gráfico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: binLabels,
                            datasets: [{
                                label: 'Frecuencia',
                                data: bins,
                                backgroundColor: reportStyles.primaryColor,
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 1
                            }, {
                                label: 'Distribución normal',
                                data: normalCurveData,
                                type: 'line',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Frecuencia'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: fieldName
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gráfico creado exitosamente para ${fieldName}`);
                    
                    // Generar análisis
                    generateNumericAnalysis(fieldName, stats, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gráfico para ${fieldName}:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gráfico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateNumericChart para ${fieldName}:`, error);
            }
        }
        
        // Función mejorada para generar análisis de campo numérico
        function generateNumericAnalysis(fieldName, stats, analysisId) {
            try {
                let analysis = `El campo "${fieldName}" tiene un valor promedio de ${stats.mean.toFixed(2)}, `;
                analysis += `con un rango desde ${stats.min.toFixed(2)} hasta ${stats.max.toFixed(2)}. `;
                
                // Análisis de la dispersión
                const cv = (stats.std / stats.mean) * 100;
                
                if (stats.std > 0) {
                    analysis += `La desviación estándar es ${stats.std.toFixed(2)}, `;
                    
                    if (cv > 50) {
                        analysis += `lo que indica una alta variabilidad en los datos (CV = ${cv.toFixed(1)}%). `;
                    } else if (cv > 20) {
                        analysis += `mostrando una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        analysis += `lo que sugiere datos relativamente homogéneos (CV = ${cv.toFixed(1)}%). `;
                    }
                }
                
                // Análisis de cuartiles y distribución
                analysis += `El primer cuartil (Q1) es ${stats.q1.toFixed(2)} y el tercer cuartil (Q3) es ${stats.q3.toFixed(2)}, `;
                analysis += `con un rango intercuartílico (IQR) de ${stats.iqr.toFixed(2)}. `;
                
                // Análisis de asimetría y curtosis
                if (stats.skewness !== undefined && stats.kurtosis !== undefined) {
                    if (Math.abs(stats.skewness) > 0.5) {
                        analysis += `La distribución muestra una asimetría ${stats.skewness > 0 ? 'positiva' : 'negativa'} (${stats.skewness.toFixed(2)}), `;
                        analysis += `lo que indica una mayor concentración de valores ${stats.skewness > 0 ? 'por debajo de la media con algunos valores altos extremos' : 'por encima de la media con algunos valores bajos extremos'}. `;
                    } else {
                        analysis += `La distribución es aproximadamente simétrica (asimetría = ${stats.skewness.toFixed(2)}). `;
                    }
                    
                    if (Math.abs(stats.kurtosis) > 1) {
                        if (stats.kurtosis > 0) {
                            analysis += `La distribución es leptocúrtica (curtosis = ${stats.kurtosis.toFixed(2)}), `;
                            analysis += `con picos más pronunciados que una distribución normal y colas más pesadas. `;
                        } else {
                            analysis += `La distribución es platicúrtica (curtosis = ${stats.kurtosis.toFixed(2)}), `;
                            analysis += `con picos más planos que una distribución normal y colas más ligeras. `;
                        }
                    } else {
                        analysis += `La curtosis (${stats.kurtosis.toFixed(2)}) es cercana a la de una distribución normal. `;
                    }
                }
                
                // Análisis de valores atípicos
                if (stats.outliers && stats.outliers.length > 0) {
                    const outlierPercentage = (stats.outliers.length / stats.count * 100).toFixed(1);
                    analysis += `Se detectaron ${stats.outliers.length} valores atípicos (${outlierPercentage}% de los datos), `;
                    
                    if (outlierPercentage > 5) {
                        analysis += `lo que podría indicar problemas en la calidad de los datos o la presencia de casos especiales que merecen un análisis detallado. `;
                    } else {
                        analysis += `que podrían representar casos especiales pero no afectan significativamente el análisis general. `;
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateNumericAnalysis para ${fieldName}:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar los datos numéricos: ${error.message}`;
            }
        }
        
        // Función para generar gráfico combinado (categórico vs numérico)
        function generateCombinedChart(container, categoryField, numericField) {
            try {
                console.log(`Generando gráfico combinado: ${categoryField} vs ${numericField}`);
                
                if (!globalData.categories[categoryField] || !globalData.numerics[numericField]) {
                    console.warn(`Campos no válidos para gráfico combinado: ${categoryField}, ${numericField}`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const chartId = `chart-combined-${categoryField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-combined-${categoryField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>${numericField} por ${categoryField}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="${analysisId}">Analizando relación...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Calcular promedio de campo numérico por categoría
                const categoryAverages = {};
                const categoryCounts = {};
                const categoryStdDevs = {};
                
                globalData.rawData.forEach(record => {
                    const category = record[categoryField];
                    const numValue = Number(record[numericField]);
                    
                    if (category && !isNaN(numValue)) {
                        if (!categoryAverages[category]) {
                            categoryAverages[category] = 0;
                            categoryCounts[category] = 0;
                            categoryStdDevs[category] = [];
                        }
                        
                        categoryAverages[category] += numValue;
                        categoryCounts[category]++;
                        categoryStdDevs[category].push(numValue);
                    }
                });
                
                console.log(`Datos de promedios por categoría calculados`);
                
                // Calcular promedios finales y desviaciones estándar
                Object.keys(categoryAverages).forEach(category => {
                    if (categoryCounts[category] > 0) {
                        categoryAverages[category] = categoryAverages[category] / categoryCounts[category];
                        
                        // Calcular desviación estándar
                        const mean = categoryAverages[category];
                        const squaredDiffs = categoryStdDevs[category].map(val => Math.pow(val - mean, 2));
                        const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / squaredDiffs.length;
                        categoryStdDevs[category] = Math.sqrt(avgSquaredDiff);
                    }
                });
                
                // Obtener las 10 categorías principales por cantidad
                const topCategories = Object.entries(categoryCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(item => item[0]);
                
                if (topCategories.length === 0) {
                    console.warn(`No hay datos válidos para el gráfico combinado`);
                    document.getElementById(analysisId).textContent = `No hay datos válidos para generar este gráfico.`;
                    return;
                }
                
                // Datos para el gráfico
                const labels = topCategories;
                const data = topCategories.map(category => categoryAverages[category]);
                const counts = topCategories.map(category => categoryCounts[category]);
                const stdDevs = topCategories.map(category => categoryStdDevs[category]);
                
                console.log(`Datos para gráfico combinado preparados: ${labels.length} categorías`);
                
                // Crear gráfico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Promedio de ${numericField}`,
                                data: data,
                                backgroundColor: reportStyles.primaryColor,
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 1,
                                order: 1
                            }, {
                                label: 'Cantidad de registros',
                                data: counts,
                                type: 'line',
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointBackgroundColor: reportStyles.accentColor,
                                yAxisID: 'y1',
                                order: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `Promedio de ${numericField}`
                                    }
                                },
                                y1: {
                                    position: 'right',
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: 'Cantidad de registros'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: categoryField
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            const categoryIndex = context.dataIndex;
                                            const category = topCategories[categoryIndex];
                                            return `Desv. Est.: ${categoryStdDevs[category].toFixed(2)}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gráfico combinado creado exitosamente`);
                    
                    // Generar análisis
                    generateCombinedAnalysis(categoryField, numericField, categoryAverages, categoryCounts, categoryStdDevs, topCategories, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gráfico combinado:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gráfico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateCombinedChart:`, error);
            }
        }
        
        // Función mejorada para generar análisis de gráfico combinado
        function generateCombinedAnalysis(categoryField, numericField, averages, counts, stdDevs, categories, analysisId) {
            try {
                let analysis = `Este gráfico muestra la relación entre "${categoryField}" y el promedio de "${numericField}". `;
                
                if (categories.length > 0) {
                    // Encontrar categoría con valor máximo y mínimo
                    const maxCategory = categories.reduce((max, category) => 
                        averages[category] > averages[max] ? category : max, categories[0]);
                    
                    const minCategory = categories.reduce((min, category) => 
                        averages[category] < averages[min] ? category : min, categories[0]);
                    
                    // Analizar valores máximos y mínimos
                    analysis += `"${maxCategory}" presenta el valor promedio más alto (${averages[maxCategory].toFixed(2)}), `;
                    analysis += `mientras que "${minCategory}" muestra el valor más bajo (${averages[minCategory].toFixed(2)}). `;
                    
                    // Calcular variación relativa
                    const relativeVariation = (averages[maxCategory] - averages[minCategory]) / averages[minCategory] * 100;
                    
                    if (relativeVariation > 100) {
                        analysis += `Existe una variación muy significativa del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else if (relativeVariation > 50) {
                        analysis += `Existe una variación significativa del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else if (relativeVariation > 20) {
                        analysis += `Existe una variación moderada del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else {
                        analysis += `La variación entre grupos es relativamente pequeña (${relativeVariation.toFixed(1)}%). `;
                    }
                    
                    // Análisis de correlación entre tamaño del grupo y valor promedio
                    const avgValues = categories.map(c => averages[c]);
                    const groupSizes = categories.map(c => counts[c]);
                    
                    // Calcular correlación simple
                    let correlation = 0;
                    if (avgValues.length > 1) {
                        const avgMean = avgValues.reduce((sum, val) => sum + val, 0) / avgValues.length;
                        const sizeMean = groupSizes.reduce((sum, val) => sum + val, 0) / groupSizes.length;
                        
                        let numerator = 0;
                        let denom1 = 0;
                        let denom2 = 0;
                        
                        for (let i = 0; i < avgValues.length; i++) {
                            numerator += (avgValues[i] - avgMean) * (groupSizes[i] - sizeMean);
                            denom1 += Math.pow(avgValues[i] - avgMean, 2);
                            denom2 += Math.pow(groupSizes[i] - sizeMean, 2);
                        }
                        
                        if (denom1 > 0 && denom2 > 0) {
                            correlation = numerator / Math.sqrt(denom1 * denom2);
                        }
                    }
                    
                    // Analizar la correlación
                    if (Math.abs(correlation) > 0.7) {
                        if (correlation > 0) {
                            analysis += `Se observa una fuerte relación positiva entre el tamaño del grupo y el valor promedio (r = ${correlation.toFixed(2)}), `;
                            analysis += `lo que sugiere que los grupos más grandes tienden a tener valores más altos. `;
                        } else {
                            analysis += `Se observa una fuerte relación negativa entre el tamaño del grupo y el valor promedio (r = ${correlation.toFixed(2)}), `;
                            analysis += `lo que sugiere que los grupos más pequeños tienden a tener valores más altos. `;
                        }
                    } else if (Math.abs(correlation) > 0.3) {
                        if (correlation > 0) {
                            analysis += `Se observa una relación moderada positiva entre el tamaño del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                        } else {
                            analysis += `Se observa una relación moderada negativa entre el tamaño del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                        }
                    } else {
                        analysis += `No se observa una relación clara entre el tamaño del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                    }
                    
                    // Análisis de variabilidad intragrupo
                    const variabilities = categories.map(c => stdDevs[c] / averages[c] * 100);  // CV por categoría
                    const avgVariability = variabilities.reduce((sum, val) => sum + val, 0) / variabilities.length;
                    
                    // Categoría con mayor y menor variabilidad
                    const maxVarCatIndex = variabilities.indexOf(Math.max(...variabilities));
                    const minVarCatIndex = variabilities.indexOf(Math.min(...variabilities));
                    
                    analysis += `La variabilidad dentro de los grupos (medida por el coeficiente de variación) es en promedio del ${avgVariability.toFixed(1)}%. `;
                    analysis += `"${categories[maxVarCatIndex]}" muestra la mayor heterogeneidad (CV = ${variabilities[maxVarCatIndex].toFixed(1)}%), `;
                    analysis += `mientras que "${categories[minVarCatIndex]}" es el grupo más homogéneo (CV = ${variabilities[minVarCatIndex].toFixed(1)}%). `;
                    
                    // Test ANOVA simplificado para diferencias entre grupos
                    if (categories.length >= 3) {
                        // Calcular varianza entre grupos
                        const overallMean = avgValues.reduce((sum, val, i) => sum + val * counts[categories[i]], 0) / 
                                          groupSizes.reduce((sum, val) => sum + val, 0);
                        
                        const betweenGroupSS = avgValues.reduce((sum, val, i) => 
                            sum + counts[categories[i]] * Math.pow(val - overallMean, 2), 0);
                        
                        const withinGroupSS = categories.reduce((sum, cat, i) => 
                            sum + counts[cat] * Math.pow(stdDevs[cat], 2), 0);
                        
                        const betweenGroupDF = categories.length - 1;
                        const withinGroupDF = groupSizes.reduce((sum, val) => sum + val, 0) - categories.length;
                        
                        if (withinGroupDF > 0) { // Evitar división por cero
                            const betweenGroupMS = betweenGroupSS / betweenGroupDF;
                            const withinGroupMS = withinGroupSS / withinGroupDF;
                            
                            const fStat = betweenGroupMS / withinGroupMS;
                            
                            if (fStat > 3) {
                                analysis += `El análisis estadístico indica diferencias significativas entre los grupos (F = ${fStat.toFixed(2)}), `;
                                analysis += `lo que sugiere que la variable "${categoryField}" tiene un efecto importante sobre "${numericField}". `;
                            } else if (fStat > 1.5) {
                                analysis += `Hay indicios de diferencias entre los grupos (F = ${fStat.toFixed(2)}), pero no son altamente significativas. `;
                            } else {
                                analysis += `Estadísticamente, las diferencias entre grupos no parecen ser significativas (F = ${fStat.toFixed(2)}). `;
                            }
                        }
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateCombinedAnalysis:`, error);
                document.getElementById(analysisId).textContent = `Error al generar el análisis: ${error.message}`;
            }
        }
        
        // Función para generar gráfico de serie temporal
        function generateTimeSeriesChart(container, dateField, numericField) {
            try {
                console.log(`Generando gráfico de serie temporal: ${dateField} - ${numericField}`);
                
                if (!globalData.dates[dateField] || !globalData.numerics[numericField]) {
                    console.warn(`Campos no válidos para gráfico de serie temporal: ${dateField}, ${numericField}`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const chartId = `chart-time-${dateField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-time-${dateField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Evolución de ${numericField} a lo largo del tiempo</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="${analysisId}">Analizando tendencia temporal...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Preparar datos agrupados por período
                const timeData = {};
                
                globalData.rawData.forEach(record => {
                    if (record[dateField] && record[numericField]) {
                        // Convertir a fecha
                        let dateValue;
                        try {
                            dateValue = new Date(record[dateField]);
                        } catch (e) {
                            return; // Ignorar si no es una fecha válida
                        }
                        
                        if (isNaN(dateValue.getTime())) return; // Ignorar si no es una fecha válida
                        
                        // Agrupar por mes
                        const year = dateValue.getFullYear();
                        const month = dateValue.getMonth() + 1;
                        const period = `${year}-${month.toString().padStart(2, '0')}`;
                        
                        if (!timeData[period]) {
                            timeData[period] = {
                                sum: 0,
                                count: 0,
                                values: []
                            };
                        }
                        
                        const numValue = Number(record[numericField]);
                        if (!isNaN(numValue)) {
                            timeData[period].sum += numValue;
                            timeData[period].count++;
                            timeData[period].values.push(numValue);
                        }
                    }
                });
                
                console.log(`Datos de serie temporal agrupados por períodos`);
                
                // Calcular promedios por período
                const timeAvg = {};
                const timeStdDev = {};
                
                Object.keys(timeData).forEach(period => {
                    if (timeData[period].count > 0) {
                        timeAvg[period] = timeData[period].sum / timeData[period].count;
                        
                        // Calcular desviación estándar
                        const values = timeData[period].values;
                        const mean = timeAvg[period];
                        const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                        const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
                        timeStdDev[period] = Math.sqrt(variance);
                    }
                });
                
                // Ordenar períodos cronológicamente
                const sortedPeriods = Object.keys(timeAvg).sort();
                
                if (sortedPeriods.length < 2) {
                    console.warn(`Datos temporales insuficientes para generar gráfico de serie temporal`);
                    document.getElementById(analysisId).textContent = `No hay suficientes datos temporales para generar un análisis de tendencia.`;
                    return;
                }
                
                // Formatear etiquetas y datos
                const labels = sortedPeriods.map(period => {
                    const [year, month] = period.split('-');
                    return `${month}/${year}`;
                });
                
                const data = sortedPeriods.map(period => timeAvg[period]);
                const counts = sortedPeriods.map(period => timeData[period].count);
                const stdDevs = sortedPeriods.map(period => timeStdDev[period]);
                
                console.log(`Datos de serie temporal preparados: ${sortedPeriods.length} períodos`);
                
                // Analizar tendencia para generar línea de tendencia
                const indices = Array.from({length: sortedPeriods.length}, (_, i) => i);
                const trendAnalysis = analyzeTrendAndPredict(indices, data);
                const trendLineData = trendAnalysis.trendValues;
                
                // Crear gráfico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Promedio de ${numericField}`,
                                data: data,
                                backgroundColor: 'rgba(52, 152, 219, 0.2)',
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 2,
                                tension: 0.3,
                                fill: true
                            }, {
                                label: 'Cantidad de registros',
                                data: counts,
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointBackgroundColor: reportStyles.accentColor,
                                tension: 0.3,
                                yAxisID: 'y1'
                            }, {
                                label: 'Línea de tendencia',
                                data: trendLineData,
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.secondaryColor,
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                tension: 0,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `Promedio de ${numericField}`
                                    }
                                },
                                y1: {
                                    position: 'right',
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: 'Cantidad de registros'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Período'
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            if (context.datasetIndex === 0) {
                                                const period = sortedPeriods[context.dataIndex];
                                                return `Desv. Est.: ${timeStdDev[period].toFixed(2)}`;
                                            }
                                            return '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gráfico de serie temporal creado exitosamente`);
                    
                    // Generar análisis
                    generateTimeSeriesAnalysis(numericField, sortedPeriods, timeAvg, timeData, trendAnalysis, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gráfico de serie temporal:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gráfico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateTimeSeriesChart:`, error);
            }
        }
        
        // Función mejorada para generar análisis de serie temporal
        function generateTimeSeriesAnalysis(numericField, periods, averages, periodData, trendAnalysis, analysisId) {
            try {
                let analysis = `Este gráfico muestra la evolución temporal de "${numericField}" a lo largo de ${periods.length} períodos. `;
                
                if (periods.length > 1) {
                    // Calcular variación total
                    const firstValue = averages[periods[0]];
                    const lastValue = averages[periods[periods.length - 1]];
                    const totalChange = lastValue - firstValue;
                    const totalChangePerc = (totalChange / firstValue) * 100;
                    
                    // Analizar tendencia general
                    if (Math.abs(totalChangePerc) < 5) {
                        analysis += `Durante el período analizado, el valor se ha mantenido relativamente estable `;
                        analysis += `(variación total de ${totalChangePerc.toFixed(1)}%). `;
                    } else {
                        if (totalChange > 0) {
                            analysis += `Durante el período analizado, el valor ha aumentado un ${totalChangePerc.toFixed(1)}% `;
                            analysis += `(de ${firstValue.toFixed(2)} a ${lastValue.toFixed(2)}). `;
                        } else {
                            analysis += `Durante el período analizado, el valor ha disminuido un ${Math.abs(totalChangePerc).toFixed(1)}% `;
                            analysis += `(de ${firstValue.toFixed(2)} a ${lastValue.toFixed(2)}). `;
                        }
                    }
                    
                    // Análisis de la tendencia utilizando regresión lineal
                    if (trendAnalysis && trendAnalysis.trend) {
                        analysis += `La línea de tendencia muestra una dirección ${trendAnalysis.trend} `;
                        analysis += `con una ecuación ${trendAnalysis.equation}. `;
                        
                        if (trendAnalysis.rSquared > 0.7) {
                            analysis += `El coeficiente de determinación R² = ${trendAnalysis.rSquared.toFixed(2)} indica que la tendencia explica bien la variación temporal. `;
                        } else if (trendAnalysis.rSquared > 0.4) {
                            analysis += `El coeficiente de determinación R² = ${trendAnalysis.rSquared.toFixed(2)} sugiere una tendencia moderada. `;
                        } else {
                            analysis += `El bajo coeficiente de determinación R² = ${trendAnalysis.rSquared.toFixed(2)} indica que la tendencia lineal no explica bien la variación temporal, `;
                            analysis += `lo que sugiere patrones más complejos o alta variabilidad. `;
                        }
                    }
                    
                    // Analizar la tendencia reciente (últimos 3 períodos o menos)
                    if (periods.length >= 3) {
                        const recentPeriods = periods.slice(-3);
                        const recentValues = recentPeriods.map(p => averages[p]);
                        
                        let recentTrend = 'estable';
                        if (recentValues[2] > recentValues[0] * 1.05) {
                            recentTrend = 'creciente';
                        } else if (recentValues[2] < recentValues[0] * 0.95) {
                            recentTrend = 'decreciente';
                        }
                        
                        analysis += `En los últimos 3 períodos, la tendencia ha sido ${recentTrend}. `;
                    }
                    
                    // Identificar picos y valles
                    let maxPeriod = periods[0];
                    let minPeriod = periods[0];
                    
                    periods.forEach(period => {
                        if (averages[period] > averages[maxPeriod]) {
                            maxPeriod = period;
                        }
                        if (averages[period] < averages[minPeriod]) {
                            minPeriod = period;
                        }
                    });
                    
                    const [maxYear, maxMonth] = maxPeriod.split('-');
                    const [minYear, minMonth] = minPeriod.split('-');
                    
                    analysis += `El valor máximo (${averages[maxPeriod].toFixed(2)}) se registró en ${maxMonth}/${maxYear}, `;
                    analysis += `mientras que el valor mínimo (${averages[minPeriod].toFixed(2)}) se registró en ${minMonth}/${minYear}. `;
                    
                    // Analizar estacionalidad (mejorado)
                    const monthlyAverages = {};
                    const monthlyCounts = {};
                    
                    periods.forEach(period => {
                        const month = parseInt(period.split('-')[1]);
                        if (!monthlyAverages[month]) {
                            monthlyAverages[month] = {
                                sum: 0,
                                count: 0
                            };
                        }
                        
                        monthlyAverages[month].sum += averages[period];
                        monthlyAverages[month].count++;
                        
                        if (!monthlyCounts[month]) {
                            monthlyCounts[month] = [];
                        }
                        monthlyCounts[month].push(averages[period]);
                    });
                    
                    // Calcular promedios mensuales y variación
                    const monthlyAvgs = {};
                    const monthlyVariations = {};
                    
                    Object.keys(monthlyAverages).forEach(month => {
                        if (monthlyAverages[month].count > 0) {
                            monthlyAvgs[month] = monthlyAverages[month].sum / monthlyAverages[month].count;
                            
                            // Calcular variación si hay más de un dato
                            if (monthlyCounts[month].length > 1) {
                                const values = monthlyCounts[month];
                                const mean = monthlyAvgs[month];
                                const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                                const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
                                monthlyVariations[month] = Math.sqrt(variance) / mean * 100; // CV porcentual
                            } else {
                                monthlyVariations[month] = 0;
                            }
                        }
                    });
                    
                    // Verificar si hay meses con múltiples puntos de datos para análisis estacional
                    const monthsWithMultipleData = Object.values(monthlyAvgs).length;
                    
                    if (monthsWithMultipleData >= 3) {
                        // Encontrar el mes con mayor y menor valor promedio
                        const months = Object.keys(monthlyAvgs).map(Number);
                        let maxMonth = months[0];
                        let minMonth = months[0];
                        
                        months.forEach(month => {
                            if (monthlyAvgs[month] > monthlyAvgs[maxMonth]) {
                                maxMonth = month;
                            }
                            if (monthlyAvgs[month] < monthlyAvgs[minMonth]) {
                                minMonth = month;
                            }
                        });
                        
                        // Nombres de meses
                        const monthNames = ['', 'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                                          'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                        
                        // Calcular la diferencia porcentual entre el máximo y mínimo mensual
                        const seasonalVariation = (monthlyAvgs[maxMonth] - monthlyAvgs[minMonth]) / monthlyAvgs[minMonth] * 100;
                        
                        if (seasonalVariation > 20) {
                            analysis += `Se observa un patrón estacional significativo (variación del ${seasonalVariation.toFixed(1)}%), `;
                            analysis += `con valores más altos en ${monthNames[maxMonth]} y más bajos en ${monthNames[minMonth]}. `;
                            
                            // Analizar consistencia estacional
                            const highMonthCV = monthlyVariations[maxMonth] || 0;
                            const lowMonthCV = monthlyVariations[minMonth] || 0;
                            
                            if (highMonthCV < 15 && lowMonthCV < 15) {
                                analysis += `Este patrón estacional parece ser consistente año tras año. `;
                            } else {
                                analysis += `Sin embargo, hay variabilidad año a año en estos patrones estacionales. `;
                            }
                        } else if (seasonalVariation > 10) {
                            analysis += `Se observa un patrón estacional moderado, con valores que tienden a ser más altos en ${monthNames[maxMonth]} `;
                            analysis += `y más bajos en ${monthNames[minMonth]}, aunque la variación (${seasonalVariation.toFixed(1)}%) no es muy pronunciada. `;
                        } else {
                            analysis += `No se observa un patrón estacional claro en los datos (variación mensual máxima de ${seasonalVariation.toFixed(1)}%). `;
                        }
                    }
                    
                    // Análisis de volatilidad
                    const periodValues = periods.map(p => averages[p]);
                    const periodDiffs = [];
                    for (let i = 1; i < periodValues.length; i++) {
                        periodDiffs.push(Math.abs((periodValues[i] - periodValues[i-1]) / periodValues[i-1] * 100));
                    }
                    
                    if (periodDiffs.length > 0) {
                        const avgChange = periodDiffs.reduce((sum, val) => sum + val, 0) / periodDiffs.length;
                        const maxChange = Math.max(...periodDiffs);
                        const maxChangeIndex = periodDiffs.indexOf(maxChange);
                        const maxChangePeriods = [periods[maxChangeIndex], periods[maxChangeIndex + 1]];
                        
                        if (avgChange > 10) {
                            analysis += `La serie muestra alta volatilidad, con un cambio promedio del ${avgChange.toFixed(1)}% entre períodos consecutivos. `;
                            analysis += `El mayor cambio (${maxChange.toFixed(1)}%) ocurrió entre ${maxChangePeriods[0]} y ${maxChangePeriods[1]}. `;
                        } else if (avgChange > 5) {
                            analysis += `La serie muestra volatilidad moderada, con un cambio promedio del ${avgChange.toFixed(1)}% entre períodos. `;
                        } else {
                            analysis += `La serie es relativamente estable, con cambios promedio del ${avgChange.toFixed(1)}% entre períodos consecutivos. `;
                        }
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateTimeSeriesAnalysis:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar la serie temporal: ${error.message}`;
            }
        }
        
        // Función para generar la sección de análisis predictivo
        function generatePredictiveSection(container) {
            try {
                console.log('Generando sección de análisis predictivo...');
                
                // Generar el análisis predictivo
                const predictiveResult = generatePredictiveAnalysis();
                
                if (!predictiveResult.success) {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card full-width';
                    cardDiv.innerHTML = `
                        <h2>Análisis Predictivo y Tendencias Futuras</h2>
                        <div class="chart-analysis">
                            <h4>Análisis:</h4>
                            <p>${predictiveResult.message || 'No hay suficientes datos para realizar un análisis predictivo.'}</p>
                        </div>
                    `;
                    container.appendChild(cardDiv);
                    return;
                }
                
                const analysis = predictiveResult.analysis;
                console.log('Análisis predictivo generado correctamente');
                
                // Crear la sección de análisis predictivo
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                cardDiv.innerHTML = `
                    <h2>Análisis Predictivo y Tendencias Futuras</h2>
                    <div class="stats-container" id="prediction-stats"></div>
                    <div id="forecast-chart-container" class="chart-container" style="display: ${analysis.forecast ? 'block' : 'none'}">
                        <canvas id="forecast-chart"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Pronósticos y Tendencias:</h4>
                        <p id="forecast-analysis">Analizando tendencias futuras...</p>
                    </div>
                    <div id="correlations-container" style="margin-top: 20px; display: ${analysis.correlations.length > 0 ? 'block' : 'none'}">
                        <h3>Relaciones y Correlaciones Detectadas</h3>
                        <div id="correlations-content" class="table-container"></div>
                    </div>
                    <div id="segments-container" style="margin-top: 20px; display: ${analysis.segments.length > 0 ? 'block' : 'none'}">
                        <h3>Segmentos Identificados</h3>
                        <div id="segments-content"></div>
                    </div>
                    <div class="chart-analysis" style="margin-top: 20px;">
                        <h4>Acciones Recomendadas:</h4>
                        <div id="predictive-recommendations"></div>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Llenar estadísticas predictivas
                const statsContainer = document.getElementById('prediction-stats');
                
                // Estadística 1: Confianza del modelo
                if (analysis.forecast) {
                    const confidenceStat = document.createElement('div');
                    confidenceStat.className = 'stat-box';
                    confidenceStat.innerHTML = `
                        <h3>Confianza del Pronóstico</h3>
                        <p>${analysis.forecast.confidence === 'alta' ? 'Alta' : analysis.forecast.confidence === 'media' ? 'Media' : 'Baja'}</p>
                    `;
                    statsContainer.appendChild(confidenceStat);
                    
                    // Estadística 2: R-cuadrado
                    const rSquaredStat = document.createElement('div');
                    rSquaredStat.className = 'stat-box';
                    rSquaredStat.innerHTML = `
                        <h3>R² del Modelo</h3>
                        <p>${(analysis.forecast.rSquared || 0).toFixed(2)}</p>
                    `;
                    statsContainer.appendChild(rSquaredStat);
                }
                
                // Estadística 3: Número de segmentos
                if (analysis.segments.length > 0) {
                    const segmentsStat = document.createElement('div');
                    segmentsStat.className = 'stat-box';
                    segmentsStat.innerHTML = `
                        <h3>Segmentos Identificados</h3>
                        <p>${analysis.segments.length}</p>
                    `;
                    statsContainer.appendChild(segmentsStat);
                }
                
                // Estadística 4: Correlaciones significativas
                if (analysis.correlations.length > 0) {
                    const correlationsStat = document.createElement('div');
                    correlationsStat.className = 'stat-box';
                    correlationsStat.innerHTML = `
                        <h3>Correlaciones Significativas</h3>
                        <p>${analysis.correlations.length}</p>
                    `;
                    statsContainer.appendChild(correlationsStat);
                }
                
                // Generar gráfico de pronóstico
                if (analysis.forecast) {
                    try {
                        generateForecastChart(analysis.forecast);
                    } catch (error) {
                        console.error('Error al generar gráfico de pronóstico:', error);
                    }
                }
                
                // Generar tabla de correlaciones
                if (analysis.correlations.length > 0) {
                    try {
                        generateCorrelationsTable(analysis.correlations);
                    } catch (error) {
                        console.error('Error al generar tabla de correlaciones:', error);
                    }
                }
                
                // Generar visualización de segmentos
                if (analysis.segments.length > 0) {
                    try {
                        generateSegmentsVisualization(analysis.segments);
                    } catch (error) {
                        console.error('Error al generar visualización de segmentos:', error);
                    }
                }
                
                // Generar recomendaciones
                try {
                    generatePredictiveRecommendations(analysis.recommendations);
                } catch (error) {
                    console.error('Error al generar recomendaciones predictivas:', error);
                }
                
                // Generar análisis textual del pronóstico
                try {
                    generateForecastAnalysis(analysis);
                } catch (error) {
                    console.error('Error al generar análisis de pronóstico:', error);
                    document.getElementById('forecast-analysis').textContent = 'Error al generar análisis de pronóstico: ' + error.message;
                }
                
                console.log('Sección de análisis predictivo generada correctamente');
            } catch (error) {
                console.error('Error en generatePredictiveSection:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'card full-width';
                errorDiv.innerHTML = `
                    <h2>Error en el Análisis Predictivo</h2>
                    <div class="chart-analysis">
                        <p>Se produjo un error al generar el análisis predictivo: ${error.message}</p>
                    </div>
                `;
                container.appendChild(errorDiv);
            }
        }
        
        // Función para generar gráfico de pronóstico
        function generateForecastChart(forecast) {
            try {
                console.log('Generando gráfico de pronóstico...');
                
                const chartCanvas = document.getElementById('forecast-chart');
                if (!chartCanvas) {
                    console.error('Elemento canvas forecast-chart no encontrado');
                    return;
                }
                
                // Extraer datos históricos y pronósticos
                const dateField = forecast.dateField;
                const valueField = forecast.field;
                
                // Preparar datos históricos
                const timeData = {};
                
                globalData.rawData.forEach(record => {
                    if (record[dateField] && record[valueField]) {
                        // Convertir a fecha
                        let dateValue;
                        try {
                            dateValue = new Date(record[dateField]);
                        } catch (e) {
                            return;
                        }
                        
                        if (isNaN(dateValue.getTime())) return;
                        
                        // Agrupar por mes
                        const year = dateValue.getFullYear();
                        const month = dateValue.getMonth() + 1;
                        const period = `${year}-${month.toString().padStart(2, '0')}`;
                        
                        if (!timeData[period]) {
                            timeData[period] = {
                                sum: 0,
                                count: 0
                            };
                        }
                        
                        const numValue = Number(record[valueField]);
                        if (!isNaN(numValue)) {
                            timeData[period].sum += numValue;
                            timeData[period].count++;
                        }
                    }
                });
                
                // Calcular promedios por período
                const timeAvg = {};
                Object.keys(timeData).forEach(period => {
                    if (timeData[period].count > 0) {
                        timeAvg[period] = timeData[period].sum / timeData[period].count;
                    }
                });
                
                // Ordenar períodos cronológicamente
                const sortedPeriods = Object.keys(timeAvg).sort();
                
                // Formatear etiquetas para datos históricos
                const historicalLabels = sortedPeriods.map(period => {
                    const [year, month] = period.split('-');
                    return `${month}/${year}`;
                });
                
                const historicalData = sortedPeriods.map(period => timeAvg[period]);
                
                // Formatear etiquetas y datos para pronósticos
                const forecastLabels = forecast.forecast.map(item => {
                    const [year, month] = item.period.split('-');
                    return `${month}/${year}`;
                });
                
                const forecastData = forecast.forecast.map(item => item.value);
                
                // Crear datos combinados para el gráfico
                const allLabels = [...historicalLabels, ...forecastLabels];
                
                // Crear datos de pronóstico con null para valores históricos
                const forecastDataWithNull = [
                    ...Array(historicalLabels.length).fill(null),
                    ...forecastData
                ];
                
                console.log('Datos de pronóstico preparados para gráfico');
                
                // Crear gráfico
                const ctx = chartCanvas.getContext('2d');
                if (!ctx) {
                    console.error('No se pudo obtener el contexto 2D para el canvas forecast-chart');
                    return;
                }
                
                charts['forecast-chart'] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allLabels,
                        datasets: [{
                            label: `Datos históricos (${valueField})`,
                            data: [...historicalData, ...Array(forecastLabels.length).fill(null)],
                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
                            borderColor: reportStyles.primaryColor,
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3
                        }, {
                            label: 'Pronóstico',
                            data: forecastDataWithNull,
                            backgroundColor: 'rgba(231, 76, 60, 0.2)',
                            borderColor: reportStyles.accentColor,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: valueField
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Período'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        const value = context.parsed.y !== null ? context.parsed.y.toFixed(2) : 'N/A';
                                        
                                        if (context.datasetIndex === 1 && context.parsed.y !== null) {
                                            // Es un pronóstico
                                            return `${datasetLabel}: ${value} (Predicción)`;
                                        }
                                        
                                        return `${datasetLabel}: ${value}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('Gráfico de pronóstico creado exitosamente');
            } catch (error) {
                console.error('Error en generateForecastChart:', error);
                throw error;
            }
        }
        
        // Función para generar tabla de correlaciones
        function generateCorrelationsTable(correlations) {
            try {
                console.log('Generando tabla de correlaciones...');
                
                const container = document.getElementById('correlations-content');
                if (!container) {
                    console.error('Contenedor correlations-content no encontrado');
                    return;
                }
                
                let html = `
                    <table>
                        <thead>
                            <tr>
                                <th>Variables</th>
                                <th>Correlación</th>
                                <th>Interpretación</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                correlations.forEach(corr => {
                    const corrValue = corr.correlation.toFixed(2);
                    const interpretation = `${corr.strength} ${corr.direction}`;
                    
                    html += `
                        <tr>
                            <td>${corr.field1} y ${corr.field2}</td>
                            <td>${corrValue}</td>
                            <td>${interpretation}</td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                    <div class="chart-analysis">
                        <p>Una correlación positiva indica que cuando una variable aumenta, la otra también tiende a aumentar. 
                        Una correlación negativa indica que cuando una variable aumenta, la otra tiende a disminuir.</p>
                    </div>
                `;
                
                container.innerHTML = html;
                console.log('Tabla de correlaciones generada correctamente');
            } catch (error) {
                console.error('Error en generateCorrelationsTable:', error);
                throw error;
            }
        }
        
        // Función para generar visualización de segmentos
        function generateSegmentsVisualization(segments) {
            try {
                console.log('Generando visualización de segmentos...');
                
                const container = document.getElementById('segments-content');
                if (!container) {
                    console.error('Contenedor segments-content no encontrado');
                    return;
                }
                
                let html = '<div class="stats-container">';
                
                segments.forEach((segment, index) => {
                    const color = [
                        reportStyles.primaryColor,
                        reportStyles.secondaryColor,
                        reportStyles.accentColor,
                        reportStyles.neutralColor
                    ][index % 4];
                    
                    html += `
                        <div class="stat-box" style="border-left-color: ${color}; flex: 1; min-width: 200px;">
                            <h3>${segment.name} (${segment.percentage}%)</h3>
                            <p style="font-size: 1rem; font-weight: normal; margin-top: 5px;">${segment.description}</p>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                container.innerHTML = html;
                console.log('Visualización de segmentos generada correctamente');
            } catch (error) {
                console.error('Error en generateSegmentsVisualization:', error);
                throw error;
            }
        }
        
        // Función para generar recomendaciones predictivas
        function generatePredictiveRecommendations(recommendations) {
            try {
                console.log('Generando recomendaciones predictivas...');
                
                const container = document.getElementById('predictive-recommendations');
                if (!container) {
                    console.error('Contenedor predictive-recommendations no encontrado');
                    return;
                }
                
                if (recommendations.length === 0) {
                    container.innerHTML = '<p>No hay recomendaciones predictivas disponibles con los datos actuales.</p>';
                    return;
                }
                
                let html = '';
                
                recommendations.forEach((rec, index) => {
                    const priorityClass = rec.confidence === 'alta' ? 'priority-high' : 
                                        rec.confidence === 'media' ? 'priority-medium' : '';
                    
                    html += `
                        <div class="recommendation-item ${priorityClass}">
                            <div class="recommendation-icon">${index + 1}</div>
                            <div class="recommendation-content">
                                <h4>${rec.title}</h4>
                                <p>${rec.description}</p>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                console.log('Recomendaciones predictivas generadas correctamente');
            } catch (error) {
                console.error('Error en generatePredictiveRecommendations:', error);
                throw error;
            }
        }
        
        // Función para generar análisis textual del pronóstico
        function generateForecastAnalysis(analysis) {
            try {
                console.log('Generando análisis textual del pronóstico...');
                
                const analysisElement = document.getElementById('forecast-analysis');
                if (!analysisElement) {
                    console.error('Elemento forecast-analysis no encontrado');
                    return;
                }
                
                if (!analysis.forecast) {
                    analysisElement.textContent = 'No hay suficientes datos temporales para generar pronósticos.';
                    return;
                }
                
                let forecastText = '';
                
                // Analizar tendencia
                forecastText += `Los datos de "${analysis.forecast.field}" muestran una tendencia ${analysis.forecast.trend}. `;
                
                // Analizar estacionalidad
                if (analysis.forecast.seasonality && !analysis.forecast.seasonality.includes('no detectada')) {
                    forecastText += `Se ha detectado estacionalidad ${analysis.forecast.seasonality}. `;
                }
                
                // Describir modelo
                forecastText += `El modelo predictivo (${analysis.forecast.equation}) tiene un coeficiente de determinación R² de ${analysis.forecast.rSquared.toFixed(2)}, `;
                forecastText += `lo que indica una ${analysis.forecast.rSquared > 0.7 ? 'alta' : analysis.forecast.rSquared > 0.4 ? 'moderada' : 'baja'} capacidad predictiva. `;
                
                // Describir pronóstico
                if (analysis.forecast.forecast.length > 0) {
                    const firstForecast = analysis.forecast.forecast[0];
                    const lastForecast = analysis.forecast.forecast[analysis.forecast.forecast.length - 1];
                    
                    forecastText += `Para el próximo período (${firstForecast.period}) se prevé un valor de ${firstForecast.value.toFixed(2)}. `;
                    
                    if (analysis.forecast.forecast.length > 1) {
                        const firstValue = firstForecast.value;
                        const lastValue = lastForecast.value;
                        const change = ((lastValue - firstValue) / firstValue) * 100;
                        
                        if (Math.abs(change) > 5) {
                            forecastText += `Se proyecta que el valor ${change > 0 ? 'aumentará' : 'disminuirá'} un ${Math.abs(change).toFixed(1)}% `;
                            forecastText += `en los próximos ${analysis.forecast.forecast.length} períodos. `;
                        } else {
                            forecastText += `Se proyecta que el valor se mantendrá relativamente estable en los próximos períodos. `;
                        }
                    }
                }
                
                // Analizar correlaciones si existen
                if (analysis.correlations.length > 0) {
                    const topCorrelation = analysis.correlations[0];
                    
                    forecastText += `Existe una correlación ${topCorrelation.strength} ${topCorrelation.direction} (${topCorrelation.correlation.toFixed(2)}) `;
                    forecastText += `entre "${topCorrelation.field1}" y "${topCorrelation.field2}", lo que puede utilizarse para mejorar la precisión predictiva. `;
                }
                
                // Mencionar segmentos si existen
                if (analysis.segments.length > 0) {
                    forecastText += `Se han identificado ${analysis.segments.length} segmentos distintos en los datos, `;
                    forecastText += `cada uno con patrones y características específicas que pueden requerir estrategias diferenciadas. `;
                }
                
                analysisElement.textContent = forecastText;
                console.log('Análisis de pronóstico generado correctamente');
            } catch (error) {
                console.error('Error en generateForecastAnalysis:', error);
                throw error;
            }
        }
        
        // Función para generar tabla de datos con selección de campos
        function generateDataTable(container) {
            try {
                console.log('Generando tabla de datos...');
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const tableId = 'data-summary-table';
                
                // Agregar selectores de campo
                cardDiv.innerHTML = `
                    <h2>Resumen de Datos</h2>
                    <div class="field-selector-container">
                        <div class="field-selector">
                            <label for="category-field-selector">Campo categórico:</label>
                            <select id="category-field-selector" class="field-select">
                                <option value="">Ninguno</option>
                            </select>
                        </div>
                        <div class="field-selector">
                            <label for="numeric-fields-selector">Campos numéricos:</label>
                            <select id="numeric-fields-selector" class="field-select" multiple size="4">
                            </select>
                        </div>
                        <button id="update-table-btn" class="btn btn-primary">Actualizar Tabla</button>
                    </div>
                    <div class="print-options">
                        <h4>Opciones de impresión:</h4>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-data-table" checked> Incluir tabla de datos
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-predictions" checked> Incluir predicciones
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-correlations" checked> Incluir correlaciones
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-segments" checked> Incluir segmentos
                        </label>
                    </div>
                    <div class="table-container">
                        <table id="${tableId}" class="data-table">
                            <thead>
                                <tr id="${tableId}-header"></tr>
                            </thead>
                            <tbody id="${tableId}-body"></tbody>
                        </table>
                    </div>
                    <div class="chart-analysis">
                        <h4>Análisis:</h4>
                        <p id="table-analysis">Esta tabla muestra un resumen de los principales hallazgos en los datos analizados.</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Configurar eventos de opciones de impresión
                document.getElementById('print-data-table').addEventListener('change', function() {
                    printOptions.includeDataTable = this.checked;
                });
                
                document.getElementById('print-predictions').addEventListener('change', function() {
                    printOptions.includePredictions = this.checked;
                });
                
                document.getElementById('print-correlations').addEventListener('change', function() {
                    printOptions.includeCorrelations = this.checked;
                });
                
                document.getElementById('print-segments').addEventListener('change', function() {
                    printOptions.includeSegments = this.checked;
                });
                
                // Llenar selectores de campo
                populateFieldSelectors();
                
                // Configurar evento para actualizar tabla
                document.getElementById('update-table-btn').addEventListener('click', function() {
                    updateDataTable(tableId);
                });
                
                // Crear tabla inicial
                updateDataTable(tableId);
                
                console.log('Tabla de datos generada correctamente');
            } catch (error) {
                console.error('Error en generateDataTable:', error);
                throw error;
            }
        }
        
        // Función para llenar los selectores de campo
        function populateFieldSelectors() {
            try {
                console.log('Llenando selectores de campo...');
                
                const categorySelector = document.getElementById('category-field-selector');
                const numericSelector = document.getElementById('numeric-fields-selector');
                
                if (!categorySelector || !numericSelector) {
                    console.error('Selectores de campo no encontrados');
                    return;
                }
                
                // Limpiar selectores
                categorySelector.innerHTML = '<option value="">Ninguno</option>';
                numericSelector.innerHTML = '';
                
                // Llenar selector de campos categóricos
                const categoryFields = Object.keys(globalData.categories);
                categoryFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    
                    // Seleccionar si está en los campos seleccionados
                    if (globalData.selectedFields.categories.includes(field)) {
                        option.selected = true;
                    }
                    
                    categorySelector.appendChild(option);
                });
                
                // Llenar selector de campos numéricos
                const numericFields = Object.keys(globalData.numerics);
                numericFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    
                    // Seleccionar si está en los campos seleccionados
                    if (globalData.selectedFields.numerics.includes(field)) {
                        option.selected = true;
                    }
                    
                    numericSelector.appendChild(option);
                });
                
                console.log('Selectores de campo llenados correctamente');
            } catch (error) {
                console.error('Error en populateFieldSelectors:', error);
            }
        }
        
        // Función para actualizar la tabla con los campos seleccionados
        function updateDataTable(tableId) {
            try {
                console.log('Actualizando tabla de datos...');
                
                // Obtener campos seleccionados
                const categorySelector = document.getElementById('category-field-selector');
                const numericSelector = document.getElementById('numeric-fields-selector');
                
                if (!categorySelector || !numericSelector) {
                    console.error('Selectores de campo no encontrados');
                    return;
                }
                
                // Actualizar campos seleccionados en datos globales
                globalData.selectedFields.categories = [];
                if (categorySelector.value) {
                    globalData.selectedFields.categories = [categorySelector.value];
                }
                
                globalData.selectedFields.numerics = Array.from(numericSelector.selectedOptions).map(option => option.value);
                
                console.log('Campos seleccionados:', globalData.selectedFields);
                
                // Crear encabezado de tabla
                const headerRow = document.getElementById(`${tableId}-header`);
                const tableBody = document.getElementById(`${tableId}-body`);
                
                if (!headerRow || !tableBody) {
                    console.error('Elementos de tabla no encontrados');
                    return;
                }
                
                // Limpiar tabla actual
                headerRow.innerHTML = '';
                tableBody.innerHTML = '';
                
                // Decidir qué campos mostrar
                let fieldsToShow = [];
                
                // Mostrar campo categórico seleccionado
                if (globalData.selectedFields.categories.length > 0) {
                    fieldsToShow.push({
                        type: 'category',
                        field: globalData.selectedFields.categories[0]
                    });
                }
                
                // Mostrar campos numéricos seleccionados
                globalData.selectedFields.numerics.forEach(field => {
                    fieldsToShow.push({
                        type: 'numeric',
                        field: field
                    });
                });
                
                // Si no hay campos seleccionados, mostrar mensaje
                if (fieldsToShow.length === 0) {
                    const analysisElement = document.getElementById('table-analysis');
                    if (analysisElement) {
                        analysisElement.textContent = 'Seleccione al menos un campo para mostrar estadísticas.';
                    }
                    return;
                }
                
                // Agregar encabezados
                const headers = ['Estadística', ...fieldsToShow.map(f => f.field)];
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                
                // Crear filas de estadísticas ampliadas
                const stats = [
                    { name: 'Tipo de datos', fn: (field, type) => globalData.fields[field].type },
                    { name: 'Conteo total', fn: (field, type) => {
                        if (type === 'numeric') {
                            return globalData.numerics[field].stats.count;
                        } else if (type === 'category') {
                            return Object.values(globalData.categories[field].distribution).reduce((a, b) => a + b, 0);
                        }
                        return 'N/A';
                    }},
                    { name: 'Valores únicos', fn: (field, type) => {
                        if (type === 'category') {
                            return globalData.categories[field].uniqueValues.length;
                        } else if (type === 'numeric') {
                            return 'N/A';
                        }
                        return 'N/A';
                    }},
                    { name: 'Valor más frecuente', fn: (field, type) => {
                        if (type === 'category') {
                            const distribution = globalData.categories[field].distribution;
                            const sorted = Object.entries(distribution).sort((a, b) => b[1] - a[1]);
                            if (sorted.length > 0) {
                                return `${sorted[0][0]} (${sorted[0][1]})`;
                            }
                        }
                        return 'N/A';
                    }},
                    { name: 'Frecuencia del valor más común', fn: (field, type) => {
                        if (type === 'category') {
                            const distribution = globalData.categories[field].distribution;
                            const sorted = Object.entries(distribution).sort((a, b) => b[1] - a[1]);
                            if (sorted.length > 0) {
                                const total = Object.values(distribution).reduce((a, b) => a + b, 0);
                                return `${sorted[0][1]} (${((sorted[0][1]/total)*100).toFixed(2)}%)`;
                            }
                        }
                        return 'N/A';
                    }},
                    { name: 'Valor mínimo', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.min.toFixed(2) : 'N/A' },
                    { name: 'Primer cuartil (Q1)', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.q1.toFixed(2) : 'N/A' },
                    { name: 'Mediana', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.median.toFixed(2) : 'N/A' },
                    { name: 'Tercer cuartil (Q3)', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.q3.toFixed(2) : 'N/A' },
                    { name: 'Valor máximo', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.max.toFixed(2) : 'N/A' },
                    { name: 'Promedio', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.mean.toFixed(2) : 'N/A' },
                    { name: 'Desviación estándar', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.std.toFixed(2) : 'N/A' },
                    { name: 'Coef. de variación (%)', fn: (field, type) => {
                        if (type === 'numeric') {
                            const stats = globalData.numerics[field].stats;
                            return ((stats.std / stats.mean) * 100).toFixed(2);
                        }
                        return 'N/A';
                    }},
                    { name: 'Asimetría', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.skewness !== undefined ? 
                        globalData.numerics[field].stats.skewness.toFixed(2) : 'N/A' },
                    { name: 'Curtosis', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.kurtosis !== undefined ? 
                        globalData.numerics[field].stats.kurtosis.toFixed(2) : 'N/A' },
                    { name: 'Outliers detectados', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.outliers ? 
                        globalData.numerics[field].stats.outliers.length : 'N/A' }
                ];
                
                // Agregar filas
                stats.forEach(stat => {
                    const row = document.createElement('tr');
                    
                    const nameCell = document.createElement('td');
                    nameCell.textContent = stat.name;
                    row.appendChild(nameCell);
                    
                    fieldsToShow.forEach(fieldInfo => {
                        const cell = document.createElement('td');
                        cell.textContent = stat.fn(fieldInfo.field, fieldInfo.type);
                        row.appendChild(cell);
                    });
                    
                    tableBody.appendChild(row);
                });
                
                // Actualizar análisis de tabla
                const analysisElement = document.getElementById('table-analysis');
                if (analysisElement) {
                    const fieldsText = fieldsToShow.map(f => `"${f.field}"`).join(', ');
                    analysisElement.textContent = `Esta tabla muestra un resumen estadístico detallado de los campos ${fieldsText}. Puede seleccionar diferentes campos para analizar otras variables de interés.`;
                }
                
                console.log('Tabla de datos actualizada correctamente');
            } catch (error) {
                console.error('Error en updateDataTable:', error);
                const analysisElement = document.getElementById('table-analysis');
                if (analysisElement) {
                    analysisElement.textContent = `Error al actualizar la tabla: ${error.message}`;
                }
            }
        }
        
        // Función para generar análisis y recomendaciones
        function generateAnalysisAndRecommendations() {
            try {
                console.log('Generando análisis y recomendaciones...');
                
                const conclusionElement = document.getElementById('general-conclusion');
                const recommendationsContainer = document.getElementById('recommendations-container');
                
                if (!conclusionElement || !recommendationsContainer) {
                    console.error('Elementos de análisis y recomendaciones no encontrados');
                    return;
                }
                
                // Generar conclusión general
                let conclusion = `Análisis de ${globalData.totalRecords} registros con ${Object.keys(globalData.fields).length} campos. `;
                
                // Análisis de campos categóricos
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const categoryValues = globalData.categories[mainCategory].uniqueValues.length;
                    
                    conclusion += `Se identificaron ${categoryValues} valores únicos en el campo principal "${mainCategory}". `;
                    
                    // Analizar concentración
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1]);
                    
                    if (sortedValues.length > 0) {
                        const topValue = sortedValues[0];
                        const topPercentage = ((topValue[1] / globalData.totalRecords) * 100).toFixed(1);
                        
                        if (parseFloat(topPercentage) > 50) {
                            conclusion += `Existe una alta concentración en el valor "${topValue[0]}" (${topPercentage}% del total). `;
                        } else if (parseFloat(topPercentage) > 30) {
                            conclusion += `El valor "${topValue[0]}" representa una proporción significativa (${topPercentage}%). `;
                        }
                    }
                }
                
                // Análisis de campos numéricos
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    // Analizar dispersión
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        conclusion += `El campo "${mainNumeric}" muestra una alta variabilidad (CV = ${cv.toFixed(1)}%), `;
                        conclusion += `lo que indica una distribución heterogénea de valores. `;
                    } else if (cv > 20) {
                        conclusion += `El campo "${mainNumeric}" muestra una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        conclusion += `El campo "${mainNumeric}" muestra valores bastante homogéneos (CV = ${cv.toFixed(1)}%). `;
                    }
                    
                    // Análisis de asimetría si está disponible
                    if (stats.skewness !== undefined) {
                        if (Math.abs(stats.skewness) > 1) {
                            conclusion += `La distribución presenta una fuerte asimetría ${stats.skewness > 0 ? 'positiva' : 'negativa'} (${stats.skewness.toFixed(2)}), `;
                            conclusion += `lo que afecta la interpretación de las medidas centrales. `;
                        }
                    }
                    
                    // Análisis de outliers
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outlierPerc = (stats.outliers.length / stats.count * 100).toFixed(1);
                        conclusion += `Se identificaron ${stats.outliers.length} valores atípicos (${outlierPerc}%) que podrían requerir atención especial. `;
                    }
                }
                
                // Análisis de campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0) {
                    conclusion += `La presencia de campos de fecha permite analizar tendencias temporales y realizar pronósticos. `;
                    
                    // Incluir resultados del análisis predictivo si hay disponibles
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.forecast) {
                        const forecast = predictiveResult.analysis.forecast;
                        conclusion += `El análisis predictivo indica una tendencia ${forecast.trend} para el campo "${forecast.field}" `;
                        conclusion += `con un nivel de confianza ${forecast.confidence}. `;
                    }
                }
                
                // Actualizar elemento de conclusión
                conclusionElement.textContent = conclusion;
                
                // Generar recomendaciones
                recommendationsContainer.innerHTML = '';
                
                // Lista de recomendaciones basadas en el análisis
                const recommendations = [];
                
                // Recomendación basada en campos categóricos
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1]);
                    
                    if (sortedValues.length > 5) {
                        const topValues = sortedValues.slice(0, 3);
                        const topCount = topValues.reduce((sum, item) => sum + item[1], 0);
                        const topPercentage = ((topCount / globalData.totalRecords) * 100).toFixed(1);
                        
                        if (parseFloat(topPercentage) > 60) {
                            recommendations.push({
                                title: `Profundizar análisis en categorías principales de "${mainCategory}"`,
                                content: `Los 3 valores principales (${topValues.map(v => v[0]).join(', ')}) representan el ${topPercentage}% de los datos. Se recomienda realizar un análisis específico de estos segmentos para identificar patrones distintivos.`,
                                priority: 'high'
                            });
                        } else {
                            recommendations.push({
                                title: `Segmentar análisis por categorías de "${mainCategory}"`,
                                content: `Evaluar el comportamiento de las diferentes categorías para identificar posibles variaciones significativas en los indicadores principales.`,
                                priority: 'medium'
                            });
                        }
                    }
                }
                
                // Recomendación basada en campos numéricos
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    // Analizar dispersión
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        recommendations.push({
                            title: `Investigar valores extremos en "${mainNumeric}"`,
                            content: `La alta variabilidad (CV = ${cv.toFixed(1)}%) sugiere la presencia de valores extremos. Se recomienda identificar y analizar estos casos para determinar si son errores de datos o valores atípicos legítimos que requieren atención especial.`,
                            priority: 'high'
                        });
                    }
                    
                    // Recomendación basada en outliers
                    if (stats.outliers && stats.outliers.length > 5) {
                        recommendations.push({
                            title: `Tratar valores atípicos identificados`,
                            content: `Se detectaron ${stats.outliers.length} valores atípicos en "${mainNumeric}". Considere aplicar técnicas de winsorización o transformación para reducir su impacto en los análisis estadísticos.`,
                            priority: 'medium'
                        });
                    }
                    
                    // Recomendación basada en asimetría
                    if (stats.skewness !== undefined && Math.abs(stats.skewness) > 1.5) {
                        recommendations.push({
                            title: `Considerar transformación de datos para "${mainNumeric}"`,
                            content: `La distribución muestra una fuerte asimetría (${stats.skewness.toFixed(2)}). Para análisis estadísticos más precisos, considere aplicar una transformación ${stats.skewness > 0 ? 'logarítmica o raíz cuadrada' : 'cuadrática o exponencial'} para normalizar los datos.`,
                            priority: 'medium'
                        });
                    }
                }
                
                // Recomendación basada en campos de fecha
                if (dateFields.length > 0 && numericFields.length > 0) {
                    recommendations.push({
                        title: 'Realizar análisis de tendencias temporales',
                        content: 'Aprovechar los campos de fecha para analizar la evolución de los indicadores clave a lo largo del tiempo, identificando patrones estacionales y tendencias a largo plazo.',
                        priority: 'medium'
                    });
                    
                    // Añadir recomendación de pronóstico si hay suficientes datos
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.forecast) {
                        const forecast = predictiveResult.analysis.forecast;
                        
                        if (forecast.trend.includes('creciente')) {
                            recommendations.push({
                                title: `Preparar recursos para tendencia creciente en "${forecast.field}"`,
                                content: `El análisis predictivo muestra una tendencia ${forecast.trend} con ${forecast.confidence} confianza. Se recomienda planificar recursos adicionales para adaptarse a este crecimiento proyectado.`,
                                priority: 'high'
                            });
                        } else if (forecast.trend.includes('decreciente')) {
                            recommendations.push({
                                title: `Estrategias para mitigar tendencia decreciente en "${forecast.field}"`,
                                content: `El análisis predictivo muestra una tendencia ${forecast.trend} con ${forecast.confidence} confianza. Se recomienda implementar estrategias correctivas para contrarrestar esta tendencia negativa.`,
                                priority: 'high'
                            });
                        }
                        
                        if (forecast.seasonality && !forecast.seasonality.includes('no detectada')) {
                            recommendations.push({
                                title: `Adaptar recursos a patrones estacionales detectados`,
                                content: `Se ha identificado estacionalidad ${forecast.seasonality} en "${forecast.field}". Se recomienda ajustar la asignación de recursos de forma anticipada para estos ciclos recurrentes.`,
                                priority: 'medium'
                            });
                        }
                    }
                }
                
                // Recomendación basada en correlaciones
                if (numericFields.length >= 2) {
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.correlations.length > 0) {
                        const mainCorrelation = predictiveResult.analysis.correlations[0];
                        
                        recommendations.push({
                            title: `Aprovechar correlación entre "${mainCorrelation.field1}" y "${mainCorrelation.field2}"`,
                            content: `Se ha detectado una correlación ${mainCorrelation.strength} ${mainCorrelation.direction} (${mainCorrelation.correlation.toFixed(2)}) entre estas variables. Esta relación puede ser explotada para optimizar estrategias y recursos.`,
                            priority: mainCorrelation.strength === 'fuerte' ? 'high' : 'medium'
                        });
                    }
                }
                
                // Recomendación general
                recommendations.push({
                    title: 'Enriquecer los datos con variables adicionales',
                    content: 'Considerar la inclusión de variables contextuales adicionales que puedan enriquecer el análisis y proporcionar nuevas perspectivas sobre los patrones observados.',
                    priority: 'low'
                });
                
                // Agregar recomendaciones al contenedor
                recommendations.forEach((rec, index) => {
                    const recElement = document.createElement('div');
                    recElement.className = `recommendation-item priority-${rec.priority}`;
                    recElement.innerHTML = `
                        <div class="recommendation-icon">${index + 1}</div>
                        <div class="recommendation-content">
                            <h4>${rec.title}</h4>
                            <p>${rec.content}</p>
                        </div>
                    `;
                    recommendationsContainer.appendChild(recElement);
                });
                
                console.log('Análisis y recomendaciones generados correctamente');
            } catch (error) {
                console.error('Error en generateAnalysisAndRecommendations:', error);
                
                const conclusionElement = document.getElementById('general-conclusion');
                if (conclusionElement) {
                    conclusionElement.textContent = 'Error al generar el análisis: ' + error.message;
                }
                
                const recommendationsContainer = document.getElementById('recommendations-container');
                if (recommendationsContainer) {
                    recommendationsContainer.innerHTML = `
                        <div class="recommendation-item">
                            <div class="recommendation-icon">!</div>
                            <div class="recommendation-content">
                                <h4>Error al generar recomendaciones</h4>
                                <p>Se produjo un error al analizar los datos y generar recomendaciones: ${error.message}</p>
                            </div>
                        </div>
                    `;
                }
            }
        }
        
        // Función para configurar filtros dinámicos
        function setupDynamicFilters() {
            try {
                console.log('Configurando filtros dinámicos...');
                
                const dynamicFiltersContainer = document.getElementById('dynamic-filters');
                if (!dynamicFiltersContainer) {
                    console.error('Contenedor de filtros dinámicos no encontrado');
                    return;
                }
                
                dynamicFiltersContainer.innerHTML = '';
                
                // Solo mostrar filtros si hay datos
                if (globalData.totalRecords === 0) return;
                
                document.getElementById('applied-filters').style.display = 'block';
                
                // Crear filtros para campos categóricos principales (max 3)
                const categoryFields = Object.keys(globalData.categories);
                categoryFields.slice(0, 3).forEach(field => {
                    const fieldInfo = globalData.categories[field];
                    
                    if (fieldInfo.uniqueValues.length <= 20) {
                        const filterGroup = document.createElement('div');
                        filterGroup.className = 'filter-group';
                        
                        const label = document.createElement('label');
                        label.textContent = field;
                        
                        const select = document.createElement('select');
                        select.id = `filter-${field.replace(/\s+/g, '-').toLowerCase()}`;
                        select.className = 'filter-select';
                        select.setAttribute('data-field', field);
                        
                        // Opción para todos
                        const allOption = document.createElement('option');
                        allOption.value = 'all';
                        allOption.textContent = 'Todos';
                        select.appendChild(allOption);
                        
                        // Ordenar valores por frecuencia
                        const sortedValues = Object.entries(fieldInfo.distribution)
                            .sort((a, b) => b[1] - a[1])
                            .map(item => item[0]);
                        
                        // Agregar opciones
                        sortedValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            select.appendChild(option);
                        });
                        
                        // Evento para aplicar filtro
                        select.addEventListener('change', applyDynamicFilters);
                        
                        filterGroup.appendChild(label);
                        filterGroup.appendChild(select);
                        
                        dynamicFiltersContainer.appendChild(filterGroup);
                    }
                });
                
                // Botón para limpiar filtros
                if (categoryFields.length > 0) {
                    const clearButton = document.createElement('button');
                    clearButton.className = 'btn btn-warning';
                    clearButton.textContent = 'Limpiar Filtros';
                    clearButton.addEventListener('click', clearFilters);
                    
                    dynamicFiltersContainer.appendChild(clearButton);
                }
                
                console.log('Filtros dinámicos configurados correctamente');
            } catch (error) {
                console.error('Error en setupDynamicFilters:', error);
            }
        }
        
        // Función para mostrar/ocultar panel de filtros
        function toggleFilterPanel() {
            const appliedFilters = document.getElementById('applied-filters');
            appliedFilters.style.display = appliedFilters.style.display === 'none' || appliedFilters.style.display === '' ? 'block' : 'none';
        }
        
        // Función para aplicar filtros dinámicos
        function applyDynamicFilters() {
            try {
                console.log('Aplicando filtros dinámicos...');
                
                // Obtener todos los filtros aplicados
                const filters = {};
                document.querySelectorAll('.filter-select').forEach(select => {
                    if (select.value !== 'all') {
                        filters[select.getAttribute('data-field')] = select.value;
                    }
                });
                
                console.log('Filtros aplicados:', filters);
                
                // Si no hay filtros, restaurar datos originales
                if (Object.keys(filters).length === 0) {
                    clearFilters();
                    return;
                }
                
                // Guardar filtros aplicados
                globalData.appliedFilters = filters;
                
                // Filtrar datos a partir de los datos originales
                if (originalData) {
                    const filteredData = originalData.rawData.filter(record => {
                        // Comprobar si cumple todos los filtros
                        return Object.entries(filters).every(([field, value]) => {
                            return String(record[field]) === String(value);
                        });
                    });
                    
                    console.log(`Datos filtrados: ${filteredData.length} registros`);
                    
                    // Crear un nuevo objeto de datos globales
                    globalData = {
                        totalRecords: filteredData.length,
                        fields: {},
                        categories: {},
                        numerics: {},
                        dates: {},
                        appliedFilters: filters,
                        rawData: filteredData,
                        selectedFields: JSON.parse(JSON.stringify(originalData.selectedFields))
                    };
                    
                    // Reprocesar los datos filtrados para recalcular estadísticas
                    if (filteredData.length > 0) {
                        const fieldNames = Object.keys(filteredData[0]);
                        
                        // Analizar cada campo para detectar su tipo
                        fieldNames.forEach(field => {
                            try {
                                globalData.fields[field] = analyzeField(filteredData, field);
                            } catch (fieldError) {
                                console.error(`Error al analizar el campo ${field}:`, fieldError);
                                globalData.fields[field] = {
                                    name: field,
                                    type: 'unknown',
                                    uniqueValues: [],
                                    distribution: {},
                                    stats: {}
                                };
                            }
                        });
                        
                        // Clasificar campos por tipo
                        fieldNames.forEach(field => {
                            const fieldInfo = globalData.fields[field];
                            
                            if (fieldInfo.type === 'date') {
                                globalData.dates[field] = fieldInfo;
                            } else if (fieldInfo.type === 'numeric') {
                                globalData.numerics[field] = fieldInfo;
                            } else if (fieldInfo.type === 'categorical') {
                                globalData.categories[field] = fieldInfo;
                            }
                        });
                    }
                    
                    // Actualizar dashboard
                    generateDashboard();
                    
                    // Mostrar badges de filtros aplicados
                    displayFilterBadges(filters);
                }
                
                console.log('Filtros aplicados correctamente');
            } catch (error) {
                console.error('Error en applyDynamicFilters:', error);
                showAlert('error-alert', 'Error al aplicar filtros: ' + error.message);
            }
        }
        
        // Función para mostrar badges de filtros aplicados
        function displayFilterBadges(filters) {
            try {
                console.log('Mostrando badges de filtros aplicados...');
                
                const badgesContainer = document.getElementById('filter-badges');
                if (!badgesContainer) {
                    console.error('Contenedor de badges de filtros no encontrado');
                    return;
                }
                
                badgesContainer.innerHTML = '';
                
                Object.entries(filters).forEach(([field, value]) => {
                    const badge = document.createElement('div');
                    badge.className = 'filter-badge';
                    badge.textContent = `${field}: ${value}`;
                    badgesContainer.appendChild(badge);
                });
                
                console.log('Badges de filtros mostrados correctamente');
            } catch (error) {
                console.error('Error en displayFilterBadges:', error);
            }
        }
        
        // Función para limpiar filtros
        function clearFilters() {
            try {
                console.log('Limpiando filtros...');
                
                if (!originalData) {
                    console.warn('No hay datos originales para restaurar');
                    return;
                }
                
                // Restaurar datos originales
                globalData = JSON.parse(JSON.stringify(originalData));
                
                // Limpiar selectores de filtro
                document.querySelectorAll('.filter-select').forEach(select => {
                    select.value = 'all';
                });
                
                // Limpiar badges de filtros
                const badgesContainer = document.getElementById('filter-badges');
                if (badgesContainer) {
                    badgesContainer.innerHTML = '';
                }
                
                // Regenerar dashboard
                generateDashboard();
                
                console.log('Filtros limpiados correctamente');
            } catch (error) {
                console.error('Error en clearFilters:', error);
                showAlert('error-alert', 'Error al limpiar filtros: ' + error.message);
            }
        }
        
        // Función mejorada para imprimir informe
        function printReport() {
            try {
                console.log('Preparando informe para impresión...');
                
                // Si no hay datos, mostrar mensaje
                if (globalData.totalRecords === 0) {
                    showAlert('info-alert', 'No hay datos para imprimir. Primero debe cargar y procesar datos.');
                    return;
                }
                
                // Mostrar loader
                document.getElementById('loader').style.display = 'block';
                
                // Actualizar título y subtítulo del informe
                document.getElementById('print-title').textContent = document.getElementById('report-title').value;
                document.getElementById('print-subtitle').textContent = document.getElementById('report-subtitle').value;
                
                // Mostrar cabecera personalizada
                document.getElementById('header-custom').style.display = 'block';
                
                // Actualizar fecha actual
                const now = new Date();
                document.getElementById('current-date').textContent = now.toLocaleDateString();
                
                // Aplicar opciones de impresión
                applyPrintOptions();
                
                // Dar tiempo para que se actualice el DOM antes de imprimir
                setTimeout(() => {
                    // Ocultar el loader
                    document.getElementById('loader').style.display = 'none';
                    
                    // Imprimir
                    window.print();
                    
                    // Restaurar opciones de impresión
                    restorePrintOptions();
                    
                    // Ocultar cabecera personalizada después de imprimir
                    setTimeout(() => {
                        document.getElementById('header-custom').style.display = 'none';
                    }, 1000);
                    
                    console.log('Impresión del informe completada');
                }, 500);
            } catch (error) {
                console.error('Error en printReport:', error);
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error al preparar el informe para impresión: ' + error.message);
            }
        }
        
        // Función para aplicar opciones de impresión
        function applyPrintOptions() {
            try {
                console.log('Aplicando opciones de impresión...');
                
                // Ocultar secciones según las opciones seleccionadas
                const dataTable = document.querySelector('.card:has(#data-summary-table)');
                if (dataTable && !printOptions.includeDataTable) {
                    dataTable.classList.add('print-hide');
                }
                
                const predictionSection = document.querySelector('.card:has(#forecast-chart-container)');
                if (predictionSection && !printOptions.includePredictions) {
                    predictionSection.classList.add('print-hide');
                }
                
                const correlationsContainer = document.getElementById('correlations-container');
                if (correlationsContainer && !printOptions.includeCorrelations) {
                    correlationsContainer.dataset.originalDisplay = correlationsContainer.style.display;
                    correlationsContainer.style.display = 'none';
                }
                
                const segmentsContainer = document.getElementById('segments-container');
                if (segmentsContainer && !printOptions.includeSegments) {
                    segmentsContainer.dataset.originalDisplay = segmentsContainer.style.display;
                    segmentsContainer.style.display = 'none';
                }
                
                console.log('Opciones de impresión aplicadas correctamente');
            } catch (error) {
                console.error('Error en applyPrintOptions:', error);
            }
        }
        
        // Función para restaurar opciones de impresión
        function restorePrintOptions() {
            try {
                console.log('Restaurando opciones de impresión...');
                
                // Restaurar visibilidad de secciones
                document.querySelectorAll('.print-hide').forEach(element => {
                    element.classList.remove('print-hide');
                });
                
                const correlationsContainer = document.getElementById('correlations-container');
                if (correlationsContainer) {
                    correlationsContainer.style.display = correlationsContainer.dataset.originalDisplay || '';
                }
                
                const segmentsContainer = document.getElementById('segments-container');
                if (segmentsContainer) {
                    segmentsContainer.style.display = segmentsContainer.dataset.originalDisplay || '';
                }
                
                console.log('Opciones de impresión restauradas correctamente');
            } catch (error) {
                console.error('Error en restorePrintOptions:', error);
            }
        }
        
        // Función para generar colores basados en un color base
        function generateColors(count) {
            // Colores base
            const baseColors = [
                reportStyles.primaryColor,
                reportStyles.secondaryColor,
                reportStyles.accentColor,
                reportStyles.neutralColor,
                shiftHue(reportStyles.primaryColor, 30),
                shiftHue(reportStyles.secondaryColor, 30),
                shiftHue(reportStyles.accentColor, 30),
                shiftHue(reportStyles.primaryColor, -30),
                shiftHue(reportStyles.secondaryColor, -30),
                shiftHue(reportStyles.accentColor, -30)
            ];
            
            // Si hay suficientes colores base, usarlos
            if (count <= baseColors.length) {
                return baseColors.slice(0, count);
            }
            
            // Si necesitamos más colores, generar colores adicionales
            const colors = [...baseColors];
            
            for (let i = baseColors.length; i < count; i++) {
                // Generar un color basado en la posición
                const hue = (i * 137) % 360; // Distribución uniforme del matiz
                colors.push(`hsl(${hue}, 70%, 60%)`);
            }
            
            return colors;
        }
        
        // Función para cambiar el matiz de un color
        function shiftHue(hexColor, amount) {
            // Convertir hex a RGB
            const r = parseInt(hexColor.slice(1, 3), 16) / 255;
            const g = parseInt(hexColor.slice(3, 5), 16) / 255;
            const b = parseInt(hexColor.slice(5, 7), 16) / 255;
            
            // Convertir RGB a HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Acromático
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Modificar matiz
            h = (h * 360 + amount) % 360;
            if (h < 0) h += 360;
            h /= 360;
            
            // Convertir HSL a RGB
            let r1, g1, b1;
            
            if (s === 0) {
                r1 = g1 = b1 = l; // Acromático
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r1 = hue2rgb(p, q, h + 1/3);
                g1 = hue2rgb(p, q, h);
                b1 = hue2rgb(p, q, h - 1/3);
            }
            
            // Convertir RGB a hex
            const toHex = x => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`;
        }
        
        // Función para actualizar colores de los gráficos
        function updateChartsColors() {
            try {
                console.log('Actualizando colores de los gráficos...');
                
                for (const chartId in charts) {
                    if (charts[chartId]) {
                        const chart = charts[chartId];
                        
                        if (chart.config.type === 'pie') {
                            chart.data.datasets[0].backgroundColor = generateColors(chart.data.labels.length);
                        } else if (chart.config.type === 'bar') {
                            if (chart.data.datasets.length === 1) {
                                chart.data.datasets[0].backgroundColor = reportStyles.primaryColor;
                                chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                            } else if (chart.data.datasets.length >= 2) {
                                chart.data.datasets[0].backgroundColor = reportStyles.primaryColor;
                                chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                                chart.data.datasets[1].backgroundColor = reportStyles.secondaryColor;
                                chart.data.datasets[1].borderColor = reportStyles.secondaryColor;
                            }
                        } else if (chart.config.type === 'line') {
                            chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                            chart.data.datasets[0].backgroundColor = `${reportStyles.primaryColor}33`; // Con transparencia
                            
                            if (chart.data.datasets.length >= 2) {
                                chart.data.datasets[1].borderColor = reportStyles.accentColor;
                                chart.data.datasets[1].backgroundColor = `${reportStyles.accentColor}33`;
                            }
                            
                            if (chart.data.datasets.length >= 3) {
                                chart.data.datasets[2].borderColor = reportStyles.secondaryColor;
                            }
                        }
                        
                        chart.update();
                    }
                }
                
                console.log('Colores de gráficos actualizados correctamente');
            } catch (error) {
                console.error('Error en updateChartsColors:', error);
            }
        }
    </script>
</body>
</html>
