<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Anal√≠tico Universal de Datos</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .card h2 {
            color: #3498db;
            font-size: 1.5rem;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .chart-container {
            height: 300px;
            position: relative;
            margin-bottom: 15px;
        }
        .chart-analysis {
            background-color: #f8f9fa;
            border-left: 3px solid #3498db;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 4px;
            font-size: 0.95rem;
        }
        .chart-analysis h4 {
            margin: 0 0 5px 0;
            color: #2c3e50;
        }
        .chart-analysis p {
            margin: 0;
            line-height: 1.5;
        }
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            flex: 1;
            min-width: 120px;
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease;
        }
        .stat-box:hover {
            transform: translateY(-3px);
        }
        .stat-box h3 {
            margin: 0;
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        .stat-box p {
            margin: 10px 0 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }
        .risk-high {
            border-left-color: #e74c3c;
        }
        .risk-medium {
            border-left-color: #f39c12;
        }
        .risk-none {
            border-left-color: #2ecc71;
        }
        .filters {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 150px;
        }
        .filter-group label {
            font-size: 0.9rem;
            color: #7f8c8d;
            font-weight: 600;
        }
        .filters input[type="file"], .filters input[type="text"] {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            flex: 1;
            min-width: 250px;
        }
        .filters select {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            width: 100%;
        }
        .data-source-tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .data-source-tab {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            background-color: #f8f9fa;
            margin-right: 5px;
            font-weight: 600;
        }
        .data-source-tab.active {
            background-color: white;
            border-bottom: 2px solid #3498db;
        }
        .data-source-content {
            display: none;
            margin-bottom: 10px;
        }
        .data-source-content.active {
            display: block;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        .btn-success {
            background-color: #2ecc71;
            color: white;
        }
        .btn-warning {
            background-color: #f39c12;
            color: white;
        }
        .btn-info {
            background-color: #16a085;
            color: white;
        }
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
        }
        .loader {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .loader div {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #3498db;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .alert-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .filter-badge {
            display: inline-block;
            padding: 5px 10px;
            background-color: #e9f7fd;
            color: #3498db;
            border-radius: 20px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .applied-filters {
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
            display: none;
        }
        .dynamic-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .conclusions-section {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .conclusions-section h2 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .conclusion-card {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .conclusion-card h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .recommendation-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #2ecc71;
        }
        .recommendation-icon {
            background-color: #2ecc71;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            flex-shrink: 0;
        }
        .recommendation-content h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .recommendation-content p {
            margin: 0;
            color: #7f8c8d;
        }
        .priority-high .recommendation-icon {
            background-color: #e74c3c;
        }
        .priority-medium .recommendation-icon {
            background-color: #f39c12;
        }
        .header-custom {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
        }
        .report-title-input {
            width: 100%;
            padding: 10px;
            font-size: 1.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .report-subtitle-input {
            width: 100%;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        /* Estilos para secci√≥n de an√°lisis predictivo */
        .predictive-section {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .correlation-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        .correlation-strong {
            background-color: #d4edda;
            color: #155724;
        }
        .correlation-moderate {
            background-color: #fff3cd;
            color: #856404;
        }
        .correlation-weak {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        .forecast-point {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
            background-color: #e9f7fd;
            color: #0c5460;
            border-left: 4px solid #3498db;
        }
        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .segment-card {
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            margin-bottom: 15px;
        }
        .segment-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .metric-item {
            background-color: #fff;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .metric-item h5 {
            margin: 0;
            font-size: 0.8rem;
            color: #7f8c8d;
        }
        .metric-item p {
            margin: 5px 0 0;
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        /* Estilos para selectores de campo */
        .field-selector-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .field-selector {
            flex: 1;
            min-width: 200px;
        }
        .print-options {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .print-options h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .print-checkbox {
            margin-right: 20px;
        }
        /* Estilos espec√≠ficos para impresi√≥n */
        @page {
            size: A4;
            margin: 1.5cm;
        }
        @media print {
            body {
                background-color: white;
                padding: 0;
                margin: 0;
                font-size: 11pt;
            }
            .container {
                max-width: 100%;
                width: 100%;
                margin: 0;
                padding: 0;
            }
            .card {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
                page-break-inside: avoid;
                margin-bottom: 15mm;
                width: 100%;
            }
            .filters, .no-print, .btn-group, #loader, .alert, .data-source-tabs {
                display: none !important;
            }
            .header-custom {
                display: block !important;
                box-shadow: none;
                padding: 0;
                margin-bottom: 20mm;
                text-align: center;
            }
            .dashboard {
                display: block;
            }
            .full-width {
                width: 100%;
            }
            .chart-container {
                height: 130mm;
                max-height: 130mm;
                width: 100%;
                page-break-inside: avoid;
            }
            header {
                margin-bottom: 15mm;
                page-break-after: avoid;
            }
            h1, h2 {
                page-break-after: avoid;
            }
            table {
                font-size: 9pt;
                page-break-inside: avoid;
                width: 100%;
            }
            th, td {
                padding: 5px 8px;
            }
            .chart-analysis, .conclusion-card, .recommendation-item {
                border: 1px solid #ddd;
                border-left-width: 4px;
                page-break-inside: avoid;
            }
            .conclusions-section {
                page-break-before: always;
                box-shadow: none;
                border: 1px solid #ddd;
            }
            .recommendation-item {
                page-break-inside: avoid;
            }
            .applied-filters {
                margin-bottom: 10mm;
                background-color: transparent;
                border: 1px solid #ddd;
                padding: 5mm;
            }
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            .card:first-of-type {
                page-break-after: avoid;
            }
            .stat-box {
                break-inside: avoid;
            }
            .stats-container {
                page-break-inside: avoid;
            }
            /* Ajuste espec√≠fico para tablas de datos */
            .data-table {
                font-size: 8pt;
            }
            .data-table th, .data-table td {
                padding: 3px 4px;
            }
            /* Asegurar que los an√°lisis se impriman completos */
            p {
                orphans: 3;
                widows: 3;
            }
            /* Ocultar elementos que no son necesarios para la impresi√≥n */
            .print-hide {
                display: none !important;
            }
            /* Mostrar elementos espec√≠ficos para impresi√≥n */
            .print-show {
                display: block !important;
            }
            /* Ocultar selectores de campo en la impresi√≥n */
            .field-selector-container, .print-options {
                display: none !important;
            }
            /* Agregar fecha y n√∫mero de p√°gina */
            @bottom-right {
                content: "P√°gina " counter(page) " de " counter(pages);
            }
            @bottom-left {
                content: "Generado el " attr(data-print-date);
            }
        }
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .stat-box {
                min-width: 100px;
            }
            .filters {
                flex-direction: column;
                align-items: stretch;
            }
            .btn-group {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }
        }
        .print-header, .print-footer {
            display: none;
        }
        @media print {
            .print-header, .print-footer {
                display: block;
                text-align: center;
            }
            .print-footer {
                position: fixed;
                bottom: 0;
                width: 100%;
                font-size: 9pt;
                color: #777;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dashboard Anal√≠tico Universal de Datos</h1>
            <p id="dashboard-description">An√°lisis avanzado de datos con identificaci√≥n autom√°tica de patrones, predicci√≥n y generaci√≥n de informes personalizados</p>
        </header>
        
        <div class="filters">
            <div class="data-source-tabs">
                <div class="data-source-tab active" data-tab="file-tab">Archivo Excel</div>
                <div class="data-source-tab" data-tab="sheets-tab">Google Sheets</div>
                <div class="data-source-tab" data-tab="config-tab">Configurar Informe</div>
            </div>
            
            <div class="data-source-content active" id="file-tab">
                <div class="filter-group">
                    <label for="excel-file">Cargar archivo Excel</label>
                    <input type="file" id="excel-file" accept=".xlsx, .xls, .csv" />
                </div>
            </div>
            
            <div class="data-source-content" id="sheets-tab">
                <div class="filter-group">
                    <label for="sheets-url">URL de Google Sheets (p√∫blico o compartido)</label>
                    <input type="text" id="sheets-url" placeholder="Ej: https://docs.google.com/spreadsheets/d/..." />
                </div>
                <div class="filter-group">
                    <label for="sheets-tab-name">Nombre de la hoja (opcional)</label>
                    <input type="text" id="sheets-tab-name" placeholder="Hoja1" />
                </div>
            </div>
            
            <div class="data-source-content" id="config-tab">
                <div class="filter-group">
                    <label for="report-title">T√≠tulo del informe</label>
                    <input type="text" id="report-title" placeholder="Informe de an√°lisis de datos" value="Informe de an√°lisis de datos" />
                </div>
                <div class="filter-group">
                    <label for="report-subtitle">Subt√≠tulo</label>
                    <input type="text" id="report-subtitle" placeholder="An√°lisis detallado y recomendaciones" value="An√°lisis detallado y recomendaciones" />
                </div>
                <div class="filter-group">
                    <label for="report-color">Color principal</label>
                    <input type="color" id="report-color" value="#3498db" />
                </div>
            </div>
            
            <div class="btn-group">
                <button id="process-button" class="btn btn-primary">Procesar Datos</button>
                <button id="filter-button" class="btn btn-warning">Filtrar Datos</button>
                <button id="print-report" class="btn btn-success">Imprimir Informe</button>
            </div>
        </div>
        
        <div id="applied-filters" class="applied-filters">
            <h3>Filtros aplicados:</h3>
            <div id="filter-badges"></div>
            <div id="dynamic-filters" class="dynamic-filters"></div>
        </div>
        
        <div id="success-alert" class="alert alert-success">
            Datos procesados correctamente. El dashboard ha sido actualizado.
        </div>
        
        <div id="error-alert" class="alert alert-danger">
            Error al procesar el archivo. Aseg√∫rese de que sea un archivo v√°lido con la estructura correcta.
        </div>
        
        <div id="info-alert" class="alert alert-info">
            Seleccione los campos adecuados para realizar el an√°lisis completo.
        </div>
        
        <div id="loader" class="loader">
            <div></div>
            <span>Procesando datos...</span>
        </div>
        
        <!-- Cabecera personalizada para impresi√≥n -->
        <div id="header-custom" class="header-custom print-show">
            <h1 id="print-title">Informe de an√°lisis de datos</h1>
            <p id="print-subtitle">An√°lisis detallado y recomendaciones</p>
            <p id="print-date">Fecha: <span id="current-date"></span></p>
        </div>
        
        <div id="dashboard-content">
            <!-- El contenido del dashboard se generar√° din√°micamente basado en los datos cargados -->
            <section class="dashboard" id="dashboard-container">
                <div class="card full-width">
                    <h2>Bienvenido al Dashboard Anal√≠tico</h2>
                    <p>Para comenzar, siga estos pasos:</p>
                    <ol>
                        <li>Cargue un archivo Excel o proporcione una URL de Google Sheets</li>
                        <li>Haga clic en "Procesar Datos" para generar el an√°lisis autom√°tico</li>
                        <li>Utilice las opciones de filtrado para explorar segmentos espec√≠ficos de datos</li>
                        <li>Imprima el informe completo para compartirlo</li>
                    </ol>
                    <p>El sistema detectar√° autom√°ticamente patrones, tendencias y relaciones en sus datos, generando visualizaciones, an√°lisis estad√≠stico avanzado y pron√≥sticos predictivos.</p>
                </div>
            </section>
            
            <section class="conclusions-section" id="conclusions-section">
                <h2>Diagn√≥stico Integral y Recomendaciones Estrat√©gicas</h2>
                
                <div class="conclusion-card">
                    <h3>Diagn√≥stico General</h3>
                    <p id="general-conclusion">Cargue sus datos para generar un an√°lisis autom√°tico y recomendaciones personalizadas.</p>
                </div>
                
                <h3>Recomendaciones Estrat√©gicas Basadas en Evidencia</h3>
                
                <div id="recommendations-container">
                    <!-- Las recomendaciones se generar√°n din√°micamente -->
                    <div class="recommendation-item">
                        <div class="recommendation-icon">i</div>
                        <div class="recommendation-content">
                            <h4>No hay recomendaciones disponibles</h4>
                            <p>Cargue sus datos para recibir recomendaciones personalizadas basadas en el an√°lisis.</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
        
        <!-- Pie de p√°gina para impresi√≥n -->
        <div class="print-footer">
            <p>Generado autom√°ticamente - P√°gina <span class="page-number"></span></p>
        </div>
    </div>

    <!-- Scripts necesarios -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        // Objeto para almacenar las instancias de gr√°ficos
        const charts = {};
        
        // Almacenar los datos sin filtrar
        let originalData = null;
        
        // Configuraci√≥n de estilos
        const reportStyles = {
            primaryColor: '#3498db',
            secondaryColor: '#2ecc71',
            accentColor: '#e74c3c',
            neutralColor: '#f39c12'
        };
        
        // Configuraci√≥n de impresi√≥n
        const printOptions = {
            includeDataTable: true,
            includePredictions: true,
            includeCorrelations: true,
            includeSegments: true,
            includeRecommendations: true
        };
        
        // Datos globales
        let globalData = {
            totalRecords: 0,
            fields: {},
            categories: {},
            numerics: {},
            dates: {},
            appliedFilters: {},
            rawData: [],
            selectedFields: {} // Para almacenar los campos seleccionados por el usuario
        };
        
        // Funci√≥n para inicializar la interfaz
        document.addEventListener('DOMContentLoaded', function() {
            // Verificar si Chart.js est√° disponible
            if (typeof Chart === 'undefined') {
                console.error('Chart.js no est√° cargado. No se pueden crear gr√°ficos.');
                showAlert('error-alert', 'Error: La biblioteca Chart.js no est√° disponible. Verifique su conexi√≥n a internet y recargue la p√°gina.');
                return;
            }
            
            console.log('Chart.js est√° disponible, versi√≥n:', Chart.version);
            
            // Establecer la fecha actual para el informe
            const now = new Date();
            document.getElementById('current-date').textContent = now.toLocaleDateString();
            document.body.setAttribute('data-print-date', now.toLocaleDateString());
            
            // Eventos para las pesta√±as de fuente de datos
            document.querySelectorAll('.data-source-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.data-source-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.data-source-content').forEach(c => c.classList.remove('active'));
                    
                    this.classList.add('active');
                    document.getElementById(this.getAttribute('data-tab')).classList.add('active');
                });
            });
            
            // Evento para procesar datos
            document.getElementById('process-button').addEventListener('click', function() {
                const fileInput = document.getElementById('excel-file');
                const sheetsUrl = document.getElementById('sheets-url');
                
                if (fileInput.files.length > 0) {
                    processExcelFile(fileInput.files[0]);
                } else if (sheetsUrl.value.trim() !== '') {
                    processGoogleSheets(sheetsUrl.value, document.getElementById('sheets-tab-name').value);
                } else {
                    showAlert('error-alert', 'Por favor, seleccione un archivo Excel o proporcione una URL de Google Sheets v√°lida.');
                }
            });
            
            // Evento para abrir panel de filtros
            document.getElementById('filter-button').addEventListener('click', function() {
                if (!globalData.rawData || globalData.rawData.length === 0) {
                    showAlert('info-alert', 'Primero debe cargar y procesar datos para poder filtrarlos.');
                    return;
                }
                
                toggleFilterPanel();
            });
            
            // Evento para imprimir informe
            document.getElementById('print-report').addEventListener('click', printReport);
            
            // Evento para cambio de t√≠tulo y subt√≠tulo del informe
            document.getElementById('report-title').addEventListener('input', function() {
                document.getElementById('print-title').textContent = this.value;
            });
            
            document.getElementById('report-subtitle').addEventListener('input', function() {
                document.getElementById('print-subtitle').textContent = this.value;
            });
            
            // Evento para cambio de color principal
            document.getElementById('report-color').addEventListener('change', function() {
                reportStyles.primaryColor = this.value;
                updateChartsColors();
            });
        });
        
        // Funci√≥n para mostrar alertas
        function showAlert(alertId, message, duration = 3000) {
            const alert = document.getElementById(alertId);
            alert.textContent = message;
            alert.style.display = 'block';
            
            setTimeout(() => {
                alert.style.display = 'none';
            }, duration);
        }
        
        // Funci√≥n para procesar archivo Excel
        function processExcelFile(file) {
            document.getElementById('loader').style.display = 'block';
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    console.log('Archivo Excel cargado correctamente.');
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    console.log(`Datos extra√≠dos: ${jsonData.length} registros`);
                    
                    // Procesar los datos
                    processData(jsonData);
                    
                    // Guardar los datos originales para aplicar filtros despu√©s
                    originalData = JSON.parse(JSON.stringify(globalData));
                    
                    // Generar visualizaciones y an√°lisis
                    generateDashboard();
                    
                    // Mostrar mensaje de √©xito
                    showAlert('success-alert', 'Datos procesados correctamente. El dashboard ha sido actualizado.');
                } catch (error) {
                    console.error('Error al procesar el archivo:', error);
                    showAlert('error-alert', 'Error al procesar el archivo: ' + error.message);
                } finally {
                    document.getElementById('loader').style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error al leer el archivo.');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Funci√≥n para procesar datos de Google Sheets
        function processGoogleSheets(url, tabName) {
            document.getElementById('loader').style.display = 'block';
            
            try {
                // Convertir URL de Google Sheets a CSV
                const csvUrl = convertSheetsToCsvUrl(url, tabName);
                
                // Informar al usuario sobre posibles problemas de CORS
                showAlert('info-alert', 'Intentando acceder a Google Sheets. Si hay problemas de CORS, considere descargar y usar el archivo localmente.', 5000);
                
                // Usar un proxy CORS p√∫blico o sugerir una soluci√≥n alternativa
                const proxyUrl = `https://cors-anywhere.herokuapp.com/${csvUrl}`;
                
                fetch(proxyUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('No se pudo acceder a la hoja. Aseg√∫rese de que sea p√∫blica o est√© compartida correctamente.');
                        }
                        return response.text();
                    })
                    .then(csvData => {
                        // Convertir CSV a JSON
                        const jsonData = parseCsvToJson(csvData);
                        
                        console.log(`Datos de Google Sheets extra√≠dos: ${jsonData.length} registros`);
                        
                        // Procesar los datos
                        processData(jsonData);
                        
                        // Guardar los datos originales para aplicar filtros despu√©s
                        originalData = JSON.parse(JSON.stringify(globalData));
                        
                        // Generar visualizaciones y an√°lisis
                        generateDashboard();
                        
                        // Mostrar mensaje de √©xito
                        showAlert('success-alert', 'Datos procesados correctamente. El dashboard ha sido actualizado.');
                    })
                    .catch(error => {
                        console.error('Error al procesar Google Sheets:', error);
                        showAlert('error-alert', 'Error al acceder a Google Sheets: ' + error.message + 
                                '. Para evitar problemas de CORS, descargue la hoja como Excel y c√°rguela directamente.');
                    })
                    .finally(() => {
                        document.getElementById('loader').style.display = 'none';
                    });
            } catch (error) {
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error: ' + error.message);
            }
        }
        
        // Funci√≥n para convertir URL de Google Sheets a URL de CSV
        function convertSheetsToCsvUrl(url, tabName) {
            // Extraer el ID de la hoja de la URL
            let sheetId = '';
            const regex = /\/d\/([a-zA-Z0-9-_]+)/;
            const match = url.match(regex);
            
            if (match && match[1]) {
                sheetId = match[1];
            } else {
                throw new Error('URL de Google Sheets no v√°lida.');
            }
            
            // Construir la URL de exportaci√≥n CSV
            let csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
            
            // Agregar nombre de la pesta√±a si se proporciona
            if (tabName && tabName.trim() !== '') {
                csvUrl += `&gid=0&sheet=${encodeURIComponent(tabName.trim())}`;
            }
            
            return csvUrl;
        }
        
        // Funci√≥n para parsear CSV a JSON
        function parseCsvToJson(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(header => header.trim().replace(/^"|"$/g, ''));
            
            const jsonData = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                const obj = {};
                
                headers.forEach((header, index) => {
                    if (index < values.length) {
                        obj[header] = values[index];
                    } else {
                        obj[header] = '';
                    }
                });
                
                jsonData.push(obj);
            }
            
            return jsonData;
        }
        
        // Funci√≥n para parsear una l√≠nea CSV respetando comillas
        function parseCSVLine(line) {
            const result = [];
            let insideQuotes = false;
            let currentValue = '';
            
            for (let i = 0; i < line.length; i++) {
                if (line[i] === '"') {
                    insideQuotes = !insideQuotes;
                } else if (line[i] === ',' && !insideQuotes) {
                    result.push(currentValue.replace(/^"|"$/g, ''));
                    currentValue = '';
                } else {
                    currentValue += line[i];
                }
            }
            
            // Agregar el √∫ltimo valor
            result.push(currentValue.replace(/^"|"$/g, ''));
            
            return result;
        }
        
        // Funci√≥n para procesar los datos
        function processData(jsonData) {
            try {
                console.log(`Procesando datos con ${jsonData.length} registros`);
                
                // Resetear datos globales
                globalData = {
                    totalRecords: jsonData.length,
                    fields: {},
                    categories: {},
                    numerics: {},
                    dates: {},
                    appliedFilters: {},
                    rawData: jsonData,
                    selectedFields: {}
                };
                
                // Si no hay datos, salir
                if (jsonData.length === 0) {
                    console.warn('No hay datos para procesar');
                    return;
                }
                
                // Obtener todas las claves de los datos
                const fieldNames = Object.keys(jsonData[0]);
                console.log(`Se encontraron ${fieldNames.length} campos:`, fieldNames);
                
                // Analizar cada campo para detectar su tipo
                fieldNames.forEach(field => {
                    try {
                        globalData.fields[field] = analyzeField(jsonData, field);
                        console.log(`Campo ${field} analizado como ${globalData.fields[field].type}`);
                    } catch (fieldError) {
                        console.error(`Error al analizar el campo ${field}:`, fieldError);
                        // Proporcionar informaci√≥n predeterminada en caso de error
                        globalData.fields[field] = {
                            name: field,
                            type: 'unknown',
                            uniqueValues: [],
                            distribution: {},
                            stats: {}
                        };
                    }
                });
                
                // Clasificar campos por tipo
                fieldNames.forEach(field => {
                    const fieldInfo = globalData.fields[field];
                    
                    if (fieldInfo.type === 'date') {
                        globalData.dates[field] = fieldInfo;
                    } else if (fieldInfo.type === 'numeric') {
                        globalData.numerics[field] = fieldInfo;
                    } else if (fieldInfo.type === 'categorical') {
                        globalData.categories[field] = fieldInfo;
                    }
                });
                
                console.log(`Clasificaci√≥n de campos: ${Object.keys(globalData.categories).length} categ√≥ricos, ${Object.keys(globalData.numerics).length} num√©ricos, ${Object.keys(globalData.dates).length} fechas`);
                
                // Inicializar los campos seleccionados
                initializeSelectedFields();
                
                console.log('Procesamiento de datos completado');
            } catch (error) {
                console.error('Error en processData:', error);
                showAlert('error-alert', 'Error al procesar los datos: ' + error.message);
            }
        }
        
        // Funci√≥n para inicializar los campos seleccionados
        function initializeSelectedFields() {
            // Inicializar con los primeros campos disponibles
            globalData.selectedFields = {
                categories: [],
                numerics: []
            };
            
            // Seleccionar el primer campo categ√≥rico disponible
            const categoryFields = Object.keys(globalData.categories);
            if (categoryFields.length > 0) {
                globalData.selectedFields.categories.push(categoryFields[0]);
            }
            
            // Seleccionar los primeros 3 campos num√©ricos disponibles
            const numericFields = Object.keys(globalData.numerics);
            for (let i = 0; i < Math.min(numericFields.length, 3); i++) {
                globalData.selectedFields.numerics.push(numericFields[i]);
            }
        }
        
        // Funci√≥n para analizar un campo y determinar su tipo y estad√≠sticas
        function analyzeField(data, fieldName) {
            try {
                console.log(`Analizando campo: ${fieldName}`);
                
                const fieldInfo = {
                    name: fieldName,
                    type: 'unknown',
                    uniqueValues: new Set(),
                    distribution: {},
                    stats: {}
                };
                
                // Recopilar valores y contarlos
                const values = [];
                let validCount = 0;
                let missingCount = 0;
                
                data.forEach(record => {
                    const value = record[fieldName];
                    
                    if (value !== undefined && value !== null && value !== '') {
                        fieldInfo.uniqueValues.add(value);
                        
                        if (!fieldInfo.distribution[value]) {
                            fieldInfo.distribution[value] = 0;
                        }
                        fieldInfo.distribution[value]++;
                        validCount++;
                        
                        // Intentar convertir a n√∫mero
                        const numValue = Number(value);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    } else {
                        missingCount++;
                    }
                });
                
                console.log(`Campo ${fieldName}: ${validCount} valores v√°lidos, ${missingCount} valores faltantes, ${fieldInfo.uniqueValues.size} valores √∫nicos`);
                
                // Determinar tipo de campo
                if (isDateField(data, fieldName)) {
                    fieldInfo.type = 'date';
                    console.log(`Campo ${fieldName} identificado como campo de fecha`);
                } else if (values.length > 0 && values.length >= validCount * 0.8) {
                    fieldInfo.type = 'numeric';
                    console.log(`Campo ${fieldName} identificado como campo num√©rico`);
                    
                    // Calcular estad√≠sticas para campo num√©rico
                    fieldInfo.stats = calculateNumericStats(values);
                } else if (fieldInfo.uniqueValues.size <= Math.min(20, data.length * 0.2)) {
                    fieldInfo.type = 'categorical';
                    console.log(`Campo ${fieldName} identificado como campo categ√≥rico con ${fieldInfo.uniqueValues.size} categor√≠as`);
                    
                    // Calcular estad√≠sticas para campo categ√≥rico
                    fieldInfo.stats = calculateCategoricalStats(fieldInfo.distribution, data.length);
                } else {
                    fieldInfo.type = 'text';
                    console.log(`Campo ${fieldName} identificado como campo de texto`);
                    
                    // Calcular estad√≠sticas b√°sicas para campo de texto
                    fieldInfo.stats = calculateTextStats(fieldInfo.distribution, data.length, validCount, missingCount);
                }
                
                // Convertir Set a Array para facilitar serializaci√≥n
                fieldInfo.uniqueValues = Array.from(fieldInfo.uniqueValues);
                
                return fieldInfo;
            } catch (error) {
                console.error(`Error al analizar campo ${fieldName}:`, error);
                return {
                    name: fieldName,
                    type: 'unknown',
                    uniqueValues: [],
                    distribution: {},
                    stats: {}
                };
            }
        }
        
        // Funci√≥n para verificar si un campo parece ser fecha
        function isDateField(data, fieldName) {
            // Verificar los primeros 20 registros (o menos)
            const sampleSize = Math.min(20, data.length);
            let dateCount = 0;
            
            for (let i = 0; i < sampleSize; i++) {
                if (i < data.length) {
                    const value = data[i][fieldName];
                    if (value) {
                        const date = new Date(value);
                        if (!isNaN(date.getTime())) {
                            dateCount++;
                        }
                    }
                }
            }
            
            // Si m√°s del 80% de los valores de la muestra son fechas v√°lidas
            return dateCount >= sampleSize * 0.8;
        }
        
        // Funci√≥n para calcular estad√≠sticas de campo categ√≥rico
        function calculateCategoricalStats(distribution, totalCount) {
            try {
                const valueCount = Object.keys(distribution).length;
                const values = Object.values(distribution);
                
                if (values.length === 0) {
                    return {
                        count: 0,
                        unique: 0,
                        mostFrequent: null,
                        mostFrequentCount: 0,
                        mostFrequentPercentage: 0
                    };
                }
                
                // Encontrar el valor m√°s frecuente
                let maxValue = '';
                let maxCount = 0;
                
                Object.entries(distribution).forEach(([value, count]) => {
                    if (count > maxCount) {
                        maxValue = value;
                        maxCount = count;
                    }
                });
                
                return {
                    count: values.reduce((a, b) => a + b, 0),
                    unique: valueCount,
                    mostFrequent: maxValue,
                    mostFrequentCount: maxCount,
                    mostFrequentPercentage: (maxCount / totalCount) * 100
                };
            } catch (error) {
                console.error('Error en calculateCategoricalStats:', error);
                return {
                    count: 0,
                    unique: 0,
                    mostFrequent: null,
                    mostFrequentCount: 0,
                    mostFrequentPercentage: 0
                };
            }
        }
        
        // Funci√≥n para calcular estad√≠sticas b√°sicas de campo de texto
        function calculateTextStats(distribution, totalCount, validCount, missingCount) {
            return {
                count: validCount,
                unique: Object.keys(distribution).length,
                missing: missingCount,
                missingPercentage: (missingCount / totalCount) * 100
            };
        }
        
        // Funci√≥n mejorada para calcular estad√≠sticas de un campo num√©rico
        function calculateNumericStats(values) {
            try {
                if (values.length === 0) {
                    return {
                        min: 0,
                        max: 0,
                        mean: 0,
                        median: 0,
                        sum: 0,
                        std: 0,
                        count: 0,
                        q1: 0,
                        q3: 0,
                        iqr: 0,
                        skewness: 0,
                        kurtosis: 0,
                        outliers: []
                    };
                }
                
                // Ordenar valores para c√°lculos estad√≠sticos
                const sortedValues = [...values].sort((a, b) => a - b);
                
                const min = sortedValues[0];
                const max = sortedValues[sortedValues.length - 1];
                const sum = sortedValues.reduce((acc, val) => acc + val, 0);
                const mean = sum / sortedValues.length;
                
                // Calcular mediana
                const mid = Math.floor(sortedValues.length / 2);
                const median = sortedValues.length % 2 === 0
                    ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
                    : sortedValues[mid];
                
                // Calcular cuartiles
                const q1Index = Math.floor(sortedValues.length * 0.25);
                const q3Index = Math.floor(sortedValues.length * 0.75);
                const q1 = sortedValues[q1Index];
                const q3 = sortedValues[q3Index];
                const iqr = q3 - q1;
                
                // Calcular desviaci√≥n est√°ndar
                const squaredDiffs = sortedValues.map(val => Math.pow(val - mean, 2));
                const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / sortedValues.length;
                const std = Math.sqrt(variance);
                
                // Calcular asimetr√≠a (skewness)
                const cubeSum = values.reduce((acc, val) => acc + Math.pow(val - mean, 3), 0);
                const skewness = cubeSum / (values.length * Math.pow(std, 3)) || 0;
                
                // Calcular curtosis
                const fourthPowerSum = values.reduce((acc, val) => acc + Math.pow(val - mean, 4), 0);
                const kurtosis = fourthPowerSum / (values.length * Math.pow(variance, 2)) - 3 || 0;
                
                // Detectar outliers usando el m√©todo IQR
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;
                const outliers = values.filter(val => val < lowerBound || val > upperBound);
                
                return {
                    min,
                    max,
                    mean,
                    median,
                    sum,
                    std,
                    count: values.length,
                    q1,
                    q3,
                    iqr,
                    skewness,
                    kurtosis,
                    outliers,
                    lowerBound,
                    upperBound
                };
            } catch (error) {
                console.error('Error en calculateNumericStats:', error);
                return {
                    min: 0,
                    max: 0,
                    mean: 0,
                    median: 0,
                    sum: 0,
                    std: 0,
                    count: 0,
                    q1: 0,
                    q3: 0,
                    iqr: 0,
                    skewness: 0,
                    kurtosis: 0,
                    outliers: []
                };
            }
        }
        
        // Funci√≥n para calcular la correlaci√≥n entre dos variables num√©ricas
        function calculateCorrelation(data, field1, field2) {
            // Extraer pares de valores v√°lidos
            const pairs = [];
            
            data.forEach(record => {
                const val1 = Number(record[field1]);
                const val2 = Number(record[field2]);
                
                if (!isNaN(val1) && !isNaN(val2)) {
                    pairs.push([val1, val2]);
                }
            });
            
            if (pairs.length < 2) return { correlation: 0, pairs: [], strength: 'insuficientes datos' };
            
            // Calcular medias
            const mean1 = pairs.reduce((sum, pair) => sum + pair[0], 0) / pairs.length;
            const mean2 = pairs.reduce((sum, pair) => sum + pair[1], 0) / pairs.length;
            
            // Calcular componentes de correlaci√≥n
            let numerator = 0;
            let denom1 = 0;
            let denom2 = 0;
            
            pairs.forEach(pair => {
                const diff1 = pair[0] - mean1;
                const diff2 = pair[1] - mean2;
                
                numerator += diff1 * diff2;
                denom1 += diff1 * diff1;
                denom2 += diff2 * diff2;
            });
            
            // Calcular coeficiente de correlaci√≥n de Pearson
            const correlation = (denom1 > 0 && denom2 > 0) 
                ? numerator / Math.sqrt(denom1 * denom2)
                : 0;
            
            // Determinar la fuerza de la correlaci√≥n
            let strength = 'nula';
            const absCorr = Math.abs(correlation);
            
            if (absCorr >= 0.9) strength = 'muy fuerte';
            else if (absCorr >= 0.7) strength = 'fuerte';
            else if (absCorr >= 0.5) strength = 'moderada';
            else if (absCorr >= 0.3) strength = 'd√©bil';
            else if (absCorr >= 0.1) strength = 'muy d√©bil';
            
            // Determinar la direcci√≥n
            const direction = correlation > 0 ? 'positiva' : correlation < 0 ? 'negativa' : 'nula';
            
            return {
                correlation,
                pairs: pairs.length,
                strength,
                direction
            };
        }
        
        // Funci√≥n para realizar an√°lisis de tendencias y predicci√≥n
        function analyzeTrendAndPredict(periods, values, numPredictions = 3) {
            if (periods.length < 4) {
                return {
                    trend: 'insuficientes datos',
                    prediction: [],
                    confidence: 'baja',
                    equation: ''
                };
            }
            
            // Crear √≠ndices num√©ricos para los per√≠odos
            const indices = Array.from({length: periods.length}, (_, i) => i);
            
            // Calcular la l√≠nea de tendencia (regresi√≥n lineal)
            const n = indices.length;
            const sumX = indices.reduce((a, b) => a + b, 0);
            const sumY = values.reduce((a, b) => a + b, 0);
            const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
            const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);
            
            // Calcular pendiente e intercepto
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Funci√≥n para calcular valores de tendencia
            const trendLine = x => slope * x + intercept;
            
            // Calcular valores de tendencia para los puntos existentes
            const trendValues = indices.map(trendLine);
            
            // Calcular R-cuadrado (coeficiente de determinaci√≥n)
            const meanY = sumY / n;
            const totalVariation = values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
            const residualVariation = values.reduce((sum, y, i) => sum + Math.pow(y - trendValues[i], 2), 0);
            const rSquared = 1 - (residualVariation / totalVariation);
            
            // Determinar la fuerza y direcci√≥n de la tendencia
            let trendStrength = 'indeterminada';
            if (rSquared > 0.7) trendStrength = 'fuerte';
            else if (rSquared > 0.4) trendStrength = 'moderada';
            else if (rSquared > 0.2) trendStrength = 'd√©bil';
            else trendStrength = 'no significativa';
            
            const trendDirection = slope > 0 ? 'creciente' : slope < 0 ? 'decreciente' : 'estable';
            
            // Realizar predicciones para futuros per√≠odos
            const predictions = [];
            for (let i = 0; i < numPredictions; i++) {
                const nextIndex = indices.length + i;
                const predictedValue = trendLine(nextIndex);
                predictions.push({
                    index: nextIndex,
                    value: predictedValue
                });
            }
            
            // Calcular el nivel de confianza basado en R-cuadrado
            let confidence = 'baja';
            if (rSquared > 0.8) confidence = 'alta';
            else if (rSquared > 0.5) confidence = 'media';
            
            // Crear ecuaci√≥n de la l√≠nea de tendencia
            const equation = `y = ${slope.toFixed(4)}x + ${intercept.toFixed(2)}`;
            
            return {
                trend: `${trendDirection} (${trendStrength})`,
                prediction: predictions,
                slope,
                intercept,
                rSquared,
                confidence,
                equation,
                trendValues
            };
        }
        
        // Funci√≥n para an√°lisis avanzado de series temporales
        function analyzeTimeSeries(periods, values) {
            if (periods.length < 6) {
                return {
                    trend: 'insuficientes datos',
                    seasonality: 'indeterminada',
                    cyclical: 'indeterminada',
                    forecast: []
                };
            }
            
            // Calcular tendencia usando regresi√≥n lineal
            const trendAnalysis = analyzeTrendAndPredict(periods, values, 3);
            
            // Eliminar la tendencia para buscar estacionalidad
            const detrended = values.map((value, i) => value - trendAnalysis.trendValues[i]);
            
            // An√°lisis simple de estacionalidad
            let hasSeasonality = false;
            let seasonalityStrength = 'no detectada';
            let seasonalityPeriod = 0;
            
            // Verificar patrones estacionales para diferentes per√≠odos
            const potentialPeriods = [3, 4, 6, 12]; // trimestral, cuatrimestral, semestral, anual
            
            // Verificar autocorrelaci√≥n para diferentes lags
            for (const period of potentialPeriods) {
                if (periods.length < period * 2) continue;
                
                let autocorrelation = 0;
                let count = 0;
                
                for (let i = 0; i < detrended.length - period; i++) {
                    autocorrelation += detrended[i] * detrended[i + period];
                    count++;
                }
                
                if (count > 0) {
                    autocorrelation /= count;
                    
                    // Normalizar la autocorrelaci√≥n
                    const variance = detrended.reduce((sum, val) => sum + val * val, 0) / detrended.length;
                    const normalizedAutocorr = variance > 0 ? autocorrelation / variance : 0;
                    
                    if (Math.abs(normalizedAutocorr) > 0.3) {
                        hasSeasonality = true;
                        seasonalityPeriod = period;
                        
                        if (Math.abs(normalizedAutocorr) > 0.7) seasonalityStrength = 'fuerte';
                        else if (Math.abs(normalizedAutocorr) > 0.5) seasonalityStrength = 'moderada';
                        else seasonalityStrength = 'd√©bil';
                        
                        break;
                    }
                }
            }
            
            // Calcular componentes estacionales si se detecta estacionalidad
            let seasonalComponents = [];
            if (hasSeasonality && seasonalityPeriod > 0) {
                const seasonalAvgs = Array(seasonalityPeriod).fill(0);
                const seasonalCounts = Array(seasonalityPeriod).fill(0);
                
                // Calcular promedios estacionales
                for (let i = 0; i < detrended.length; i++) {
                    const seasonIndex = i % seasonalityPeriod;
                    seasonalAvgs[seasonIndex] += detrended[i];
                    seasonalCounts[seasonIndex]++;
                }
                
                for (let i = 0; i < seasonalityPeriod; i++) {
                    if (seasonalCounts[i] > 0) {
                        seasonalAvgs[i] /= seasonalCounts[i];
                    }
                }
                
                // Normalizar componentes estacionales para que sumen cero
                const avgSeasonal = seasonalAvgs.reduce((sum, val) => sum + val, 0) / seasonalityPeriod;
                seasonalComponents = seasonalAvgs.map(val => val - avgSeasonal);
            }
            
            // Generar pron√≥sticos combinando tendencia y estacionalidad
            const forecast = [];
            const numPredictions = 3;
            
            for (let i = 0; i < numPredictions; i++) {
                const nextIndex = periods.length + i;
                const trendPrediction = trendAnalysis.slope * nextIndex + trendAnalysis.intercept;
                
                let seasonalAdjustment = 0;
                if (hasSeasonality && seasonalityPeriod > 0) {
                    const seasonIndex = nextIndex % seasonalityPeriod;
                    seasonalAdjustment = seasonalComponents[seasonIndex] || 0;
                }
                
                forecast.push({
                    index: nextIndex,
                    value: trendPrediction + seasonalAdjustment
                });
            }
            
            return {
                trend: trendAnalysis.trend,
                equation: trendAnalysis.equation,
                rSquared: trendAnalysis.rSquared,
                seasonality: hasSeasonality ? `${seasonalityStrength} (periodo: ${seasonalityPeriod})` : 'no detectada',
                seasonalComponents,
                forecast,
                confidence: hasSeasonality && trendAnalysis.rSquared > 0.5 ? 'media-alta' : trendAnalysis.confidence
            };
        }
        
        // Funci√≥n para an√°lisis de cl√∫steres usando K-means simple
        function performClusterAnalysis(data, fields, k = 3, maxIterations = 100) {
            try {
                if (!data || data.length < k || !fields || fields.length === 0) {
                    return {
                        success: false,
                        message: 'Datos insuficientes para an√°lisis de cl√∫steres'
                    };
                }
                
                // Extraer y normalizar valores para los campos seleccionados
                const extractedData = [];
                const fieldStats = {};
                
                // Calcular estad√≠sticas para normalizaci√≥n
                fields.forEach(field => {
                    const values = data
                        .map(record => Number(record[field]))
                        .filter(val => !isNaN(val));
                    
                    if (values.length > 0) {
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const range = max - min > 0 ? max - min : 1; // Evitar divisi√≥n por cero
                        
                        fieldStats[field] = { min, max, range };
                    }
                });
                
                // Extraer y normalizar datos
                data.forEach(record => {
                    const point = {};
                    
                    let hasValidValue = false;
                    fields.forEach(field => {
                        const value = Number(record[field]);
                        
                        if (!isNaN(value) && fieldStats[field]) {
                            // Normalizar a escala [0,1]
                            const { min, range } = fieldStats[field];
                            point[field] = (value - min) / range;
                            hasValidValue = true;
                        } else {
                            point[field] = null;
                        }
                    });
                    
                    if (hasValidValue) {
                        extractedData.push({
                            original: record,
                            normalized: point
                        });
                    }
                });
                
                if (extractedData.length < k) {
                    return {
                        success: false,
                        message: 'Datos insuficientes despu√©s de filtrar valores no v√°lidos'
                    };
                }
                
                // Inicializar centroides de forma aleatoria
                let centroids = [];
                const selectedIndices = new Set();
                
                while (centroids.length < k) {
                    const randomIndex = Math.floor(Math.random() * extractedData.length);
                    
                    if (!selectedIndices.has(randomIndex) && Object.values(extractedData[randomIndex].normalized).every(val => val !== null)) {
                        selectedIndices.add(randomIndex);
                        centroids.push({...extractedData[randomIndex].normalized});
                    }
                }
                
                // Funci√≥n para calcular distancia euclidiana
                function calculateDistance(point1, point2) {
                    let sumSquaredDiff = 0;
                    let validDimensions = 0;
                    
                    fields.forEach(field => {
                        if (point1[field] !== null && point2[field] !== null) {
                            sumSquaredDiff += Math.pow(point1[field] - point2[field], 2);
                            validDimensions++;
                        }
                    });
                    
                    return validDimensions > 0 ? Math.sqrt(sumSquaredDiff / validDimensions) : Infinity;
                }
                
                // Realizar algoritmo K-means
                let clusters = Array(k).fill().map(() => []);
                let iteration = 0;
                let centroidsChanged = true;
                
                while (centroidsChanged && iteration < maxIterations) {
                    // Reiniciar clusters
                    clusters = Array(k).fill().map(() => []);
                    
                    // Asignar puntos a clusters
                    extractedData.forEach(dataPoint => {
                        let minDistance = Infinity;
                        let clusterIndex = 0;
                        
                        centroids.forEach((centroid, index) => {
                            const distance = calculateDistance(dataPoint.normalized, centroid);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                clusterIndex = index;
                            }
                        });
                        
                        clusters[clusterIndex].push(dataPoint);
                    });
                    
                    // Actualizar centroides
                    centroidsChanged = false;
                    
                    clusters.forEach((cluster, index) => {
                        if (cluster.length === 0) return;
                        
                        const newCentroid = {};
                        
                        fields.forEach(field => {
                            const validValues = cluster
                                .map(point => point.normalized[field])
                                .filter(val => val !== null);
                            
                            if (validValues.length > 0) {
                                newCentroid[field] = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
                            } else {
                                newCentroid[field] = centroids[index][field];
                            }
                        });
                        
                        // Verificar si el centroide cambi√≥ significativamente
                        const centroidDistance = calculateDistance(centroids[index], newCentroid);
                        if (centroidDistance > 0.001) {
                            centroidsChanged = true;
                        }
                        
                        centroids[index] = newCentroid;
                    });
                    
                    iteration++;
                }
                
                // Calcular m√©tricas para cada cluster
                const clusterMetrics = clusters.map((cluster, index) => {
                    // Calcular estad√≠sticas para cada campo en este cluster
                    const fieldMetrics = {};
                    
                    fields.forEach(field => {
                        const originalValues = cluster
                            .map(point => Number(point.original[field]))
                            .filter(val => !isNaN(val));
                        
                        if (originalValues.length > 0) {
                            const stats = calculateNumericStats(originalValues);
                            fieldMetrics[field] = stats;
                        }
                    });
                    
                    // Calcular la cohesi√≥n del cluster (suma de distancias al centroide)
                    let totalDistance = 0;
                    cluster.forEach(point => {
                        totalDistance += calculateDistance(point.normalized, centroids[index]);
                    });
                    
                    const avgDistance = cluster.length > 0 ? totalDistance / cluster.length : 0;
                    
                    return {
                        size: cluster.length,
                        percentage: (cluster.length / extractedData.length) * 100,
                        fieldMetrics,
                        cohesion: avgDistance,
                        centroid: {...centroids[index]}
                    };
                });
                
                // Identificar caracter√≠sticas distintivas de cada cluster
                const clusterProfiles = clusterMetrics.map((metrics, index) => {
                    const distinctiveFeatures = [];
                    
                    fields.forEach(field => {
                        if (metrics.fieldMetrics[field]) {
                            const clusterMean = metrics.fieldMetrics[field].mean;
                            
                            // Comparar con los otros clusters
                            const otherClusters = clusterMetrics.filter((_, i) => i !== index);
                            const otherMeans = otherClusters
                                .map(c => c.fieldMetrics[field] ? c.fieldMetrics[field].mean : null)
                                .filter(mean => mean !== null);
                            
                            if (otherMeans.length > 0) {
                                const overallMean = otherMeans.reduce((sum, val) => sum + val, 0) / otherMeans.length;
                                const difference = clusterMean - overallMean;
                                const percentDiff = (difference / overallMean) * 100;
                                
                                if (Math.abs(percentDiff) > 15) {
                                    distinctiveFeatures.push({
                                        field,
                                        direction: percentDiff > 0 ? 'mayor' : 'menor',
                                        percentDiff: Math.abs(percentDiff)
                                    });
                                }
                            }
                        }
                    });
                    
                    return {
                        clusterIndex: index,
                        distinctiveFeatures: distinctiveFeatures.sort((a, b) => b.percentDiff - a.percentDiff)
                    };
                });
                
                // Asignar clusters a los datos originales
                const dataWithClusters = data.map(record => {
                    // Buscar el punto correspondiente en extractedData
                    const found = extractedData.find(point => point.original === record);
                    
                    if (found) {
                        const clusterIndex = clusters.findIndex(cluster => cluster.includes(found));
                        return {
                            ...record,
                            cluster: clusterIndex !== -1 ? clusterIndex : null
                        };
                    }
                    
                    return {
                        ...record,
                        cluster: null
                    };
                });
                
                return {
                    success: true,
                    clusters: clusterMetrics,
                    clusterProfiles,
                    iterations: iteration,
                    dataWithClusters
                };
            } catch (error) {
                console.error('Error en performClusterAnalysis:', error);
                return {
                    success: false,
                    message: 'Error en an√°lisis de cl√∫steres: ' + error.message
                };
            }
        }
        
        // Funci√≥n para generar un an√°lisis predictivo consolidado
        function generatePredictiveAnalysis() {
            try {
                if (globalData.totalRecords === 0) {
                    return {
                        success: false,
                        message: 'No hay datos suficientes para realizar an√°lisis predictivo.'
                    };
                }
                
                const analysis = {
                    trends: [],
                    correlations: [],
                    forecast: null,
                    clusters: null,
                    segments: [],
                    recommendations: []
                };
                
                // 1. An√°lisis de tendencias para campos num√©ricos con series temporales
                const dateFields = Object.keys(globalData.dates);
                const numericFields = Object.keys(globalData.numerics);
                
                if (dateFields.length > 0 && numericFields.length > 0) {
                    const dateField = dateFields[0];
                    
                    numericFields.slice(0, 3).forEach(numericField => {
                        // Preparar datos de serie temporal
                        const timeData = {};
                        
                        globalData.rawData.forEach(record => {
                            if (record[dateField] && record[numericField]) {
                                // Convertir a fecha
                                let dateValue;
                                try {
                                    dateValue = new Date(record[dateField]);
                                } catch (e) {
                                    return; // Ignorar si no es una fecha v√°lida
                                }
                                
                                if (isNaN(dateValue.getTime())) return; // Ignorar si no es una fecha v√°lida
                                
                                // Agrupar por mes
                                const year = dateValue.getFullYear();
                                const month = dateValue.getMonth() + 1;
                                const period = `${year}-${month.toString().padStart(2, '0')}`;
                                
                                if (!timeData[period]) {
                                    timeData[period] = {
                                        sum: 0,
                                        count: 0
                                    };
                                }
                                
                                const numValue = Number(record[numericField]);
                                if (!isNaN(numValue)) {
                                    timeData[period].sum += numValue;
                                    timeData[period].count++;
                                }
                            }
                        });
                        
                        // Calcular promedios por per√≠odo
                        const timeAvg = {};
                        Object.keys(timeData).forEach(period => {
                            if (timeData[period].count > 0) {
                                timeAvg[period] = timeData[period].sum / timeData[period].count;
                            }
                        });
                        
                        // Ordenar per√≠odos cronol√≥gicamente
                        const sortedPeriods = Object.keys(timeAvg).sort();
                        const values = sortedPeriods.map(period => timeAvg[period]);
                        
                        if (sortedPeriods.length >= 4) {
                            // Analizar tendencia y generar pron√≥stico
                            const timeSeriesAnalysis = analyzeTimeSeries(sortedPeriods, values);
                            
                            // Formatear fechas para las predicciones
                            const lastPeriod = sortedPeriods[sortedPeriods.length - 1];
                            const [lastYear, lastMonth] = lastPeriod.split('-').map(Number);
                            
                            const formattedForecasts = timeSeriesAnalysis.forecast.map((forecast, index) => {
                                let forecastMonth = lastMonth + index + 1;
                                let forecastYear = lastYear;
                                
                                while (forecastMonth > 12) {
                                    forecastMonth -= 12;
                                    forecastYear += 1;
                                }
                                
                                return {
                                    period: `${forecastYear}-${forecastMonth.toString().padStart(2, '0')}`,
                                    value: forecast.value
                                };
                            });
                            
                            analysis.trends.push({
                                field: numericField,
                                dateField,
                                trend: timeSeriesAnalysis.trend,
                                seasonality: timeSeriesAnalysis.seasonality,
                                equation: timeSeriesAnalysis.equation,
                                rSquared: timeSeriesAnalysis.rSquared,
                                forecast: formattedForecasts,
                                confidence: timeSeriesAnalysis.confidence
                            });
                        }
                    });
                    
                    // Establecer el pron√≥stico principal (primer campo num√©rico)
                    if (analysis.trends.length > 0) {
                        analysis.forecast = analysis.trends[0];
                    }
                }
                
                // 2. An√°lisis de correlaciones entre campos num√©ricos
                if (numericFields.length >= 2) {
                    // Analizar todas las combinaciones de pares de campos num√©ricos
                    for (let i = 0; i < numericFields.length - 1; i++) {
                        for (let j = i + 1; j < numericFields.length; j++) {
                            const field1 = numericFields[i];
                            const field2 = numericFields[j];
                            
                            const correlation = calculateCorrelation(globalData.rawData, field1, field2);
                            
                            if (Math.abs(correlation.correlation) >= 0.3) {
                                analysis.correlations.push({
                                    field1,
                                    field2,
                                    correlation: correlation.correlation,
                                    strength: correlation.strength,
                                    direction: correlation.direction
                                });
                            }
                        }
                    }
                    
                    // Ordenar por fuerza de correlaci√≥n
                    analysis.correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
                }
                
                // 3. An√°lisis de cl√∫steres si hay suficientes campos num√©ricos
                if (numericFields.length >= 2) {
                    // Seleccionar hasta 4 campos num√©ricos para el an√°lisis
                    const clusterFields = numericFields.slice(0, 4);
                    
                    // Determinar el n√∫mero √≥ptimo de cl√∫steres (entre 2 y 5)
                    const maxClusters = Math.min(5, Math.ceil(Math.sqrt(globalData.totalRecords / 10)));
                    const k = Math.max(2, Math.min(maxClusters, 3)); // Default a 3 si es posible
                    
                    const clusterAnalysis = performClusterAnalysis(globalData.rawData, clusterFields, k);
                    
                    if (clusterAnalysis.success) {
                        analysis.clusters = {
                            k,
                            fields: clusterFields,
                            clusters: clusterAnalysis.clusters,
                            profiles: clusterAnalysis.clusterProfiles
                        };
                        
                        // Generar segmentos basados en los perfiles de cl√∫steres
                        clusterAnalysis.clusterProfiles.forEach((profile, index) => {
                            const cluster = clusterAnalysis.clusters[index];
                            
                            if (profile.distinctiveFeatures.length > 0) {
                                // Crear descripci√≥n del segmento
                                const topFeatures = profile.distinctiveFeatures.slice(0, 3);
                                
                                const featureDescriptions = topFeatures.map(feature => {
                                    const percentDiff = feature.percentDiff.toFixed(1);
                                    return `"${feature.field}" ${feature.direction} (${percentDiff}%)`;
                                });
                                
                                const segmentName = `Segmento ${index + 1}`;
                                const segmentDesc = `Caracterizado por ${featureDescriptions.join(', ')}`;
                                
                                analysis.segments.push({
                                    name: segmentName,
                                    size: cluster.size,
                                    percentage: cluster.percentage.toFixed(1),
                                    description: segmentDesc,
                                    features: topFeatures
                                });
                            }
                        });
                    }
                }
                
                // 4. Generar recomendaciones basadas en los hallazgos
                
                // Recomendaciones basadas en tendencias
                if (analysis.trends.length > 0) {
                    const mainTrend = analysis.trends[0];
                    
                    if (mainTrend.trend.includes('creciente')) {
                        analysis.recommendations.push({
                            type: 'tendencia',
                            title: `Aprovechar tendencia creciente en ${mainTrend.field}`,
                            description: `Los datos muestran una tendencia ${mainTrend.trend} para ${mainTrend.field}. Se recomienda capitalizar este crecimiento preparando capacidad adicional y optimizando recursos.`,
                            confidence: mainTrend.confidence
                        });
                    } else if (mainTrend.trend.includes('decreciente')) {
                        analysis.recommendations.push({
                            type: 'tendencia',
                            title: `Mitigar tendencia decreciente en ${mainTrend.field}`,
                            description: `Los datos muestran una tendencia ${mainTrend.trend} para ${mainTrend.field}. Se recomienda investigar las causas subyacentes e implementar estrategias para revertir esta tendencia.`,
                            confidence: mainTrend.confidence
                        });
                    }
                    
                    if (mainTrend.seasonality && !mainTrend.seasonality.includes('no detectada')) {
                        analysis.recommendations.push({
                            type: 'estacionalidad',
                            title: `Planificar para patrones estacionales`,
                            description: `Se ha detectado estacionalidad ${mainTrend.seasonality} en ${mainTrend.field}. Se recomienda ajustar la planificaci√≥n de recursos y estrategias para adaptarse a estos ciclos predecibles.`,
                            confidence: 'media-alta'
                        });
                    }
                }
                
                // Recomendaciones basadas en correlaciones
                if (analysis.correlations.length > 0) {
                    const strongestCorrelation = analysis.correlations[0];
                    
                    analysis.recommendations.push({
                        type: 'correlaci√≥n',
                        title: `Explorar relaci√≥n entre ${strongestCorrelation.field1} y ${strongestCorrelation.field2}`,
                        description: `Existe una correlaci√≥n ${strongestCorrelation.strength} ${strongestCorrelation.direction} entre estos campos. Se recomienda analizar c√≥mo el cambio en uno podr√≠a influir en el otro para optimizar resultados.`,
                        confidence: strongestCorrelation.strength.includes('fuerte') ? 'alta' : 'media'
                    });
                }
                
                // Recomendaciones basadas en segmentos
                if (analysis.segments.length > 0) {
                    const largestSegment = analysis.segments.reduce(
                        (max, segment) => parseFloat(segment.percentage) > parseFloat(max.percentage) ? segment : max, 
                        analysis.segments[0]
                    );
                    
                    analysis.recommendations.push({
                        type: 'segmentaci√≥n',
                        title: `Estrategia espec√≠fica para ${largestSegment.name}`,
                        description: `Este segmento representa el ${largestSegment.percentage}% de los datos y est√° ${largestSegment.description}. Se recomienda desarrollar estrategias espec√≠ficas que consideren estas caracter√≠sticas distintivas.`,
                        confidence: 'media-alta'
                    });
                }
                
                return {
                    success: true,
                    analysis
                };
            } catch (error) {
                console.error('Error en generatePredictiveAnalysis:', error);
                return {
                    success: false,
                    message: 'Error al generar an√°lisis predictivo: ' + error.message
                };
            }
        }
        
        // Funci√≥n para generar el dashboard completo
        function generateDashboard() {
            try {
                console.log('Generando dashboard...');
                
                // Limpiar el contenedor del dashboard
                const dashboardContainer = document.getElementById('dashboard-container');
                if (!dashboardContainer) {
                    console.error('Contenedor del dashboard no encontrado');
                    return;
                }
                dashboardContainer.innerHTML = '';
                
                // Limpiar los gr√°ficos existentes
                console.log('Limpiando gr√°ficos existentes...');
                for (const chartId in charts) {
                    try {
                        if (charts[chartId]) {
                            charts[chartId].destroy();
                            delete charts[chartId];
                        }
                    } catch (chartError) {
                        console.error(`Error al destruir el gr√°fico ${chartId}:`, chartError);
                    }
                }
                
                // Si no hay datos, mostrar mensaje
                if (globalData.totalRecords === 0) {
                    console.log('No hay datos para mostrar');
                    dashboardContainer.innerHTML = `
                        <div class="card full-width">
                            <h2>No hay datos para mostrar</h2>
                            <p>Cargue un archivo Excel o proporcione una URL de Google Sheets para comenzar el an√°lisis.</p>
                        </div>
                    `;
                    return;
                }
                
                console.log(`Generando dashboard con ${globalData.totalRecords} registros`);
                
                // 1. Generar tarjeta de resumen
                try {
                    console.log('Generando tarjeta de resumen...');
                    generateSummaryCard(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar tarjeta de resumen:', error);
                }
                
                // 2. Generar gr√°ficos de distribuci√≥n para campos categ√≥ricos (m√°ximo 4)
                const categoryFields = Object.keys(globalData.categories);
                console.log(`Se encontraron ${categoryFields.length} campos categ√≥ricos:`, categoryFields);
                
                for (let i = 0; i < Math.min(categoryFields.length, 4); i++) {
                    try {
                        console.log(`Generando gr√°fico para categor√≠a ${i+1}/${Math.min(categoryFields.length, 4)}: ${categoryFields[i]}`);
                        generateCategoryChart(dashboardContainer, categoryFields[i]);
                    } catch (error) {
                        console.error(`Error al generar gr√°fico para categor√≠a ${categoryFields[i]}:`, error);
                    }
                }
                
                // 3. Generar gr√°ficos para campos num√©ricos (m√°ximo 4)
                const numericFields = Object.keys(globalData.numerics);
                console.log(`Se encontraron ${numericFields.length} campos num√©ricos:`, numericFields);
                
                for (let i = 0; i < Math.min(numericFields.length, 4); i++) {
                    try {
                        console.log(`Generando gr√°fico para campo num√©rico ${i+1}/${Math.min(numericFields.length, 4)}: ${numericFields[i]}`);
                        generateNumericChart(dashboardContainer, numericFields[i]);
                    } catch (error) {
                        console.error(`Error al generar gr√°fico para campo num√©rico ${numericFields[i]}:`, error);
                    }
                }
                
                // 4. Generar gr√°ficos combinados (categ√≥rico vs num√©rico)
                if (categoryFields.length > 0 && numericFields.length > 0) {
                    try {
                        console.log(`Generando gr√°fico combinado: ${categoryFields[0]} vs ${numericFields[0]}`);
                        generateCombinedChart(dashboardContainer, categoryFields[0], numericFields[0]);
                    } catch (error) {
                        console.error(`Error al generar gr√°fico combinado:`, error);
                    }
                }
                
                // 5. Generar gr√°ficos de tendencia temporal si hay campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0 && numericFields.length > 0) {
                    try {
                        console.log(`Generando gr√°fico de serie temporal: ${dateFields[0]} - ${numericFields[0]}`);
                        generateTimeSeriesChart(dashboardContainer, dateFields[0], numericFields[0]);
                    } catch (error) {
                        console.error(`Error al generar gr√°fico de serie temporal:`, error);
                    }
                }
                
                // 6. Generar secci√≥n de an√°lisis predictivo
                try {
                    console.log('Generando secci√≥n de an√°lisis predictivo...');
                    generatePredictiveSection(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar secci√≥n de an√°lisis predictivo:', error);
                }
                
                // 7. Generar tablas de datos principales
                try {
                    console.log('Generando tabla de datos...');
                    generateDataTable(dashboardContainer);
                } catch (error) {
                    console.error('Error al generar tabla de datos:', error);
                }
                
                // 8. Generar an√°lisis y recomendaciones
                try {
                    console.log('Generando an√°lisis y recomendaciones...');
                    generateAnalysisAndRecommendations();
                } catch (error) {
                    console.error('Error al generar an√°lisis y recomendaciones:', error);
                }
                
                // 9. Configurar filtros din√°micos
                try {
                    console.log('Configurando filtros din√°micos...');
                    setupDynamicFilters();
                } catch (error) {
                    console.error('Error al configurar filtros din√°micos:', error);
                }
                
                console.log('Generaci√≥n del dashboard completada');
            } catch (error) {
                console.error('Error en generateDashboard:', error);
                showAlert('error-alert', 'Error al generar el dashboard: ' + error.message);
            }
        }
        
        // Funci√≥n para generar la tarjeta de resumen
        function generateSummaryCard(container) {
            try {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.innerHTML = `
                    <h2>Resumen General</h2>
                    <div class="stats-container" id="summary-stats"></div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="summary-analysis">Analizando datos...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Agregar estad√≠sticas
                const statsContainer = document.getElementById('summary-stats');
                
                // Total de registros
                const totalStat = document.createElement('div');
                totalStat.className = 'stat-box';
                totalStat.innerHTML = `
                    <h3>Total Registros</h3>
                    <p>${globalData.totalRecords}</p>
                `;
                statsContainer.appendChild(totalStat);
                
                // Campos analizados
                const fieldsStat = document.createElement('div');
                fieldsStat.className = 'stat-box';
                fieldsStat.innerHTML = `
                    <h3>Campos Analizados</h3>
                    <p>${Object.keys(globalData.fields).length}</p>
                `;
                statsContainer.appendChild(fieldsStat);
                
                // Categor√≠as principales (si existen)
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const categoryCount = globalData.categories[mainCategory].uniqueValues.length;
                    
                    const categoryStat = document.createElement('div');
                    categoryStat.className = 'stat-box';
                    categoryStat.innerHTML = `
                        <h3>${mainCategory}</h3>
                        <p>${categoryCount}</p>
                    `;
                    statsContainer.appendChild(categoryStat);
                }
                
                // Campo num√©rico principal (si existe)
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    const numericStat = document.createElement('div');
                    numericStat.className = 'stat-box';
                    numericStat.innerHTML = `
                        <h3>Promedio ${mainNumeric}</h3>
                        <p>${stats.mean.toFixed(2)}</p>
                    `;
                    statsContainer.appendChild(numericStat);
                    
                    // Mostrar outliers si existen
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outliersStat = document.createElement('div');
                        outliersStat.className = 'stat-box risk-high';
                        outliersStat.innerHTML = `
                            <h3>Valores At√≠picos</h3>
                            <p>${stats.outliers.length}</p>
                        `;
                        statsContainer.appendChild(outliersStat);
                    }
                }
                
                // Generar el an√°lisis de resumen
                generateSummaryAnalysis();
            } catch (error) {
                console.error('Error en generateSummaryCard:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar el an√°lisis de resumen
        function generateSummaryAnalysis() {
            try {
                let analysis = `El conjunto de datos contiene ${globalData.totalRecords} registros con ${Object.keys(globalData.fields).length} campos analizados. `;
                
                // An√°lisis de campos categ√≥ricos
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    analysis += `Se identificaron ${categoryFields.length} campos categ√≥ricos. `;
                    
                    // Analizar la distribuci√≥n del primer campo categ√≥rico
                    const mainCategory = categoryFields[0];
                    const categoryValues = globalData.categories[mainCategory].uniqueValues.length;
                    
                    analysis += `El campo "${mainCategory}" contiene ${categoryValues} valores √∫nicos. `;
                    
                    // Identificar valores m√°s frecuentes
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    if (sortedValues.length > 0) {
                        analysis += `Los valores m√°s frecuentes son: `;
                        sortedValues.forEach((entry, index) => {
                            const percentage = ((entry[1] / globalData.totalRecords) * 100).toFixed(1);
                            analysis += `"${entry[0]}" (${percentage}%)`;
                            
                            if (index < sortedValues.length - 1) {
                                analysis += ', ';
                            } else {
                                analysis += '. ';
                            }
                        });
                    }
                }
                
                // An√°lisis de campos num√©ricos
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    analysis += `Se identificaron ${numericFields.length} campos num√©ricos. `;
                    
                    // Analizar estad√≠sticas del primer campo num√©rico
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    analysis += `Para el campo "${mainNumeric}", el valor promedio es ${stats.mean.toFixed(2)}, `;
                    analysis += `con un valor m√≠nimo de ${stats.min.toFixed(2)} y m√°ximo de ${stats.max.toFixed(2)}. `;
                    
                    // An√°lisis de dispersi√≥n
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        analysis += `Los datos muestran una alta variabilidad (CV = ${cv.toFixed(1)}%), lo que indica valores dispersos. `;
                    } else if (cv > 20) {
                        analysis += `Los datos muestran una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        analysis += `Los datos muestran una baja variabilidad (CV = ${cv.toFixed(1)}%), lo que indica valores m√°s homog√©neos. `;
                    }
                    
                    // An√°lisis de asimetr√≠a
                    if (stats.skewness) {
                        if (Math.abs(stats.skewness) > 1) {
                            const skewType = stats.skewness > 0 ? "positiva" : "negativa";
                            analysis += `La distribuci√≥n presenta una asimetr√≠a ${skewType} significativa (${stats.skewness.toFixed(2)}), `;
                            analysis += `lo que indica una concentraci√≥n de valores ${stats.skewness > 0 ? "bajos con algunos valores extremos altos" : "altos con algunos valores extremos bajos"}. `;
                        }
                    }
                    
                    // An√°lisis de valores at√≠picos
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outlierPercentage = (stats.outliers.length / stats.count * 100).toFixed(1);
                        analysis += `Se detectaron ${stats.outliers.length} valores at√≠picos (${outlierPercentage}% del total), `;
                        analysis += `que podr√≠an afectar significativamente los an√°lisis estad√≠sticos. `;
                    }
                }
                
                // An√°lisis de campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0) {
                    analysis += `Se identificaron ${dateFields.length} campos de fecha, lo que permite realizar an√°lisis temporales y predicciones. `;
                }
                
                document.getElementById('summary-analysis').textContent = analysis;
            } catch (error) {
                console.error('Error en generateSummaryAnalysis:', error);
                document.getElementById('summary-analysis').textContent = 'Error al generar el an√°lisis de resumen.';
            }
        }
        
        // Funci√≥n para generar gr√°fico de distribuci√≥n de categor√≠a
        function generateCategoryChart(container, fieldName) {
            try {
                console.log(`Generando gr√°fico de categor√≠a para el campo: ${fieldName}`);
                
                if (!globalData.categories[fieldName]) {
                    console.warn(`Campo ${fieldName} no encontrado en los datos de categor√≠as`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                const chartId = `chart-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Distribuci√≥n de ${fieldName}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="${analysisId}">Analizando distribuci√≥n...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Obtener datos para el gr√°fico
                const distribution = globalData.categories[fieldName].distribution;
                console.log(`Datos de distribuci√≥n para ${fieldName}:`, distribution);
                
                if (!distribution || Object.keys(distribution).length === 0) {
                    console.warn(`No hay datos de distribuci√≥n disponibles para ${fieldName}`);
                    document.getElementById(analysisId).textContent = `No hay datos de distribuci√≥n disponibles para ${fieldName}`;
                    return;
                }
                
                // Ordenar y limitar a los 10 valores m√°s frecuentes si hay muchos
                const sortedData = Object.entries(distribution)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                
                const labels = sortedData.map(item => item[0]);
                const values = sortedData.map(item => item[1]);
                
                console.log(`Datos del gr√°fico para ${fieldName}:`, { labels, values });
                
                // Crear gr√°fico con manejo de errores
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    // Crear gr√°fico con configuraci√≥n simplificada
                    charts[chartId] = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: values,
                                backgroundColor: generateColors(labels.length)
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: {
                                        font: {
                                            size: 12
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || '';
                                            const value = context.raw || 0;
                                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                            const percentage = Math.round((value / total) * 100);
                                            return `${label}: ${value} (${percentage}%)`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gr√°fico creado exitosamente para ${fieldName}`);
                    
                    // Generar an√°lisis
                    generateCategoryAnalysis(fieldName, distribution, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gr√°fico para ${fieldName}:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gr√°fico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateCategoryChart para ${fieldName}:`, error);
            }
        }
        
        // Funci√≥n para generar an√°lisis de distribuci√≥n de categor√≠a
        function generateCategoryAnalysis(fieldName, distribution, analysisId) {
            try {
                const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
                const sortedData = Object.entries(distribution)
                    .sort((a, b) => b[1] - a[1]);
                
                let analysis = '';
                
                // Analizar valores m√°s frecuentes
                if (sortedData.length > 0) {
                    const topValue = sortedData[0];
                    const topPercentage = ((topValue[1] / total) * 100).toFixed(1);
                    
                    analysis += `En el campo "${fieldName}", el valor m√°s frecuente es "${topValue[0]}" con ${topValue[1]} registros (${topPercentage}%). `;
                    
                    // Analizar concentraci√≥n
                    if (sortedData.length >= 3) {
                        const top3 = sortedData.slice(0, 3);
                        const top3Count = top3.reduce((sum, item) => sum + item[1], 0);
                        const top3Percentage = ((top3Count / total) * 100).toFixed(1);
                        
                        analysis += `Los 3 valores principales representan el ${top3Percentage}% de los datos, `;
                        
                        if (top3Percentage > 80) {
                            analysis += `lo que indica una alta concentraci√≥n en pocos valores. `;
                        } else if (top3Percentage > 50) {
                            analysis += `mostrando una concentraci√≥n moderada. `;
                        } else {
                            analysis += `indicando una distribuci√≥n m√°s equilibrada entre los diferentes valores. `;
                        }
                    }
                    
                    // Analizar "cola larga"
                    const uniqueCount = sortedData.length;
                    if (uniqueCount > 10) {
                        const tailCount = sortedData.slice(10).reduce((sum, item) => sum + item[1], 0);
                        const tailPercentage = ((tailCount / total) * 100).toFixed(1);
                        
                        analysis += `Hay ${uniqueCount - 10} valores adicionales que representan el ${tailPercentage}% de los datos, `;
                        
                        if (tailPercentage > 30) {
                            analysis += `lo que sugiere una "cola larga" significativa en la distribuci√≥n. `;
                        } else {
                            analysis += `formando una "cola larga" de menor relevancia. `;
                        }
                    }
                    
                    // An√°lisis de equidad de la distribuci√≥n (√≠ndice de Gini simplificado)
                    if (sortedData.length > 1) {
                        const values = sortedData.map(item => item[1]);
                        const totalSum = values.reduce((sum, val) => sum + val, 0);
                        const proportions = values.map(val => val / totalSum);
                        
                        // Calcular una versi√≥n simplificada del √≠ndice de Gini
                        let giniSum = 0;
                        for (let i = 0; i < proportions.length; i++) {
                            for (let j = 0; j < proportions.length; j++) {
                                giniSum += Math.abs(proportions[i] - proportions[j]);
                            }
                        }
                        
                        const gini = giniSum / (2 * proportions.length * proportions.length);
                        
                        if (gini > 0.6) {
                            analysis += `La distribuci√≥n muestra una desigualdad alta (Gini ‚âà ${gini.toFixed(2)}), con una fuerte dominancia de pocos valores. `;
                        } else if (gini > 0.4) {
                            analysis += `La distribuci√≥n muestra una desigualdad moderada (Gini ‚âà ${gini.toFixed(2)}). `;
                        } else {
                            analysis += `La distribuci√≥n es relativamente equitativa entre los diferentes valores (Gini ‚âà ${gini.toFixed(2)}). `;
                        }
                    }
                } else {
                    analysis = `No hay suficientes datos para analizar la distribuci√≥n de "${fieldName}".`;
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateCategoryAnalysis para ${fieldName}:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar la distribuci√≥n: ${error.message}`;
            }
        }
        
        // Funci√≥n para generar gr√°fico de campo num√©rico
        function generateNumericChart(container, fieldName) {
            try {
                console.log(`Generando gr√°fico num√©rico para el campo: ${fieldName}`);
                
                if (!globalData.numerics[fieldName]) {
                    console.warn(`Campo ${fieldName} no encontrado en los datos num√©ricos`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                
                const chartId = `chart-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-${fieldName.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Distribuci√≥n de ${fieldName}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="${analysisId}">Analizando distribuci√≥n num√©rica...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Generar datos para histograma
                const values = [];
                globalData.rawData.forEach(record => {
                    if (record[fieldName] !== undefined && record[fieldName] !== null && record[fieldName] !== '') {
                        const numValue = Number(record[fieldName]);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    }
                });
                
                console.log(`Valores num√©ricos para ${fieldName}: ${values.length} valores v√°lidos`);
                
                if (values.length === 0) {
                    console.warn(`No hay valores num√©ricos v√°lidos para ${fieldName}`);
                    document.getElementById(analysisId).textContent = `No hay valores num√©ricos v√°lidos para ${fieldName}`;
                    return;
                }
                
                // Calcular intervalos para histograma
                const stats = globalData.numerics[fieldName].stats;
                const min = stats.min;
                const max = stats.max;
                const range = max - min;
                const binCount = Math.min(10, Math.ceil(Math.sqrt(values.length)));
                const binWidth = range / binCount;
                
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                // Crear etiquetas de bins
                for (let i = 0; i < binCount; i++) {
                    const binStart = min + (i * binWidth);
                    const binEnd = binStart + binWidth;
                    binLabels.push(`${binStart.toFixed(1)} - ${binEnd.toFixed(1)}`);
                }
                
                // Clasificar valores en bins
                values.forEach(value => {
                    if (value >= min && value <= max) {
                        const binIndex = Math.min(binCount - 1, Math.floor((value - min) / binWidth));
                        bins[binIndex]++;
                    }
                });
                
                console.log(`Datos del histograma para ${fieldName}:`, { binLabels, bins });
                
                // Crear dataset para la curva de distribuci√≥n normal
                const normalCurveData = [];
                if (stats.std > 0) { // Evitar divisi√≥n por cero
                    for (let i = 0; i < binCount; i++) {
                        const x = min + (i + 0.5) * binWidth;
                        const z = (x - stats.mean) / stats.std;
                        const y = (1 / (stats.std * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
                        // Escalar para que se ajuste al histograma
                        const maxBin = Math.max(...bins);
                        const scaleFactor = maxBin / (1 / (stats.std * Math.sqrt(2 * Math.PI)));
                        normalCurveData.push(y * scaleFactor);
                    }
                }
                
                // Crear gr√°fico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: binLabels,
                            datasets: [{
                                label: 'Frecuencia',
                                data: bins,
                                backgroundColor: reportStyles.primaryColor,
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 1
                            }, {
                                label: 'Distribuci√≥n normal',
                                data: normalCurveData,
                                type: 'line',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Frecuencia'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: fieldName
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gr√°fico creado exitosamente para ${fieldName}`);
                    
                    // Generar an√°lisis
                    generateNumericAnalysis(fieldName, stats, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gr√°fico para ${fieldName}:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gr√°fico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateNumericChart para ${fieldName}:`, error);
            }
        }
        
        // Funci√≥n mejorada para generar an√°lisis de campo num√©rico
        function generateNumericAnalysis(fieldName, stats, analysisId) {
            try {
                let analysis = `El campo "${fieldName}" tiene un valor promedio de ${stats.mean.toFixed(2)}, `;
                analysis += `con un rango desde ${stats.min.toFixed(2)} hasta ${stats.max.toFixed(2)}. `;
                
                // An√°lisis de la dispersi√≥n
                const cv = (stats.std / stats.mean) * 100;
                
                if (stats.std > 0) {
                    analysis += `La desviaci√≥n est√°ndar es ${stats.std.toFixed(2)}, `;
                    
                    if (cv > 50) {
                        analysis += `lo que indica una alta variabilidad en los datos (CV = ${cv.toFixed(1)}%). `;
                    } else if (cv > 20) {
                        analysis += `mostrando una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        analysis += `lo que sugiere datos relativamente homog√©neos (CV = ${cv.toFixed(1)}%). `;
                    }
                }
                
                // An√°lisis de cuartiles y distribuci√≥n
                analysis += `El primer cuartil (Q1) es ${stats.q1.toFixed(2)} y el tercer cuartil (Q3) es ${stats.q3.toFixed(2)}, `;
                analysis += `con un rango intercuart√≠lico (IQR) de ${stats.iqr.toFixed(2)}. `;
                
                // An√°lisis de asimetr√≠a y curtosis
                if (stats.skewness !== undefined && stats.kurtosis !== undefined) {
                    if (Math.abs(stats.skewness) > 0.5) {
                        analysis += `La distribuci√≥n muestra una asimetr√≠a ${stats.skewness > 0 ? 'positiva' : 'negativa'} (${stats.skewness.toFixed(2)}), `;
                        analysis += `lo que indica una mayor concentraci√≥n de valores ${stats.skewness > 0 ? 'por debajo de la media con algunos valores altos extremos' : 'por encima de la media con algunos valores bajos extremos'}. `;
                    } else {
                        analysis += `La distribuci√≥n es aproximadamente sim√©trica (asimetr√≠a = ${stats.skewness.toFixed(2)}). `;
                    }
                    
                    if (Math.abs(stats.kurtosis) > 1) {
                        if (stats.kurtosis > 0) {
                            analysis += `La distribuci√≥n es leptoc√∫rtica (curtosis = ${stats.kurtosis.toFixed(2)}), `;
                            analysis += `con picos m√°s pronunciados que una distribuci√≥n normal y colas m√°s pesadas. `;
                        } else {
                            analysis += `La distribuci√≥n es platic√∫rtica (curtosis = ${stats.kurtosis.toFixed(2)}), `;
                            analysis += `con picos m√°s planos que una distribuci√≥n normal y colas m√°s ligeras. `;
                        }
                    } else {
                        analysis += `La curtosis (${stats.kurtosis.toFixed(2)}) es cercana a la de una distribuci√≥n normal. `;
                    }
                }
                
                // An√°lisis de valores at√≠picos
                if (stats.outliers && stats.outliers.length > 0) {
                    const outlierPercentage = (stats.outliers.length / stats.count * 100).toFixed(1);
                    analysis += `Se detectaron ${stats.outliers.length} valores at√≠picos (${outlierPercentage}% de los datos), `;
                    
                    if (outlierPercentage > 5) {
                        analysis += `lo que podr√≠a indicar problemas en la calidad de los datos o la presencia de casos especiales que merecen un an√°lisis detallado. `;
                    } else {
                        analysis += `que podr√≠an representar casos especiales pero no afectan significativamente el an√°lisis general. `;
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateNumericAnalysis para ${fieldName}:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar los datos num√©ricos: ${error.message}`;
            }
        }
        
        // Funci√≥n para generar gr√°fico combinado (categ√≥rico vs num√©rico)
        function generateCombinedChart(container, categoryField, numericField) {
            try {
                console.log(`Generando gr√°fico combinado: ${categoryField} vs ${numericField}`);
                
                if (!globalData.categories[categoryField] || !globalData.numerics[numericField]) {
                    console.warn(`Campos no v√°lidos para gr√°fico combinado: ${categoryField}, ${numericField}`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const chartId = `chart-combined-${categoryField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-combined-${categoryField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>${numericField} por ${categoryField}</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="${analysisId}">Analizando relaci√≥n...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Calcular promedio de campo num√©rico por categor√≠a
                const categoryAverages = {};
                const categoryCounts = {};
                const categoryStdDevs = {};
                
                globalData.rawData.forEach(record => {
                    const category = record[categoryField];
                    const numValue = Number(record[numericField]);
                    
                    if (category && !isNaN(numValue)) {
                        if (!categoryAverages[category]) {
                            categoryAverages[category] = 0;
                            categoryCounts[category] = 0;
                            categoryStdDevs[category] = [];
                        }
                        
                        categoryAverages[category] += numValue;
                        categoryCounts[category]++;
                        categoryStdDevs[category].push(numValue);
                    }
                });
                
                console.log(`Datos de promedios por categor√≠a calculados`);
                
                // Calcular promedios finales y desviaciones est√°ndar
                Object.keys(categoryAverages).forEach(category => {
                    if (categoryCounts[category] > 0) {
                        categoryAverages[category] = categoryAverages[category] / categoryCounts[category];
                        
                        // Calcular desviaci√≥n est√°ndar
                        const mean = categoryAverages[category];
                        const squaredDiffs = categoryStdDevs[category].map(val => Math.pow(val - mean, 2));
                        const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / squaredDiffs.length;
                        categoryStdDevs[category] = Math.sqrt(avgSquaredDiff);
                    }
                });
                
                // Obtener las 10 categor√≠as principales por cantidad
                const topCategories = Object.entries(categoryCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(item => item[0]);
                
                if (topCategories.length === 0) {
                    console.warn(`No hay datos v√°lidos para el gr√°fico combinado`);
                    document.getElementById(analysisId).textContent = `No hay datos v√°lidos para generar este gr√°fico.`;
                    return;
                }
                
                // Datos para el gr√°fico
                const labels = topCategories;
                const data = topCategories.map(category => categoryAverages[category]);
                const counts = topCategories.map(category => categoryCounts[category]);
                const stdDevs = topCategories.map(category => categoryStdDevs[category]);
                
                console.log(`Datos para gr√°fico combinado preparados: ${labels.length} categor√≠as`);
                
                // Crear gr√°fico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Promedio de ${numericField}`,
                                data: data,
                                backgroundColor: reportStyles.primaryColor,
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 1,
                                order: 1
                            }, {
                                label: 'Cantidad de registros',
                                data: counts,
                                type: 'line',
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointBackgroundColor: reportStyles.accentColor,
                                yAxisID: 'y1',
                                order: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `Promedio de ${numericField}`
                                    }
                                },
                                y1: {
                                    position: 'right',
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: 'Cantidad de registros'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: categoryField
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            const categoryIndex = context.dataIndex;
                                            const category = topCategories[categoryIndex];
                                            return `Desv. Est.: ${categoryStdDevs[category].toFixed(2)}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gr√°fico combinado creado exitosamente`);
                    
                    // Generar an√°lisis
                    generateCombinedAnalysis(categoryField, numericField, categoryAverages, categoryCounts, categoryStdDevs, topCategories, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gr√°fico combinado:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gr√°fico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateCombinedChart:`, error);
            }
        }
        
        // Funci√≥n mejorada para generar an√°lisis de gr√°fico combinado
        function generateCombinedAnalysis(categoryField, numericField, averages, counts, stdDevs, categories, analysisId) {
            try {
                let analysis = `Este gr√°fico muestra la relaci√≥n entre "${categoryField}" y el promedio de "${numericField}". `;
                
                if (categories.length > 0) {
                    // Encontrar categor√≠a con valor m√°ximo y m√≠nimo
                    const maxCategory = categories.reduce((max, category) => 
                        averages[category] > averages[max] ? category : max, categories[0]);
                    
                    const minCategory = categories.reduce((min, category) => 
                        averages[category] < averages[min] ? category : min, categories[0]);
                    
                    // Analizar valores m√°ximos y m√≠nimos
                    analysis += `"${maxCategory}" presenta el valor promedio m√°s alto (${averages[maxCategory].toFixed(2)}), `;
                    analysis += `mientras que "${minCategory}" muestra el valor m√°s bajo (${averages[minCategory].toFixed(2)}). `;
                    
                    // Calcular variaci√≥n relativa
                    const relativeVariation = (averages[maxCategory] - averages[minCategory]) / averages[minCategory] * 100;
                    
                    if (relativeVariation > 100) {
                        analysis += `Existe una variaci√≥n muy significativa del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else if (relativeVariation > 50) {
                        analysis += `Existe una variaci√≥n significativa del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else if (relativeVariation > 20) {
                        analysis += `Existe una variaci√≥n moderada del ${relativeVariation.toFixed(1)}% entre estos grupos. `;
                    } else {
                        analysis += `La variaci√≥n entre grupos es relativamente peque√±a (${relativeVariation.toFixed(1)}%). `;
                    }
                    
                    // An√°lisis de correlaci√≥n entre tama√±o del grupo y valor promedio
                    const avgValues = categories.map(c => averages[c]);
                    const groupSizes = categories.map(c => counts[c]);
                    
                    // Calcular correlaci√≥n simple
                    let correlation = 0;
                    if (avgValues.length > 1) {
                        const avgMean = avgValues.reduce((sum, val) => sum + val, 0) / avgValues.length;
                        const sizeMean = groupSizes.reduce((sum, val) => sum + val, 0) / groupSizes.length;
                        
                        let numerator = 0;
                        let denom1 = 0;
                        let denom2 = 0;
                        
                        for (let i = 0; i < avgValues.length; i++) {
                            numerator += (avgValues[i] - avgMean) * (groupSizes[i] - sizeMean);
                            denom1 += Math.pow(avgValues[i] - avgMean, 2);
                            denom2 += Math.pow(groupSizes[i] - sizeMean, 2);
                        }
                        
                        if (denom1 > 0 && denom2 > 0) {
                            correlation = numerator / Math.sqrt(denom1 * denom2);
                        }
                    }
                    
                    // Analizar la correlaci√≥n
                    if (Math.abs(correlation) > 0.7) {
                        if (correlation > 0) {
                            analysis += `Se observa una fuerte relaci√≥n positiva entre el tama√±o del grupo y el valor promedio (r = ${correlation.toFixed(2)}), `;
                            analysis += `lo que sugiere que los grupos m√°s grandes tienden a tener valores m√°s altos. `;
                        } else {
                            analysis += `Se observa una fuerte relaci√≥n negativa entre el tama√±o del grupo y el valor promedio (r = ${correlation.toFixed(2)}), `;
                            analysis += `lo que sugiere que los grupos m√°s peque√±os tienden a tener valores m√°s altos. `;
                        }
                    } else if (Math.abs(correlation) > 0.3) {
                        if (correlation > 0) {
                            analysis += `Se observa una relaci√≥n moderada positiva entre el tama√±o del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                        } else {
                            analysis += `Se observa una relaci√≥n moderada negativa entre el tama√±o del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                        }
                    } else {
                        analysis += `No se observa una relaci√≥n clara entre el tama√±o del grupo y el valor promedio (r = ${correlation.toFixed(2)}). `;
                    }
                    
                    // An√°lisis de variabilidad intragrupo
                    const variabilities = categories.map(c => stdDevs[c] / averages[c] * 100);  // CV por categor√≠a
                    const avgVariability = variabilities.reduce((sum, val) => sum + val, 0) / variabilities.length;
                    
                    // Categor√≠a con mayor y menor variabilidad
                    const maxVarCatIndex = variabilities.indexOf(Math.max(...variabilities));
                    const minVarCatIndex = variabilities.indexOf(Math.min(...variabilities));
                    
                    analysis += `La variabilidad dentro de los grupos (medida por el coeficiente de variaci√≥n) es en promedio del ${avgVariability.toFixed(1)}%. `;
                    analysis += `"${categories[maxVarCatIndex]}" muestra la mayor heterogeneidad (CV = ${variabilities[maxVarCatIndex].toFixed(1)}%), `;
                    analysis += `mientras que "${categories[minVarCatIndex]}" es el grupo m√°s homog√©neo (CV = ${variabilities[minVarCatIndex].toFixed(1)}%). `;
                    
                    // Test ANOVA simplificado para diferencias entre grupos
                    if (categories.length >= 3) {
                        // Calcular varianza entre grupos
                        const overallMean = avgValues.reduce((sum, val, i) => sum + val * counts[categories[i]], 0) / 
                                          groupSizes.reduce((sum, val) => sum + val, 0);
                        
                        const betweenGroupSS = avgValues.reduce((sum, val, i) => 
                            sum + counts[categories[i]] * Math.pow(val - overallMean, 2), 0);
                        
                        const withinGroupSS = categories.reduce((sum, cat, i) => 
                            sum + counts[cat] * Math.pow(stdDevs[cat], 2), 0);
                        
                        const betweenGroupDF = categories.length - 1;
                        const withinGroupDF = groupSizes.reduce((sum, val) => sum + val, 0) - categories.length;
                        
                        if (withinGroupDF > 0) { // Evitar divisi√≥n por cero
                            const betweenGroupMS = betweenGroupSS / betweenGroupDF;
                            const withinGroupMS = withinGroupSS / withinGroupDF;
                            
                            const fStat = betweenGroupMS / withinGroupMS;
                            
                            if (fStat > 3) {
                                analysis += `El an√°lisis estad√≠stico indica diferencias significativas entre los grupos (F = ${fStat.toFixed(2)}), `;
                                analysis += `lo que sugiere que la variable "${categoryField}" tiene un efecto importante sobre "${numericField}". `;
                            } else if (fStat > 1.5) {
                                analysis += `Hay indicios de diferencias entre los grupos (F = ${fStat.toFixed(2)}), pero no son altamente significativas. `;
                            } else {
                                analysis += `Estad√≠sticamente, las diferencias entre grupos no parecen ser significativas (F = ${fStat.toFixed(2)}). `;
                            }
                        }
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateCombinedAnalysis:`, error);
                document.getElementById(analysisId).textContent = `Error al generar el an√°lisis: ${error.message}`;
            }
        }
        
        // Funci√≥n para generar gr√°fico de serie temporal
        function generateTimeSeriesChart(container, dateField, numericField) {
            try {
                console.log(`Generando gr√°fico de serie temporal: ${dateField} - ${numericField}`);
                
                if (!globalData.dates[dateField] || !globalData.numerics[numericField]) {
                    console.warn(`Campos no v√°lidos para gr√°fico de serie temporal: ${dateField}, ${numericField}`);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const chartId = `chart-time-${dateField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                const analysisId = `analysis-time-${dateField.replace(/\s+/g, '-').toLowerCase()}-${numericField.replace(/\s+/g, '-').toLowerCase()}`;
                
                cardDiv.innerHTML = `
                    <h2>Evoluci√≥n de ${numericField} a lo largo del tiempo</h2>
                    <div class="chart-container">
                        <canvas id="${chartId}"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="${analysisId}">Analizando tendencia temporal...</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Preparar datos agrupados por per√≠odo
                const timeData = {};
                
                globalData.rawData.forEach(record => {
                    if (record[dateField] && record[numericField]) {
                        // Convertir a fecha
                        let dateValue;
                        try {
                            dateValue = new Date(record[dateField]);
                        } catch (e) {
                            return; // Ignorar si no es una fecha v√°lida
                        }
                        
                        if (isNaN(dateValue.getTime())) return; // Ignorar si no es una fecha v√°lida
                        
                        // Agrupar por mes
                        const year = dateValue.getFullYear();
                        const month = dateValue.getMonth() + 1;
                        const period = `${year}-${month.toString().padStart(2, '0')}`;
                        
                        if (!timeData[period]) {
                            timeData[period] = {
                                sum: 0,
                                count: 0,
                                values: []
                            };
                        }
                        
                        const numValue = Number(record[numericField]);
                        if (!isNaN(numValue)) {
                            timeData[period].sum += numValue;
                            timeData[period].count++;
                            timeData[period].values.push(numValue);
                        }
                    }
                });
                
                console.log(`Datos de serie temporal agrupados por per√≠odos`);
                
                // Calcular promedios por per√≠odo
                const timeAvg = {};
                const timeStdDev = {};
                
                Object.keys(timeData).forEach(period => {
                    if (timeData[period].count > 0) {
                        timeAvg[period] = timeData[period].sum / timeData[period].count;
                        
                        // Calcular desviaci√≥n est√°ndar
                        const values = timeData[period].values;
                        const mean = timeAvg[period];
                        const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                        const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
                        timeStdDev[period] = Math.sqrt(variance);
                    }
                });
                
                // Ordenar per√≠odos cronol√≥gicamente
                const sortedPeriods = Object.keys(timeAvg).sort();
                
                if (sortedPeriods.length < 2) {
                    console.warn(`Datos temporales insuficientes para generar gr√°fico de serie temporal`);
                    document.getElementById(analysisId).textContent = `No hay suficientes datos temporales para generar un an√°lisis de tendencia.`;
                    return;
                }
                
                // Formatear etiquetas y datos
                const labels = sortedPeriods.map(period => {
                    const [year, month] = period.split('-');
                    return `${month}/${year}`;
                });
                
                const data = sortedPeriods.map(period => timeAvg[period]);
                const counts = sortedPeriods.map(period => timeData[period].count);
                const stdDevs = sortedPeriods.map(period => timeStdDev[period]);
                
                console.log(`Datos de serie temporal preparados: ${sortedPeriods.length} per√≠odos`);
                
                // Analizar tendencia para generar l√≠nea de tendencia
                const indices = Array.from({length: sortedPeriods.length}, (_, i) => i);
                const trendAnalysis = analyzeTrendAndPredict(indices, data);
                const trendLineData = trendAnalysis.trendValues;
                
                // Crear gr√°fico
                try {
                    const canvas = document.getElementById(chartId);
                    if (!canvas) {
                        console.error(`Elemento canvas ${chartId} no encontrado`);
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.error(`No se pudo obtener el contexto 2D para el canvas ${chartId}`);
                        return;
                    }
                    
                    charts[chartId] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `Promedio de ${numericField}`,
                                data: data,
                                backgroundColor: 'rgba(52, 152, 219, 0.2)',
                                borderColor: reportStyles.primaryColor,
                                borderWidth: 2,
                                tension: 0.3,
                                fill: true
                            }, {
                                label: 'Cantidad de registros',
                                data: counts,
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.accentColor,
                                borderWidth: 2,
                                pointBackgroundColor: reportStyles.accentColor,
                                tension: 0.3,
                                yAxisID: 'y1'
                            }, {
                                label: 'L√≠nea de tendencia',
                                data: trendLineData,
                                backgroundColor: 'transparent',
                                borderColor: reportStyles.secondaryColor,
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                tension: 0,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `Promedio de ${numericField}`
                                    }
                                },
                                y1: {
                                    position: 'right',
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: 'Cantidad de registros'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Per√≠odo'
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        afterLabel: function(context) {
                                            if (context.datasetIndex === 0) {
                                                const period = sortedPeriods[context.dataIndex];
                                                return `Desv. Est.: ${timeStdDev[period].toFixed(2)}`;
                                            }
                                            return '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Gr√°fico de serie temporal creado exitosamente`);
                    
                    // Generar an√°lisis
                    generateTimeSeriesAnalysis(numericField, sortedPeriods, timeAvg, timeData, trendAnalysis, analysisId);
                } catch (chartError) {
                    console.error(`Error al crear gr√°fico de serie temporal:`, chartError);
                    document.getElementById(analysisId).textContent = `Error al crear gr√°fico: ${chartError.message}`;
                }
            } catch (error) {
                console.error(`Error en generateTimeSeriesChart:`, error);
            }
        }
        
        // Funci√≥n mejorada para generar an√°lisis de serie temporal
        function generateTimeSeriesAnalysis(numericField, periods, averages, periodData, trendAnalysis, analysisId) {
            try {
                let analysis = `Este gr√°fico muestra la evoluci√≥n temporal de "${numericField}" a lo largo de ${periods.length} per√≠odos. `;
                
                if (periods.length > 1) {
                    // Calcular variaci√≥n total
                    const firstValue = averages[periods[0]];
                    const lastValue = averages[periods[periods.length - 1]];
                    const totalChange = lastValue - firstValue;
                    const totalChangePerc = (totalChange / firstValue) * 100;
                    
                    // Analizar tendencia general
                    if (Math.abs(totalChangePerc) < 5) {
                        analysis += `Durante el per√≠odo analizado, el valor se ha mantenido relativamente estable `;
                        analysis += `(variaci√≥n total de ${totalChangePerc.toFixed(1)}%). `;
                    } else {
                        if (totalChange > 0) {
                            analysis += `Durante el per√≠odo analizado, el valor ha aumentado un ${totalChangePerc.toFixed(1)}% `;
                            analysis += `(de ${firstValue.toFixed(2)} a ${lastValue.toFixed(2)}). `;
                        } else {
                            analysis += `Durante el per√≠odo analizado, el valor ha disminuido un ${Math.abs(totalChangePerc).toFixed(1)}% `;
                            analysis += `(de ${firstValue.toFixed(2)} a ${lastValue.toFixed(2)}). `;
                        }
                    }
                    
                    // An√°lisis de la tendencia utilizando regresi√≥n lineal
                    if (trendAnalysis && trendAnalysis.trend) {
                        analysis += `La l√≠nea de tendencia muestra una direcci√≥n ${trendAnalysis.trend} `;
                        analysis += `con una ecuaci√≥n ${trendAnalysis.equation}. `;
                        
                        if (trendAnalysis.rSquared > 0.7) {
                            analysis += `El coeficiente de determinaci√≥n R¬≤ = ${trendAnalysis.rSquared.toFixed(2)} indica que la tendencia explica bien la variaci√≥n temporal. `;
                        } else if (trendAnalysis.rSquared > 0.4) {
                            analysis += `El coeficiente de determinaci√≥n R¬≤ = ${trendAnalysis.rSquared.toFixed(2)} sugiere una tendencia moderada. `;
                        } else {
                            analysis += `El bajo coeficiente de determinaci√≥n R¬≤ = ${trendAnalysis.rSquared.toFixed(2)} indica que la tendencia lineal no explica bien la variaci√≥n temporal, `;
                            analysis += `lo que sugiere patrones m√°s complejos o alta variabilidad. `;
                        }
                    }
                    
                    // Analizar la tendencia reciente (√∫ltimos 3 per√≠odos o menos)
                    if (periods.length >= 3) {
                        const recentPeriods = periods.slice(-3);
                        const recentValues = recentPeriods.map(p => averages[p]);
                        
                        let recentTrend = 'estable';
                        if (recentValues[2] > recentValues[0] * 1.05) {
                            recentTrend = 'creciente';
                        } else if (recentValues[2] < recentValues[0] * 0.95) {
                            recentTrend = 'decreciente';
                        }
                        
                        analysis += `En los √∫ltimos 3 per√≠odos, la tendencia ha sido ${recentTrend}. `;
                    }
                    
                    // Identificar picos y valles
                    let maxPeriod = periods[0];
                    let minPeriod = periods[0];
                    
                    periods.forEach(period => {
                        if (averages[period] > averages[maxPeriod]) {
                            maxPeriod = period;
                        }
                        if (averages[period] < averages[minPeriod]) {
                            minPeriod = period;
                        }
                    });
                    
                    const [maxYear, maxMonth] = maxPeriod.split('-');
                    const [minYear, minMonth] = minPeriod.split('-');
                    
                    analysis += `El valor m√°ximo (${averages[maxPeriod].toFixed(2)}) se registr√≥ en ${maxMonth}/${maxYear}, `;
                    analysis += `mientras que el valor m√≠nimo (${averages[minPeriod].toFixed(2)}) se registr√≥ en ${minMonth}/${minYear}. `;
                    
                    // Analizar estacionalidad (mejorado)
                    const monthlyAverages = {};
                    const monthlyCounts = {};
                    
                    periods.forEach(period => {
                        const month = parseInt(period.split('-')[1]);
                        if (!monthlyAverages[month]) {
                            monthlyAverages[month] = {
                                sum: 0,
                                count: 0
                            };
                        }
                        
                        monthlyAverages[month].sum += averages[period];
                        monthlyAverages[month].count++;
                        
                        if (!monthlyCounts[month]) {
                            monthlyCounts[month] = [];
                        }
                        monthlyCounts[month].push(averages[period]);
                    });
                    
                    // Calcular promedios mensuales y variaci√≥n
                    const monthlyAvgs = {};
                    const monthlyVariations = {};
                    
                    Object.keys(monthlyAverages).forEach(month => {
                        if (monthlyAverages[month].count > 0) {
                            monthlyAvgs[month] = monthlyAverages[month].sum / monthlyAverages[month].count;
                            
                            // Calcular variaci√≥n si hay m√°s de un dato
                            if (monthlyCounts[month].length > 1) {
                                const values = monthlyCounts[month];
                                const mean = monthlyAvgs[month];
                                const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                                const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
                                monthlyVariations[month] = Math.sqrt(variance) / mean * 100; // CV porcentual
                            } else {
                                monthlyVariations[month] = 0;
                            }
                        }
                    });
                    
                    // Verificar si hay meses con m√∫ltiples puntos de datos para an√°lisis estacional
                    const monthsWithMultipleData = Object.values(monthlyAvgs).length;
                    
                    if (monthsWithMultipleData >= 3) {
                        // Encontrar el mes con mayor y menor valor promedio
                        const months = Object.keys(monthlyAvgs).map(Number);
                        let maxMonth = months[0];
                        let minMonth = months[0];
                        
                        months.forEach(month => {
                            if (monthlyAvgs[month] > monthlyAvgs[maxMonth]) {
                                maxMonth = month;
                            }
                            if (monthlyAvgs[month] < monthlyAvgs[minMonth]) {
                                minMonth = month;
                            }
                        });
                        
                        // Nombres de meses
                        const monthNames = ['', 'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                                          'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                        
                        // Calcular la diferencia porcentual entre el m√°ximo y m√≠nimo mensual
                        const seasonalVariation = (monthlyAvgs[maxMonth] - monthlyAvgs[minMonth]) / monthlyAvgs[minMonth] * 100;
                        
                        if (seasonalVariation > 20) {
                            analysis += `Se observa un patr√≥n estacional significativo (variaci√≥n del ${seasonalVariation.toFixed(1)}%), `;
                            analysis += `con valores m√°s altos en ${monthNames[maxMonth]} y m√°s bajos en ${monthNames[minMonth]}. `;
                            
                            // Analizar consistencia estacional
                            const highMonthCV = monthlyVariations[maxMonth] || 0;
                            const lowMonthCV = monthlyVariations[minMonth] || 0;
                            
                            if (highMonthCV < 15 && lowMonthCV < 15) {
                                analysis += `Este patr√≥n estacional parece ser consistente a√±o tras a√±o. `;
                            } else {
                                analysis += `Sin embargo, hay variabilidad a√±o a a√±o en estos patrones estacionales. `;
                            }
                        } else if (seasonalVariation > 10) {
                            analysis += `Se observa un patr√≥n estacional moderado, con valores que tienden a ser m√°s altos en ${monthNames[maxMonth]} `;
                            analysis += `y m√°s bajos en ${monthNames[minMonth]}, aunque la variaci√≥n (${seasonalVariation.toFixed(1)}%) no es muy pronunciada. `;
                        } else {
                            analysis += `No se observa un patr√≥n estacional claro en los datos (variaci√≥n mensual m√°xima de ${seasonalVariation.toFixed(1)}%). `;
                        }
                    }
                    
                    // An√°lisis de volatilidad
                    const periodValues = periods.map(p => averages[p]);
                    const periodDiffs = [];
                    for (let i = 1; i < periodValues.length; i++) {
                        periodDiffs.push(Math.abs((periodValues[i] - periodValues[i-1]) / periodValues[i-1] * 100));
                    }
                    
                    if (periodDiffs.length > 0) {
                        const avgChange = periodDiffs.reduce((sum, val) => sum + val, 0) / periodDiffs.length;
                        const maxChange = Math.max(...periodDiffs);
                        const maxChangeIndex = periodDiffs.indexOf(maxChange);
                        const maxChangePeriods = [periods[maxChangeIndex], periods[maxChangeIndex + 1]];
                        
                        if (avgChange > 10) {
                            analysis += `La serie muestra alta volatilidad, con un cambio promedio del ${avgChange.toFixed(1)}% entre per√≠odos consecutivos. `;
                            analysis += `El mayor cambio (${maxChange.toFixed(1)}%) ocurri√≥ entre ${maxChangePeriods[0]} y ${maxChangePeriods[1]}. `;
                        } else if (avgChange > 5) {
                            analysis += `La serie muestra volatilidad moderada, con un cambio promedio del ${avgChange.toFixed(1)}% entre per√≠odos. `;
                        } else {
                            analysis += `La serie es relativamente estable, con cambios promedio del ${avgChange.toFixed(1)}% entre per√≠odos consecutivos. `;
                        }
                    }
                }
                
                document.getElementById(analysisId).textContent = analysis;
            } catch (error) {
                console.error(`Error en generateTimeSeriesAnalysis:`, error);
                document.getElementById(analysisId).textContent = `Error al analizar la serie temporal: ${error.message}`;
            }
        }
        
        // Funci√≥n para generar la secci√≥n de an√°lisis predictivo
        function generatePredictiveSection(container) {
            try {
                console.log('Generando secci√≥n de an√°lisis predictivo...');
                
                // Generar el an√°lisis predictivo
                const predictiveResult = generatePredictiveAnalysis();
                
                if (!predictiveResult.success) {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card full-width';
                    cardDiv.innerHTML = `
                        <h2>An√°lisis Predictivo y Tendencias Futuras</h2>
                        <div class="chart-analysis">
                            <h4>An√°lisis:</h4>
                            <p>${predictiveResult.message || 'No hay suficientes datos para realizar un an√°lisis predictivo.'}</p>
                        </div>
                    `;
                    container.appendChild(cardDiv);
                    return;
                }
                
                const analysis = predictiveResult.analysis;
                console.log('An√°lisis predictivo generado correctamente');
                
                // Crear la secci√≥n de an√°lisis predictivo
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                cardDiv.innerHTML = `
                    <h2>An√°lisis Predictivo y Tendencias Futuras</h2>
                    <div class="stats-container" id="prediction-stats"></div>
                    <div id="forecast-chart-container" class="chart-container" style="display: ${analysis.forecast ? 'block' : 'none'}">
                        <canvas id="forecast-chart"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <h4>Pron√≥sticos y Tendencias:</h4>
                        <p id="forecast-analysis">Analizando tendencias futuras...</p>
                    </div>
                    <div id="correlations-container" style="margin-top: 20px; display: ${analysis.correlations.length > 0 ? 'block' : 'none'}">
                        <h3>Relaciones y Correlaciones Detectadas</h3>
                        <div id="correlations-content" class="table-container"></div>
                    </div>
                    <div id="segments-container" style="margin-top: 20px; display: ${analysis.segments.length > 0 ? 'block' : 'none'}">
                        <h3>Segmentos Identificados</h3>
                        <div id="segments-content"></div>
                    </div>
                    <div class="chart-analysis" style="margin-top: 20px;">
                        <h4>Acciones Recomendadas:</h4>
                        <div id="predictive-recommendations"></div>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Llenar estad√≠sticas predictivas
                const statsContainer = document.getElementById('prediction-stats');
                
                // Estad√≠stica 1: Confianza del modelo
                if (analysis.forecast) {
                    const confidenceStat = document.createElement('div');
                    confidenceStat.className = 'stat-box';
                    confidenceStat.innerHTML = `
                        <h3>Confianza del Pron√≥stico</h3>
                        <p>${analysis.forecast.confidence === 'alta' ? 'Alta' : analysis.forecast.confidence === 'media' ? 'Media' : 'Baja'}</p>
                    `;
                    statsContainer.appendChild(confidenceStat);
                    
                    // Estad√≠stica 2: R-cuadrado
                    const rSquaredStat = document.createElement('div');
                    rSquaredStat.className = 'stat-box';
                    rSquaredStat.innerHTML = `
                        <h3>R¬≤ del Modelo</h3>
                        <p>${(analysis.forecast.rSquared || 0).toFixed(2)}</p>
                    `;
                    statsContainer.appendChild(rSquaredStat);
                }
                
                // Estad√≠stica 3: N√∫mero de segmentos
                if (analysis.segments.length > 0) {
                    const segmentsStat = document.createElement('div');
                    segmentsStat.className = 'stat-box';
                    segmentsStat.innerHTML = `
                        <h3>Segmentos Identificados</h3>
                        <p>${analysis.segments.length}</p>
                    `;
                    statsContainer.appendChild(segmentsStat);
                }
                
                // Estad√≠stica 4: Correlaciones significativas
                if (analysis.correlations.length > 0) {
                    const correlationsStat = document.createElement('div');
                    correlationsStat.className = 'stat-box';
                    correlationsStat.innerHTML = `
                        <h3>Correlaciones Significativas</h3>
                        <p>${analysis.correlations.length}</p>
                    `;
                    statsContainer.appendChild(correlationsStat);
                }
                
                // Generar gr√°fico de pron√≥stico
                if (analysis.forecast) {
                    try {
                        generateForecastChart(analysis.forecast);
                    } catch (error) {
                        console.error('Error al generar gr√°fico de pron√≥stico:', error);
                    }
                }
                
                // Generar tabla de correlaciones
                if (analysis.correlations.length > 0) {
                    try {
                        generateCorrelationsTable(analysis.correlations);
                    } catch (error) {
                        console.error('Error al generar tabla de correlaciones:', error);
                    }
                }
                
                // Generar visualizaci√≥n de segmentos
                if (analysis.segments.length > 0) {
                    try {
                        generateSegmentsVisualization(analysis.segments);
                    } catch (error) {
                        console.error('Error al generar visualizaci√≥n de segmentos:', error);
                    }
                }
                
                // Generar recomendaciones
                try {
                    generatePredictiveRecommendations(analysis.recommendations);
                } catch (error) {
                    console.error('Error al generar recomendaciones predictivas:', error);
                }
                
                // Generar an√°lisis textual del pron√≥stico
                try {
                    generateForecastAnalysis(analysis);
                } catch (error) {
                    console.error('Error al generar an√°lisis de pron√≥stico:', error);
                    document.getElementById('forecast-analysis').textContent = 'Error al generar an√°lisis de pron√≥stico: ' + error.message;
                }
                
                console.log('Secci√≥n de an√°lisis predictivo generada correctamente');
            } catch (error) {
                console.error('Error en generatePredictiveSection:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'card full-width';
                errorDiv.innerHTML = `
                    <h2>Error en el An√°lisis Predictivo</h2>
                    <div class="chart-analysis">
                        <p>Se produjo un error al generar el an√°lisis predictivo: ${error.message}</p>
                    </div>
                `;
                container.appendChild(errorDiv);
            }
        }
        
        // Funci√≥n para generar gr√°fico de pron√≥stico
        function generateForecastChart(forecast) {
            try {
                console.log('Generando gr√°fico de pron√≥stico...');
                
                const chartCanvas = document.getElementById('forecast-chart');
                if (!chartCanvas) {
                    console.error('Elemento canvas forecast-chart no encontrado');
                    return;
                }
                
                // Extraer datos hist√≥ricos y pron√≥sticos
                const dateField = forecast.dateField;
                const valueField = forecast.field;
                
                // Preparar datos hist√≥ricos
                const timeData = {};
                
                globalData.rawData.forEach(record => {
                    if (record[dateField] && record[valueField]) {
                        // Convertir a fecha
                        let dateValue;
                        try {
                            dateValue = new Date(record[dateField]);
                        } catch (e) {
                            return;
                        }
                        
                        if (isNaN(dateValue.getTime())) return;
                        
                        // Agrupar por mes
                        const year = dateValue.getFullYear();
                        const month = dateValue.getMonth() + 1;
                        const period = `${year}-${month.toString().padStart(2, '0')}`;
                        
                        if (!timeData[period]) {
                            timeData[period] = {
                                sum: 0,
                                count: 0
                            };
                        }
                        
                        const numValue = Number(record[valueField]);
                        if (!isNaN(numValue)) {
                            timeData[period].sum += numValue;
                            timeData[period].count++;
                        }
                    }
                });
                
                // Calcular promedios por per√≠odo
                const timeAvg = {};
                Object.keys(timeData).forEach(period => {
                    if (timeData[period].count > 0) {
                        timeAvg[period] = timeData[period].sum / timeData[period].count;
                    }
                });
                
                // Ordenar per√≠odos cronol√≥gicamente
                const sortedPeriods = Object.keys(timeAvg).sort();
                
                // Formatear etiquetas para datos hist√≥ricos
                const historicalLabels = sortedPeriods.map(period => {
                    const [year, month] = period.split('-');
                    return `${month}/${year}`;
                });
                
                const historicalData = sortedPeriods.map(period => timeAvg[period]);
                
                // Formatear etiquetas y datos para pron√≥sticos
                const forecastLabels = forecast.forecast.map(item => {
                    const [year, month] = item.period.split('-');
                    return `${month}/${year}`;
                });
                
                const forecastData = forecast.forecast.map(item => item.value);
                
                // Crear datos combinados para el gr√°fico
                const allLabels = [...historicalLabels, ...forecastLabels];
                
                // Crear datos de pron√≥stico con null para valores hist√≥ricos
                const forecastDataWithNull = [
                    ...Array(historicalLabels.length).fill(null),
                    ...forecastData
                ];
                
                console.log('Datos de pron√≥stico preparados para gr√°fico');
                
                // Crear gr√°fico
                const ctx = chartCanvas.getContext('2d');
                if (!ctx) {
                    console.error('No se pudo obtener el contexto 2D para el canvas forecast-chart');
                    return;
                }
                
                charts['forecast-chart'] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allLabels,
                        datasets: [{
                            label: `Datos hist√≥ricos (${valueField})`,
                            data: [...historicalData, ...Array(forecastLabels.length).fill(null)],
                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
                            borderColor: reportStyles.primaryColor,
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3
                        }, {
                            label: 'Pron√≥stico',
                            data: forecastDataWithNull,
                            backgroundColor: 'rgba(231, 76, 60, 0.2)',
                            borderColor: reportStyles.accentColor,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: valueField
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Per√≠odo'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        const value = context.parsed.y !== null ? context.parsed.y.toFixed(2) : 'N/A';
                                        
                                        if (context.datasetIndex === 1 && context.parsed.y !== null) {
                                            // Es un pron√≥stico
                                            return `${datasetLabel}: ${value} (Predicci√≥n)`;
                                        }
                                        
                                        return `${datasetLabel}: ${value}`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('Gr√°fico de pron√≥stico creado exitosamente');
            } catch (error) {
                console.error('Error en generateForecastChart:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar tabla de correlaciones
        function generateCorrelationsTable(correlations) {
            try {
                console.log('Generando tabla de correlaciones...');
                
                const container = document.getElementById('correlations-content');
                if (!container) {
                    console.error('Contenedor correlations-content no encontrado');
                    return;
                }
                
                let html = `
                    <table>
                        <thead>
                            <tr>
                                <th>Variables</th>
                                <th>Correlaci√≥n</th>
                                <th>Interpretaci√≥n</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                correlations.forEach(corr => {
                    const corrValue = corr.correlation.toFixed(2);
                    const interpretation = `${corr.strength} ${corr.direction}`;
                    
                    html += `
                        <tr>
                            <td>${corr.field1} y ${corr.field2}</td>
                            <td>${corrValue}</td>
                            <td>${interpretation}</td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                    <div class="chart-analysis">
                        <p>Una correlaci√≥n positiva indica que cuando una variable aumenta, la otra tambi√©n tiende a aumentar. 
                        Una correlaci√≥n negativa indica que cuando una variable aumenta, la otra tiende a disminuir.</p>
                    </div>
                `;
                
                container.innerHTML = html;
                console.log('Tabla de correlaciones generada correctamente');
            } catch (error) {
                console.error('Error en generateCorrelationsTable:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar visualizaci√≥n de segmentos
        function generateSegmentsVisualization(segments) {
            try {
                console.log('Generando visualizaci√≥n de segmentos...');
                
                const container = document.getElementById('segments-content');
                if (!container) {
                    console.error('Contenedor segments-content no encontrado');
                    return;
                }
                
                let html = '<div class="stats-container">';
                
                segments.forEach((segment, index) => {
                    const color = [
                        reportStyles.primaryColor,
                        reportStyles.secondaryColor,
                        reportStyles.accentColor,
                        reportStyles.neutralColor
                    ][index % 4];
                    
                    html += `
                        <div class="stat-box" style="border-left-color: ${color}; flex: 1; min-width: 200px;">
                            <h3>${segment.name} (${segment.percentage}%)</h3>
                            <p style="font-size: 1rem; font-weight: normal; margin-top: 5px;">${segment.description}</p>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                container.innerHTML = html;
                console.log('Visualizaci√≥n de segmentos generada correctamente');
            } catch (error) {
                console.error('Error en generateSegmentsVisualization:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar recomendaciones predictivas
        function generatePredictiveRecommendations(recommendations) {
            try {
                console.log('Generando recomendaciones predictivas...');
                
                const container = document.getElementById('predictive-recommendations');
                if (!container) {
                    console.error('Contenedor predictive-recommendations no encontrado');
                    return;
                }
                
                if (recommendations.length === 0) {
                    container.innerHTML = '<p>No hay recomendaciones predictivas disponibles con los datos actuales.</p>';
                    return;
                }
                
                let html = '';
                
                recommendations.forEach((rec, index) => {
                    const priorityClass = rec.confidence === 'alta' ? 'priority-high' : 
                                        rec.confidence === 'media' ? 'priority-medium' : '';
                    
                    html += `
                        <div class="recommendation-item ${priorityClass}">
                            <div class="recommendation-icon">${index + 1}</div>
                            <div class="recommendation-content">
                                <h4>${rec.title}</h4>
                                <p>${rec.description}</p>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                console.log('Recomendaciones predictivas generadas correctamente');
            } catch (error) {
                console.error('Error en generatePredictiveRecommendations:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar an√°lisis textual del pron√≥stico
        function generateForecastAnalysis(analysis) {
            try {
                console.log('Generando an√°lisis textual del pron√≥stico...');
                
                const analysisElement = document.getElementById('forecast-analysis');
                if (!analysisElement) {
                    console.error('Elemento forecast-analysis no encontrado');
                    return;
                }
                
                if (!analysis.forecast) {
                    analysisElement.textContent = 'No hay suficientes datos temporales para generar pron√≥sticos.';
                    return;
                }
                
                let forecastText = '';
                
                // Analizar tendencia
                forecastText += `Los datos de "${analysis.forecast.field}" muestran una tendencia ${analysis.forecast.trend}. `;
                
                // Analizar estacionalidad
                if (analysis.forecast.seasonality && !analysis.forecast.seasonality.includes('no detectada')) {
                    forecastText += `Se ha detectado estacionalidad ${analysis.forecast.seasonality}. `;
                }
                
                // Describir modelo
                forecastText += `El modelo predictivo (${analysis.forecast.equation}) tiene un coeficiente de determinaci√≥n R¬≤ de ${analysis.forecast.rSquared.toFixed(2)}, `;
                forecastText += `lo que indica una ${analysis.forecast.rSquared > 0.7 ? 'alta' : analysis.forecast.rSquared > 0.4 ? 'moderada' : 'baja'} capacidad predictiva. `;
                
                // Describir pron√≥stico
                if (analysis.forecast.forecast.length > 0) {
                    const firstForecast = analysis.forecast.forecast[0];
                    const lastForecast = analysis.forecast.forecast[analysis.forecast.forecast.length - 1];
                    
                    forecastText += `Para el pr√≥ximo per√≠odo (${firstForecast.period}) se prev√© un valor de ${firstForecast.value.toFixed(2)}. `;
                    
                    if (analysis.forecast.forecast.length > 1) {
                        const firstValue = firstForecast.value;
                        const lastValue = lastForecast.value;
                        const change = ((lastValue - firstValue) / firstValue) * 100;
                        
                        if (Math.abs(change) > 5) {
                            forecastText += `Se proyecta que el valor ${change > 0 ? 'aumentar√°' : 'disminuir√°'} un ${Math.abs(change).toFixed(1)}% `;
                            forecastText += `en los pr√≥ximos ${analysis.forecast.forecast.length} per√≠odos. `;
                        } else {
                            forecastText += `Se proyecta que el valor se mantendr√° relativamente estable en los pr√≥ximos per√≠odos. `;
                        }
                    }
                }
                
                // Analizar correlaciones si existen
                if (analysis.correlations.length > 0) {
                    const topCorrelation = analysis.correlations[0];
                    
                    forecastText += `Existe una correlaci√≥n ${topCorrelation.strength} ${topCorrelation.direction} (${topCorrelation.correlation.toFixed(2)}) `;
                    forecastText += `entre "${topCorrelation.field1}" y "${topCorrelation.field2}", lo que puede utilizarse para mejorar la precisi√≥n predictiva. `;
                }
                
                // Mencionar segmentos si existen
                if (analysis.segments.length > 0) {
                    forecastText += `Se han identificado ${analysis.segments.length} segmentos distintos en los datos, `;
                    forecastText += `cada uno con patrones y caracter√≠sticas espec√≠ficas que pueden requerir estrategias diferenciadas. `;
                }
                
                analysisElement.textContent = forecastText;
                console.log('An√°lisis de pron√≥stico generado correctamente');
            } catch (error) {
                console.error('Error en generateForecastAnalysis:', error);
                throw error;
            }
        }
        
        // Funci√≥n para generar tabla de datos con selecci√≥n de campos
        function generateDataTable(container) {
            try {
                console.log('Generando tabla de datos...');
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card full-width';
                
                const tableId = 'data-summary-table';
                
                // Agregar selectores de campo
                cardDiv.innerHTML = `
                    <h2>Resumen de Datos</h2>
                    <div class="field-selector-container">
                        <div class="field-selector">
                            <label for="category-field-selector">Campo categ√≥rico:</label>
                            <select id="category-field-selector" class="field-select">
                                <option value="">Ninguno</option>
                            </select>
                        </div>
                        <div class="field-selector">
                            <label for="numeric-fields-selector">Campos num√©ricos:</label>
                            <select id="numeric-fields-selector" class="field-select" multiple size="4">
                            </select>
                        </div>
                        <button id="update-table-btn" class="btn btn-primary">Actualizar Tabla</button>
                    </div>
                    <div class="print-options">
                        <h4>Opciones de impresi√≥n:</h4>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-data-table" checked> Incluir tabla de datos
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-predictions" checked> Incluir predicciones
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-correlations" checked> Incluir correlaciones
                        </label>
                        <label class="print-checkbox">
                            <input type="checkbox" id="print-segments" checked> Incluir segmentos
                        </label>
                    </div>
                    <div class="table-container">
                        <table id="${tableId}" class="data-table">
                            <thead>
                                <tr id="${tableId}-header"></tr>
                            </thead>
                            <tbody id="${tableId}-body"></tbody>
                        </table>
                    </div>
                    <div class="chart-analysis">
                        <h4>An√°lisis:</h4>
                        <p id="table-analysis">Esta tabla muestra un resumen de los principales hallazgos en los datos analizados.</p>
                    </div>
                `;
                
                container.appendChild(cardDiv);
                
                // Configurar eventos de opciones de impresi√≥n
                document.getElementById('print-data-table').addEventListener('change', function() {
                    printOptions.includeDataTable = this.checked;
                });
                
                document.getElementById('print-predictions').addEventListener('change', function() {
                    printOptions.includePredictions = this.checked;
                });
                
                document.getElementById('print-correlations').addEventListener('change', function() {
                    printOptions.includeCorrelations = this.checked;
                });
                
                document.getElementById('print-segments').addEventListener('change', function() {
                    printOptions.includeSegments = this.checked;
                });
                
                // Llenar selectores de campo
                populateFieldSelectors();
                
                // Configurar evento para actualizar tabla
                document.getElementById('update-table-btn').addEventListener('click', function() {
                    updateDataTable(tableId);
                });
                
                // Crear tabla inicial
                updateDataTable(tableId);
                
                console.log('Tabla de datos generada correctamente');
            } catch (error) {
                console.error('Error en generateDataTable:', error);
                throw error;
            }
        }
        
        // Funci√≥n para llenar los selectores de campo
        function populateFieldSelectors() {
            try {
                console.log('Llenando selectores de campo...');
                
                const categorySelector = document.getElementById('category-field-selector');
                const numericSelector = document.getElementById('numeric-fields-selector');
                
                if (!categorySelector || !numericSelector) {
                    console.error('Selectores de campo no encontrados');
                    return;
                }
                
                // Limpiar selectores
                categorySelector.innerHTML = '<option value="">Ninguno</option>';
                numericSelector.innerHTML = '';
                
                // Llenar selector de campos categ√≥ricos
                const categoryFields = Object.keys(globalData.categories);
                categoryFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    
                    // Seleccionar si est√° en los campos seleccionados
                    if (globalData.selectedFields.categories.includes(field)) {
                        option.selected = true;
                    }
                    
                    categorySelector.appendChild(option);
                });
                
                // Llenar selector de campos num√©ricos
                const numericFields = Object.keys(globalData.numerics);
                numericFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    
                    // Seleccionar si est√° en los campos seleccionados
                    if (globalData.selectedFields.numerics.includes(field)) {
                        option.selected = true;
                    }
                    
                    numericSelector.appendChild(option);
                });
                
                console.log('Selectores de campo llenados correctamente');
            } catch (error) {
                console.error('Error en populateFieldSelectors:', error);
            }
        }
        
        // Funci√≥n para actualizar la tabla con los campos seleccionados
        function updateDataTable(tableId) {
            try {
                console.log('Actualizando tabla de datos...');
                
                // Obtener campos seleccionados
                const categorySelector = document.getElementById('category-field-selector');
                const numericSelector = document.getElementById('numeric-fields-selector');
                
                if (!categorySelector || !numericSelector) {
                    console.error('Selectores de campo no encontrados');
                    return;
                }
                
                // Actualizar campos seleccionados en datos globales
                globalData.selectedFields.categories = [];
                if (categorySelector.value) {
                    globalData.selectedFields.categories = [categorySelector.value];
                }
                
                globalData.selectedFields.numerics = Array.from(numericSelector.selectedOptions).map(option => option.value);
                
                console.log('Campos seleccionados:', globalData.selectedFields);
                
                // Crear encabezado de tabla
                const headerRow = document.getElementById(`${tableId}-header`);
                const tableBody = document.getElementById(`${tableId}-body`);
                
                if (!headerRow || !tableBody) {
                    console.error('Elementos de tabla no encontrados');
                    return;
                }
                
                // Limpiar tabla actual
                headerRow.innerHTML = '';
                tableBody.innerHTML = '';
                
                // Decidir qu√© campos mostrar
                let fieldsToShow = [];
                
                // Mostrar campo categ√≥rico seleccionado
                if (globalData.selectedFields.categories.length > 0) {
                    fieldsToShow.push({
                        type: 'category',
                        field: globalData.selectedFields.categories[0]
                    });
                }
                
                // Mostrar campos num√©ricos seleccionados
                globalData.selectedFields.numerics.forEach(field => {
                    fieldsToShow.push({
                        type: 'numeric',
                        field: field
                    });
                });
                
                // Si no hay campos seleccionados, mostrar mensaje
                if (fieldsToShow.length === 0) {
                    const analysisElement = document.getElementById('table-analysis');
                    if (analysisElement) {
                        analysisElement.textContent = 'Seleccione al menos un campo para mostrar estad√≠sticas.';
                    }
                    return;
                }
                
                // Agregar encabezados
                const headers = ['Estad√≠stica', ...fieldsToShow.map(f => f.field)];
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                
                // Crear filas de estad√≠sticas ampliadas
                const stats = [
                    { name: 'Tipo de datos', fn: (field, type) => globalData.fields[field].type },
                    { name: 'Conteo total', fn: (field, type) => {
                        if (type === 'numeric') {
                            return globalData.numerics[field].stats.count;
                        } else if (type === 'category') {
                            return Object.values(globalData.categories[field].distribution).reduce((a, b) => a + b, 0);
                        }
                        return 'N/A';
                    }},
                    { name: 'Valores √∫nicos', fn: (field, type) => {
                        if (type === 'category') {
                            return globalData.categories[field].uniqueValues.length;
                        } else if (type === 'numeric') {
                            return 'N/A';
                        }
                        return 'N/A';
                    }},
                    { name: 'Valor m√°s frecuente', fn: (field, type) => {
                        if (type === 'category') {
                            const distribution = globalData.categories[field].distribution;
                            const sorted = Object.entries(distribution).sort((a, b) => b[1] - a[1]);
                            if (sorted.length > 0) {
                                return `${sorted[0][0]} (${sorted[0][1]})`;
                            }
                        }
                        return 'N/A';
                    }},
                    { name: 'Frecuencia del valor m√°s com√∫n', fn: (field, type) => {
                        if (type === 'category') {
                            const distribution = globalData.categories[field].distribution;
                            const sorted = Object.entries(distribution).sort((a, b) => b[1] - a[1]);
                            if (sorted.length > 0) {
                                const total = Object.values(distribution).reduce((a, b) => a + b, 0);
                                return `${sorted[0][1]} (${((sorted[0][1]/total)*100).toFixed(2)}%)`;
                            }
                        }
                        return 'N/A';
                    }},
                    { name: 'Valor m√≠nimo', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.min.toFixed(2) : 'N/A' },
                    { name: 'Primer cuartil (Q1)', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.q1.toFixed(2) : 'N/A' },
                    { name: 'Mediana', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.median.toFixed(2) : 'N/A' },
                    { name: 'Tercer cuartil (Q3)', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.q3.toFixed(2) : 'N/A' },
                    { name: 'Valor m√°ximo', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.max.toFixed(2) : 'N/A' },
                    { name: 'Promedio', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.mean.toFixed(2) : 'N/A' },
                    { name: 'Desviaci√≥n est√°ndar', fn: (field, type) => type === 'numeric' ? globalData.numerics[field].stats.std.toFixed(2) : 'N/A' },
                    { name: 'Coef. de variaci√≥n (%)', fn: (field, type) => {
                        if (type === 'numeric') {
                            const stats = globalData.numerics[field].stats;
                            return ((stats.std / stats.mean) * 100).toFixed(2);
                        }
                        return 'N/A';
                    }},
                    { name: 'Asimetr√≠a', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.skewness !== undefined ? 
                        globalData.numerics[field].stats.skewness.toFixed(2) : 'N/A' },
                    { name: 'Curtosis', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.kurtosis !== undefined ? 
                        globalData.numerics[field].stats.kurtosis.toFixed(2) : 'N/A' },
                    { name: 'Outliers detectados', fn: (field, type) => type === 'numeric' && globalData.numerics[field].stats.outliers ? 
                        globalData.numerics[field].stats.outliers.length : 'N/A' }
                ];
                
                // Agregar filas
                stats.forEach(stat => {
                    const row = document.createElement('tr');
                    
                    const nameCell = document.createElement('td');
                    nameCell.textContent = stat.name;
                    row.appendChild(nameCell);
                    
                    fieldsToShow.forEach(fieldInfo => {
                        const cell = document.createElement('td');
                        cell.textContent = stat.fn(fieldInfo.field, fieldInfo.type);
                        row.appendChild(cell);
                    });
                    
                    tableBody.appendChild(row);
                });
                
                // Actualizar an√°lisis de tabla
                const analysisElement = document.getElementById('table-analysis');
                if (analysisElement) {
                    const fieldsText = fieldsToShow.map(f => `"${f.field}"`).join(', ');
                    analysisElement.textContent = `Esta tabla muestra un resumen estad√≠stico detallado de los campos ${fieldsText}. Puede seleccionar diferentes campos para analizar otras variables de inter√©s.`;
                }
                
                console.log('Tabla de datos actualizada correctamente');
            } catch (error) {
                console.error('Error en updateDataTable:', error);
                const analysisElement = document.getElementById('table-analysis');
                if (analysisElement) {
                    analysisElement.textContent = `Error al actualizar la tabla: ${error.message}`;
                }
            }
        }
        
        // Funci√≥n para generar an√°lisis y recomendaciones
        function generateAnalysisAndRecommendations() {
            try {
                console.log('Generando an√°lisis y recomendaciones...');
                
                const conclusionElement = document.getElementById('general-conclusion');
                const recommendationsContainer = document.getElementById('recommendations-container');
                
                if (!conclusionElement || !recommendationsContainer) {
                    console.error('Elementos de an√°lisis y recomendaciones no encontrados');
                    return;
                }
                
                // Generar conclusi√≥n general
                let conclusion = `An√°lisis de ${globalData.totalRecords} registros con ${Object.keys(globalData.fields).length} campos. `;
                
                // An√°lisis de campos categ√≥ricos
                const categoryFields = Object.keys(globalData.categories);
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const categoryValues = globalData.categories[mainCategory].uniqueValues.length;
                    
                    conclusion += `Se identificaron ${categoryValues} valores √∫nicos en el campo principal "${mainCategory}". `;
                    
                    // Analizar concentraci√≥n
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1]);
                    
                    if (sortedValues.length > 0) {
                        const topValue = sortedValues[0];
                        const topPercentage = ((topValue[1] / globalData.totalRecords) * 100).toFixed(1);
                        
                        if (parseFloat(topPercentage) > 50) {
                            conclusion += `Existe una alta concentraci√≥n en el valor "${topValue[0]}" (${topPercentage}% del total). `;
                        } else if (parseFloat(topPercentage) > 30) {
                            conclusion += `El valor "${topValue[0]}" representa una proporci√≥n significativa (${topPercentage}%). `;
                        }
                    }
                }
                
                // An√°lisis de campos num√©ricos
                const numericFields = Object.keys(globalData.numerics);
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    // Analizar dispersi√≥n
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        conclusion += `El campo "${mainNumeric}" muestra una alta variabilidad (CV = ${cv.toFixed(1)}%), `;
                        conclusion += `lo que indica una distribuci√≥n heterog√©nea de valores. `;
                    } else if (cv > 20) {
                        conclusion += `El campo "${mainNumeric}" muestra una variabilidad moderada (CV = ${cv.toFixed(1)}%). `;
                    } else {
                        conclusion += `El campo "${mainNumeric}" muestra valores bastante homog√©neos (CV = ${cv.toFixed(1)}%). `;
                    }
                    
                    // An√°lisis de asimetr√≠a si est√° disponible
                    if (stats.skewness !== undefined) {
                        if (Math.abs(stats.skewness) > 1) {
                            conclusion += `La distribuci√≥n presenta una fuerte asimetr√≠a ${stats.skewness > 0 ? 'positiva' : 'negativa'} (${stats.skewness.toFixed(2)}), `;
                            conclusion += `lo que afecta la interpretaci√≥n de las medidas centrales. `;
                        }
                    }
                    
                    // An√°lisis de outliers
                    if (stats.outliers && stats.outliers.length > 0) {
                        const outlierPerc = (stats.outliers.length / stats.count * 100).toFixed(1);
                        conclusion += `Se identificaron ${stats.outliers.length} valores at√≠picos (${outlierPerc}%) que podr√≠an requerir atenci√≥n especial. `;
                    }
                }
                
                // An√°lisis de campos de fecha
                const dateFields = Object.keys(globalData.dates);
                if (dateFields.length > 0) {
                    conclusion += `La presencia de campos de fecha permite analizar tendencias temporales y realizar pron√≥sticos. `;
                    
                    // Incluir resultados del an√°lisis predictivo si hay disponibles
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.forecast) {
                        const forecast = predictiveResult.analysis.forecast;
                        conclusion += `El an√°lisis predictivo indica una tendencia ${forecast.trend} para el campo "${forecast.field}" `;
                        conclusion += `con un nivel de confianza ${forecast.confidence}. `;
                    }
                }
                
                // Actualizar elemento de conclusi√≥n
                conclusionElement.textContent = conclusion;
                
                // Generar recomendaciones
                recommendationsContainer.innerHTML = '';
                
                // Lista de recomendaciones basadas en el an√°lisis
                const recommendations = [];
                
                // Recomendaci√≥n basada en campos categ√≥ricos
                if (categoryFields.length > 0) {
                    const mainCategory = categoryFields[0];
                    const distribution = globalData.categories[mainCategory].distribution;
                    const sortedValues = Object.entries(distribution)
                        .sort((a, b) => b[1] - a[1]);
                    
                    if (sortedValues.length > 5) {
                        const topValues = sortedValues.slice(0, 3);
                        const topCount = topValues.reduce((sum, item) => sum + item[1], 0);
                        const topPercentage = ((topCount / globalData.totalRecords) * 100).toFixed(1);
                        
                        if (parseFloat(topPercentage) > 60) {
                            recommendations.push({
                                title: `Profundizar an√°lisis en categor√≠as principales de "${mainCategory}"`,
                                content: `Los 3 valores principales (${topValues.map(v => v[0]).join(', ')}) representan el ${topPercentage}% de los datos. Se recomienda realizar un an√°lisis espec√≠fico de estos segmentos para identificar patrones distintivos.`,
                                priority: 'high'
                            });
                        } else {
                            recommendations.push({
                                title: `Segmentar an√°lisis por categor√≠as de "${mainCategory}"`,
                                content: `Evaluar el comportamiento de las diferentes categor√≠as para identificar posibles variaciones significativas en los indicadores principales.`,
                                priority: 'medium'
                            });
                        }
                    }
                }
                
                // Recomendaci√≥n basada en campos num√©ricos
                if (numericFields.length > 0) {
                    const mainNumeric = numericFields[0];
                    const stats = globalData.numerics[mainNumeric].stats;
                    
                    // Analizar dispersi√≥n
                    const cv = (stats.std / stats.mean) * 100;
                    
                    if (cv > 50) {
                        recommendations.push({
                            title: `Investigar valores extremos en "${mainNumeric}"`,
                            content: `La alta variabilidad (CV = ${cv.toFixed(1)}%) sugiere la presencia de valores extremos. Se recomienda identificar y analizar estos casos para determinar si son errores de datos o valores at√≠picos leg√≠timos que requieren atenci√≥n especial.`,
                            priority: 'high'
                        });
                    }
                    
                    // Recomendaci√≥n basada en outliers
                    if (stats.outliers && stats.outliers.length > 5) {
                        recommendations.push({
                            title: `Tratar valores at√≠picos identificados`,
                            content: `Se detectaron ${stats.outliers.length} valores at√≠picos en "${mainNumeric}". Considere aplicar t√©cnicas de winsorizaci√≥n o transformaci√≥n para reducir su impacto en los an√°lisis estad√≠sticos.`,
                            priority: 'medium'
                        });
                    }
                    
                    // Recomendaci√≥n basada en asimetr√≠a
                    if (stats.skewness !== undefined && Math.abs(stats.skewness) > 1.5) {
                        recommendations.push({
                            title: `Considerar transformaci√≥n de datos para "${mainNumeric}"`,
                            content: `La distribuci√≥n muestra una fuerte asimetr√≠a (${stats.skewness.toFixed(2)}). Para an√°lisis estad√≠sticos m√°s precisos, considere aplicar una transformaci√≥n ${stats.skewness > 0 ? 'logar√≠tmica o ra√≠z cuadrada' : 'cuadr√°tica o exponencial'} para normalizar los datos.`,
                            priority: 'medium'
                        });
                    }
                }
                
                // Recomendaci√≥n basada en campos de fecha
                if (dateFields.length > 0 && numericFields.length > 0) {
                    recommendations.push({
                        title: 'Realizar an√°lisis de tendencias temporales',
                        content: 'Aprovechar los campos de fecha para analizar la evoluci√≥n de los indicadores clave a lo largo del tiempo, identificando patrones estacionales y tendencias a largo plazo.',
                        priority: 'medium'
                    });
                    
                    // A√±adir recomendaci√≥n de pron√≥stico si hay suficientes datos
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.forecast) {
                        const forecast = predictiveResult.analysis.forecast;
                        
                        if (forecast.trend.includes('creciente')) {
                            recommendations.push({
                                title: `Preparar recursos para tendencia creciente en "${forecast.field}"`,
                                content: `El an√°lisis predictivo muestra una tendencia ${forecast.trend} con ${forecast.confidence} confianza. Se recomienda planificar recursos adicionales para adaptarse a este crecimiento proyectado.`,
                                priority: 'high'
                            });
                        } else if (forecast.trend.includes('decreciente')) {
                            recommendations.push({
                                title: `Estrategias para mitigar tendencia decreciente en "${forecast.field}"`,
                                content: `El an√°lisis predictivo muestra una tendencia ${forecast.trend} con ${forecast.confidence} confianza. Se recomienda implementar estrategias correctivas para contrarrestar esta tendencia negativa.`,
                                priority: 'high'
                            });
                        }
                        
                        if (forecast.seasonality && !forecast.seasonality.includes('no detectada')) {
                            recommendations.push({
                                title: `Adaptar recursos a patrones estacionales detectados`,
                                content: `Se ha identificado estacionalidad ${forecast.seasonality} en "${forecast.field}". Se recomienda ajustar la asignaci√≥n de recursos de forma anticipada para estos ciclos recurrentes.`,
                                priority: 'medium'
                            });
                        }
                    }
                }
                
                // Recomendaci√≥n basada en correlaciones
                if (numericFields.length >= 2) {
                    const predictiveResult = generatePredictiveAnalysis();
                    if (predictiveResult.success && predictiveResult.analysis.correlations.length > 0) {
                        const mainCorrelation = predictiveResult.analysis.correlations[0];
                        
                        recommendations.push({
                            title: `Aprovechar correlaci√≥n entre "${mainCorrelation.field1}" y "${mainCorrelation.field2}"`,
                            content: `Se ha detectado una correlaci√≥n ${mainCorrelation.strength} ${mainCorrelation.direction} (${mainCorrelation.correlation.toFixed(2)}) entre estas variables. Esta relaci√≥n puede ser explotada para optimizar estrategias y recursos.`,
                            priority: mainCorrelation.strength === 'fuerte' ? 'high' : 'medium'
                        });
                    }
                }
                
                // Recomendaci√≥n general
                recommendations.push({
                    title: 'Enriquecer los datos con variables adicionales',
                    content: 'Considerar la inclusi√≥n de variables contextuales adicionales que puedan enriquecer el an√°lisis y proporcionar nuevas perspectivas sobre los patrones observados.',
                    priority: 'low'
                });
                
                // Agregar recomendaciones al contenedor
                recommendations.forEach((rec, index) => {
                    const recElement = document.createElement('div');
                    recElement.className = `recommendation-item priority-${rec.priority}`;
                    recElement.innerHTML = `
                        <div class="recommendation-icon">${index + 1}</div>
                        <div class="recommendation-content">
                            <h4>${rec.title}</h4>
                            <p>${rec.content}</p>
                        </div>
                    `;
                    recommendationsContainer.appendChild(recElement);
                });
                
                console.log('An√°lisis y recomendaciones generados correctamente');
            } catch (error) {
                console.error('Error en generateAnalysisAndRecommendations:', error);
                
                const conclusionElement = document.getElementById('general-conclusion');
                if (conclusionElement) {
                    conclusionElement.textContent = 'Error al generar el an√°lisis: ' + error.message;
                }
                
                const recommendationsContainer = document.getElementById('recommendations-container');
                if (recommendationsContainer) {
                    recommendationsContainer.innerHTML = `
                        <div class="recommendation-item">
                            <div class="recommendation-icon">!</div>
                            <div class="recommendation-content">
                                <h4>Error al generar recomendaciones</h4>
                                <p>Se produjo un error al analizar los datos y generar recomendaciones: ${error.message}</p>
                            </div>
                        </div>
                    `;
                }
            }
        }
        
        // Funci√≥n para configurar filtros din√°micos
        function setupDynamicFilters() {
            try {
                console.log('Configurando filtros din√°micos...');
                
                const dynamicFiltersContainer = document.getElementById('dynamic-filters');
                if (!dynamicFiltersContainer) {
                    console.error('Contenedor de filtros din√°micos no encontrado');
                    return;
                }
                
                dynamicFiltersContainer.innerHTML = '';
                
                // Solo mostrar filtros si hay datos
                if (globalData.totalRecords === 0) return;
                
                document.getElementById('applied-filters').style.display = 'block';
                
                // Crear filtros para campos categ√≥ricos principales (max 3)
                const categoryFields = Object.keys(globalData.categories);
                categoryFields.slice(0, 3).forEach(field => {
                    const fieldInfo = globalData.categories[field];
                    
                    if (fieldInfo.uniqueValues.length <= 20) {
                        const filterGroup = document.createElement('div');
                        filterGroup.className = 'filter-group';
                        
                        const label = document.createElement('label');
                        label.textContent = field;
                        
                        const select = document.createElement('select');
                        select.id = `filter-${field.replace(/\s+/g, '-').toLowerCase()}`;
                        select.className = 'filter-select';
                        select.setAttribute('data-field', field);
                        
                        // Opci√≥n para todos
                        const allOption = document.createElement('option');
                        allOption.value = 'all';
                        allOption.textContent = 'Todos';
                        select.appendChild(allOption);
                        
                        // Ordenar valores por frecuencia
                        const sortedValues = Object.entries(fieldInfo.distribution)
                            .sort((a, b) => b[1] - a[1])
                            .map(item => item[0]);
                        
                        // Agregar opciones
                        sortedValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            select.appendChild(option);
                        });
                        
                        // Evento para aplicar filtro
                        select.addEventListener('change', applyDynamicFilters);
                        
                        filterGroup.appendChild(label);
                        filterGroup.appendChild(select);
                        
                        dynamicFiltersContainer.appendChild(filterGroup);
                    }
                });
                
                // Bot√≥n para limpiar filtros
                if (categoryFields.length > 0) {
                    const clearButton = document.createElement('button');
                    clearButton.className = 'btn btn-warning';
                    clearButton.textContent = 'Limpiar Filtros';
                    clearButton.addEventListener('click', clearFilters);
                    
                    dynamicFiltersContainer.appendChild(clearButton);
                }
                
                console.log('Filtros din√°micos configurados correctamente');
            } catch (error) {
                console.error('Error en setupDynamicFilters:', error);
            }
        }
        
        // Funci√≥n para mostrar/ocultar panel de filtros
        function toggleFilterPanel() {
            const appliedFilters = document.getElementById('applied-filters');
            appliedFilters.style.display = appliedFilters.style.display === 'none' || appliedFilters.style.display === '' ? 'block' : 'none';
        }
        
        // Funci√≥n para aplicar filtros din√°micos
        function applyDynamicFilters() {
            try {
                console.log('Aplicando filtros din√°micos...');
                
                // Obtener todos los filtros aplicados
                const filters = {};
                document.querySelectorAll('.filter-select').forEach(select => {
                    if (select.value !== 'all') {
                        filters[select.getAttribute('data-field')] = select.value;
                    }
                });
                
                console.log('Filtros aplicados:', filters);
                
                // Si no hay filtros, restaurar datos originales
                if (Object.keys(filters).length === 0) {
                    clearFilters();
                    return;
                }
                
                // Guardar filtros aplicados
                globalData.appliedFilters = filters;
                
                // Filtrar datos a partir de los datos originales
                if (originalData) {
                    const filteredData = originalData.rawData.filter(record => {
                        // Comprobar si cumple todos los filtros
                        return Object.entries(filters).every(([field, value]) => {
                            return String(record[field]) === String(value);
                        });
                    });
                    
                    console.log(`Datos filtrados: ${filteredData.length} registros`);
                    
                    // Crear un nuevo objeto de datos globales
                    globalData = {
                        totalRecords: filteredData.length,
                        fields: {},
                        categories: {},
                        numerics: {},
                        dates: {},
                        appliedFilters: filters,
                        rawData: filteredData,
                        selectedFields: JSON.parse(JSON.stringify(originalData.selectedFields))
                    };
                    
                    // Reprocesar los datos filtrados para recalcular estad√≠sticas
                    if (filteredData.length > 0) {
                        const fieldNames = Object.keys(filteredData[0]);
                        
                        // Analizar cada campo para detectar su tipo
                        fieldNames.forEach(field => {
                            try {
                                globalData.fields[field] = analyzeField(filteredData, field);
                            } catch (fieldError) {
                                console.error(`Error al analizar el campo ${field}:`, fieldError);
                                globalData.fields[field] = {
                                    name: field,
                                    type: 'unknown',
                                    uniqueValues: [],
                                    distribution: {},
                                    stats: {}
                                };
                            }
                        });
                        
                        // Clasificar campos por tipo
                        fieldNames.forEach(field => {
                            const fieldInfo = globalData.fields[field];
                            
                            if (fieldInfo.type === 'date') {
                                globalData.dates[field] = fieldInfo;
                            } else if (fieldInfo.type === 'numeric') {
                                globalData.numerics[field] = fieldInfo;
                            } else if (fieldInfo.type === 'categorical') {
                                globalData.categories[field] = fieldInfo;
                            }
                        });
                    }
                    
                    // Actualizar dashboard
                    generateDashboard();
                    
                    // Mostrar badges de filtros aplicados
                    displayFilterBadges(filters);
                }
                
                console.log('Filtros aplicados correctamente');
            } catch (error) {
                console.error('Error en applyDynamicFilters:', error);
                showAlert('error-alert', 'Error al aplicar filtros: ' + error.message);
            }
        }
        
        // Funci√≥n para mostrar badges de filtros aplicados
        function displayFilterBadges(filters) {
            try {
                console.log('Mostrando badges de filtros aplicados...');
                
                const badgesContainer = document.getElementById('filter-badges');
                if (!badgesContainer) {
                    console.error('Contenedor de badges de filtros no encontrado');
                    return;
                }
                
                badgesContainer.innerHTML = '';
                
                Object.entries(filters).forEach(([field, value]) => {
                    const badge = document.createElement('div');
                    badge.className = 'filter-badge';
                    badge.textContent = `${field}: ${value}`;
                    badgesContainer.appendChild(badge);
                });
                
                console.log('Badges de filtros mostrados correctamente');
            } catch (error) {
                console.error('Error en displayFilterBadges:', error);
            }
        }
        
        // Funci√≥n para limpiar filtros
        function clearFilters() {
            try {
                console.log('Limpiando filtros...');
                
                if (!originalData) {
                    console.warn('No hay datos originales para restaurar');
                    return;
                }
                
                // Restaurar datos originales
                globalData = JSON.parse(JSON.stringify(originalData));
                
                // Limpiar selectores de filtro
                document.querySelectorAll('.filter-select').forEach(select => {
                    select.value = 'all';
                });
                
                // Limpiar badges de filtros
                const badgesContainer = document.getElementById('filter-badges');
                if (badgesContainer) {
                    badgesContainer.innerHTML = '';
                }
                
                // Regenerar dashboard
                generateDashboard();
                
                console.log('Filtros limpiados correctamente');
            } catch (error) {
                console.error('Error en clearFilters:', error);
                showAlert('error-alert', 'Error al limpiar filtros: ' + error.message);
            }
        }
        
        // Funci√≥n mejorada para imprimir informe
        function printReport() {
            try {
                console.log('Preparando informe para impresi√≥n...');
                
                // Si no hay datos, mostrar mensaje
                if (globalData.totalRecords === 0) {
                    showAlert('info-alert', 'No hay datos para imprimir. Primero debe cargar y procesar datos.');
                    return;
                }
                
                // Mostrar loader
                document.getElementById('loader').style.display = 'block';
                
                // Actualizar t√≠tulo y subt√≠tulo del informe
                document.getElementById('print-title').textContent = document.getElementById('report-title').value;
                document.getElementById('print-subtitle').textContent = document.getElementById('report-subtitle').value;
                
                // Mostrar cabecera personalizada
                document.getElementById('header-custom').style.display = 'block';
                
                // Actualizar fecha actual
                const now = new Date();
                document.getElementById('current-date').textContent = now.toLocaleDateString();
                
                // Aplicar opciones de impresi√≥n
                applyPrintOptions();
                
                // Dar tiempo para que se actualice el DOM antes de imprimir
                setTimeout(() => {
                    // Ocultar el loader
                    document.getElementById('loader').style.display = 'none';
                    
                    // Imprimir
                    window.print();
                    
                    // Restaurar opciones de impresi√≥n
                    restorePrintOptions();
                    
                    // Ocultar cabecera personalizada despu√©s de imprimir
                    setTimeout(() => {
                        document.getElementById('header-custom').style.display = 'none';
                    }, 1000);
                    
                    console.log('Impresi√≥n del informe completada');
                }, 500);
            } catch (error) {
                console.error('Error en printReport:', error);
                document.getElementById('loader').style.display = 'none';
                showAlert('error-alert', 'Error al preparar el informe para impresi√≥n: ' + error.message);
            }
        }
        
        // Funci√≥n para aplicar opciones de impresi√≥n
        function applyPrintOptions() {
            try {
                console.log('Aplicando opciones de impresi√≥n...');
                
                // Ocultar secciones seg√∫n las opciones seleccionadas
                const dataTable = document.querySelector('.card:has(#data-summary-table)');
                if (dataTable && !printOptions.includeDataTable) {
                    dataTable.classList.add('print-hide');
                }
                
                const predictionSection = document.querySelector('.card:has(#forecast-chart-container)');
                if (predictionSection && !printOptions.includePredictions) {
                    predictionSection.classList.add('print-hide');
                }
                
                const correlationsContainer = document.getElementById('correlations-container');
                if (correlationsContainer && !printOptions.includeCorrelations) {
                    correlationsContainer.dataset.originalDisplay = correlationsContainer.style.display;
                    correlationsContainer.style.display = 'none';
                }
                
                const segmentsContainer = document.getElementById('segments-container');
                if (segmentsContainer && !printOptions.includeSegments) {
                    segmentsContainer.dataset.originalDisplay = segmentsContainer.style.display;
                    segmentsContainer.style.display = 'none';
                }
                
                console.log('Opciones de impresi√≥n aplicadas correctamente');
            } catch (error) {
                console.error('Error en applyPrintOptions:', error);
            }
        }
        
        // Funci√≥n para restaurar opciones de impresi√≥n
        function restorePrintOptions() {
            try {
                console.log('Restaurando opciones de impresi√≥n...');
                
                // Restaurar visibilidad de secciones
                document.querySelectorAll('.print-hide').forEach(element => {
                    element.classList.remove('print-hide');
                });
                
                const correlationsContainer = document.getElementById('correlations-container');
                if (correlationsContainer) {
                    correlationsContainer.style.display = correlationsContainer.dataset.originalDisplay || '';
                }
                
                const segmentsContainer = document.getElementById('segments-container');
                if (segmentsContainer) {
                    segmentsContainer.style.display = segmentsContainer.dataset.originalDisplay || '';
                }
                
                console.log('Opciones de impresi√≥n restauradas correctamente');
            } catch (error) {
                console.error('Error en restorePrintOptions:', error);
            }
        }
        
        // Funci√≥n para generar colores basados en un color base
        function generateColors(count) {
            // Colores base
            const baseColors = [
                reportStyles.primaryColor,
                reportStyles.secondaryColor,
                reportStyles.accentColor,
                reportStyles.neutralColor,
                shiftHue(reportStyles.primaryColor, 30),
                shiftHue(reportStyles.secondaryColor, 30),
                shiftHue(reportStyles.accentColor, 30),
                shiftHue(reportStyles.primaryColor, -30),
                shiftHue(reportStyles.secondaryColor, -30),
                shiftHue(reportStyles.accentColor, -30)
            ];
            
            // Si hay suficientes colores base, usarlos
            if (count <= baseColors.length) {
                return baseColors.slice(0, count);
            }
            
            // Si necesitamos m√°s colores, generar colores adicionales
            const colors = [...baseColors];
            
            for (let i = baseColors.length; i < count; i++) {
                // Generar un color basado en la posici√≥n
                const hue = (i * 137) % 360; // Distribuci√≥n uniforme del matiz
                colors.push(`hsl(${hue}, 70%, 60%)`);
            }
            
            return colors;
        }
        
        // Funci√≥n para cambiar el matiz de un color
        function shiftHue(hexColor, amount) {
            // Convertir hex a RGB
            const r = parseInt(hexColor.slice(1, 3), 16) / 255;
            const g = parseInt(hexColor.slice(3, 5), 16) / 255;
            const b = parseInt(hexColor.slice(5, 7), 16) / 255;
            
            // Convertir RGB a HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Acrom√°tico
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Modificar matiz
            h = (h * 360 + amount) % 360;
            if (h < 0) h += 360;
            h /= 360;
            
            // Convertir HSL a RGB
            let r1, g1, b1;
            
            if (s === 0) {
                r1 = g1 = b1 = l; // Acrom√°tico
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r1 = hue2rgb(p, q, h + 1/3);
                g1 = hue2rgb(p, q, h);
                b1 = hue2rgb(p, q, h - 1/3);
            }
            
            // Convertir RGB a hex
            const toHex = x => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`;
        }
        
        // Funci√≥n para actualizar colores de los gr√°ficos
        function updateChartsColors() {
            try {
                console.log('Actualizando colores de los gr√°ficos...');
                
                for (const chartId in charts) {
                    if (charts[chartId]) {
                        const chart = charts[chartId];
                        
                        if (chart.config.type === 'pie') {
                            chart.data.datasets[0].backgroundColor = generateColors(chart.data.labels.length);
                        } else if (chart.config.type === 'bar') {
                            if (chart.data.datasets.length === 1) {
                                chart.data.datasets[0].backgroundColor = reportStyles.primaryColor;
                                chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                            } else if (chart.data.datasets.length >= 2) {
                                chart.data.datasets[0].backgroundColor = reportStyles.primaryColor;
                                chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                                chart.data.datasets[1].backgroundColor = reportStyles.secondaryColor;
                                chart.data.datasets[1].borderColor = reportStyles.secondaryColor;
                            }
                        } else if (chart.config.type === 'line') {
                            chart.data.datasets[0].borderColor = reportStyles.primaryColor;
                            chart.data.datasets[0].backgroundColor = `${reportStyles.primaryColor}33`; // Con transparencia
                            
                            if (chart.data.datasets.length >= 2) {
                                chart.data.datasets[1].borderColor = reportStyles.accentColor;
                                chart.data.datasets[1].backgroundColor = `${reportStyles.accentColor}33`;
                            }
                            
                            if (chart.data.datasets.length >= 3) {
                                chart.data.datasets[2].borderColor = reportStyles.secondaryColor;
                            }
                        }
                        
                        chart.update();
                    }
                }
                
                console.log('Colores de gr√°ficos actualizados correctamente');
            } catch (error) {
                console.error('Error en updateChartsColors:', error);
            }
        }
    </script>
</body>
</html>
